<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="width=device-width,initial-scale=1.0" name="viewport">
    <title>迷宫</title>
    <script src="../js/utils/load.js" charset="utf-8"></script>
    <script src="https://cdn.wilddog.com/sdk/js/2.5.17/wilddog.js"></script>
    <script src="https://cdn.bootcss.com/pako/1.0.5/pako.min.js"></script>
    <style media="screen">
      html, body{
        padding: 0px;
        margin: 0px;
        overflow: hidden;
      }
    </style>
  </head>
  <body>

  </body>
  <script comment="SizeUtil" type="text/javascript">
    class SizeUtil {
      constructor(width, height, padding) {
        this.width = width
        this.height = height
        this.innerWidth = window.innerWidth
        this.innerHeight = window.innerHeight
        this.padding = padding

        var step1 = parseInt((this.innerWidth-padding*2)/this.width)
        var step2 = parseInt((this.innerHeight-padding*2)/this.height)

        this.step = Math.min(step1, step2)

        var mazeWidth = width * this.step
        var mazeHeight = height * this.step

        this.leftPadding = parseInt((this.innerWidth - mazeWidth)/2)
        this.topPadding = parseInt((this.innerHeight - mazeHeight)/2)

      }
    }
  </script>
  <script comment="画布" type="text/javascript">
    class Scene {
      constructor(size, timer) {
        this.size = size
        this.timer = timer
        this.models = []
        this.canvas = document.createElement('canvas')
        this.initCanvas()
      }

      addModel(model){
        this.models.push(model)
      }

      render() {
        const {models, g, size} = this
        g.clearRect(0,0,size.innerWidth,size.innerHeight)
        models.forEach((model)=>{
          model.render(g)
        })
      }

      initCanvas(){
        const {canvas, size} = this
        this.g = canvas.getContext('2d')
        document.body.append(canvas)
        canvas.width = size.innerWidth
        canvas.height = size.innerHeight
        canvas.style.background = '#EEE'
      }
    }
  </script>
  <script comment="迷宫" type="text/javascript">
    class Maze {
      constructor(size, timer, network) {
        this.size = size
        this.timer = timer
        this.network = network
        this.walls = []
        this.models = []
        this.mazeAnimEnd = false
        this.create()
        this.init()
      }

      init(){
        document.body.addEventListener('keydown',(e)=>{
          if(!this.mazeAnimEnd) return
          this.role[e.code] = true
        })
        document.body.addEventListener('keyup',(e)=>{
          if(!this.mazeAnimEnd) return
          this.role[e.code] = false
        })
      }

      create(){
        this.walls = []
        const {walls, size, network} = this
        const {width, height} = size

        if (network.data&&network.data.walls) {
          console.log(network.data);
          this.walls = JSON.parse(pako.inflate(network.data.walls, { to: 'string' }))
          for (var username in network.data.players) {
            this.addModel(new Player(size,network.ref.child('players'),username))
          }
          return
        }

        var wallMap = {}
        for (var j = 0; j < height; j++) {
          for (var i = 0; i < width; i++) {
            wallMap[i+'-'+j] = { x:i, y:j, l:true, t:true, r:true, b:true }
          }
        }

        var stack = []
        var cur = wallMap['0-0']
        delete wallMap['0-0']
        cur.check = true
        // 入口
        cur.l=false
        // 出口
        wallMap[`${width-1}-${height-1}`].r=false
        walls.push(cur)
        while (true) {
          // find neighbors
          let nbs = []
          let x = cur.x
          let y = cur.y
          if (wallMap[`${x-1}-${y}`]) { nbs.push(wallMap[`${x-1}-${y}`]) }
          if (wallMap[`${x}-${y-1}`]) { nbs.push(wallMap[`${x}-${y-1}`]) }
          if (wallMap[`${x+1}-${y}`]) { nbs.push(wallMap[`${x+1}-${y}`]) }
          if (wallMap[`${x}-${y+1}`]) { nbs.push(wallMap[`${x}-${y+1}`]) }
          if (nbs.length > 0) {
            stack.push(cur)
            let o = cur
            cur = nbs[parseInt(nbs.length*Math.random())]
            walls.push(cur)
            let n = cur
            delete wallMap[`${cur.x}-${cur.y}`]
            n.check = true
            if (o.x-1==n.x) { o.l=n.r=false }
            if (o.x+1==n.x) { o.r=n.l=false }
            if (o.y-1===n.y) { o.t=n.b=false }
            if (o.y+1==n.y) { o.b=n.t=false }
          } else {
            cur = Math.random()>0.9?stack.shift():stack.pop()
            if (!cur) { break }
          }
        }

        if (network.data) {
          network.ref.child('walls').set(pako.deflate(JSON.stringify(walls), { to: 'string' }))
        }
      }

      addRole(role){
        this.role = role
        this.addModel(role)
      }

      addModel(model){
        this.models.push(model)
      }

      render(g) {
        const {models, size, walls, mazeAnimEnd} = this
        const {leftPadding, topPadding} = size
        g.save()
        g.translate(leftPadding,topPadding)
        this.drawWalls(g, walls)
        if (mazeAnimEnd) {
          models.forEach((model)=>{
            model.render(g)
          })
        }
        g.restore()
      }

      drawWalls(g, wall){
        const {walls, timer} = this
        var time = timer.startDelta
        var wallSize = time / 1
        g.beginPath()
        g.strokeStyle = 'blue'
        g.lineWidth = 1.5
        for (var i = 0; i < wallSize && i < walls.length; i++) {
          this.drawWall(g, walls[i])
        }
        g.stroke()
        g.closePath()

        if (wallSize > walls.length) {
          this.mazeAnimEnd = true
        } else {
          this.mazeAnimEnd = false
        }
      }

      drawWall(g, wall){
        const {x,y,l,t,r,b} = wall
        var step = this.size.step
        var x_ = x * step + step/2
        var y_ = y * step + step/2
        if (l) {
          g.moveTo(x_-step/2,y_-step/2)
          g.lineTo(x_-step/2,y_+step/2)
        }
        if (t) {
          g.moveTo(x_-step/2,y_-step/2)
          g.lineTo(x_+step/2,y_-step/2)
        }
        if (r) {
          g.moveTo(x_+step/2,y_-step/2)
          g.lineTo(x_+step/2,y_+step/2)
        }
        if (b) {
          g.moveTo(x_-step/2,y_+step/2)
          g.lineTo(x_+step/2,y_+step/2)
        }
      }
    }
  </script>
  <script comment="Role" type="text/javascript">
    class Role {
      constructor(size, timer, playerRef,successCallback) {
        this.name = parseInt(10000*Math.random())
        this.walls = []
        this.playerRef = playerRef
        this.successCallback = successCallback
        this.size = size
        this.timer = timer
        this.ArrowDown = false
        this.ArrowUp = false
        this.ArrowLeft = false
        this.ArrowRight = false
        this.posX = 0
        this.posY = 0
        this.speed = 0.3
        this.gameover = false
        this.loadHead()
      }

      reset(){
        this.posX = 0
        this.posY = 0
        this.gameover = false
      }

      loadHead(){
        var img = new Image()
        img.src = `https://www.gravatar.com/avatar/${encodeURIComponent(this.name)}?s=40&d=monsterid`
        img.crossOrigin = 'Anonymous'
        img.onload= ()=>{
          var c = document.createElement('canvas')
          c.width = img.width
          c.height = img.height
          var g = c.getContext('2d')
          g.drawImage(img,0,0)
          var imgData = g.getImageData(0,0,img.width,img.height)
          let buf = imgData.data
          this.color = buf.slice(0,4)
          for (var i = 0; i < buf.length; i++) {
            let r = buf[i*4+0]
            let g = buf[i*4+1]
            let b = buf[i*4+2]
            let a = buf[i*4+3]
            if (r==this.color[0]&&g==this.color[1]&&b==this.color[2]){
              buf[i*4+3] = 0
            }
          }
          g.putImageData(imgData,0,0)
          img.onload = ()=>{
            this.img = img
          }
          img.src = c.toDataURL()
        }
      }

      setWallMap(wallMap){
        this.wallMap = wallMap
      }

      render(g){
        const {canvas,size,img,posX,posY} = this
        if (!img) { return }
        this.countPosition()
        const {step} = size
        const {width, height} = img
        var scale = 0.8 * step/width
        var pl = (step - width*scale) / 2
        var pt = (step - height*scale) / 2

        g.save()
        g.translate(pl,pt)
        g.beginPath()
        g.drawImage(img,posX,posY,width*scale,height*scale)
        g.closePath()
        g.restore()
      }

      countPosition(){
        const {wallMap,timer,speed,posX,posY,canvas,size,img,ArrowDown, ArrowUp, ArrowLeft, ArrowRight,gameover} = this
        if (!wallMap) { return }
        if (gameover) { return }
        const {step} = size

        if (ArrowDown) { this.posY+=timer.delta*speed }
        if (ArrowUp) { this.posY-=timer.delta*speed }
        if (ArrowLeft) { this.posX-=timer.delta*speed }
        if (ArrowRight) { this.posX+=timer.delta*speed }

        let x = parseInt((posX+step/2)/step)
        let y = parseInt((posY+step/2)/step)

        if (x<0) { x = 0; this.posX = 0 }
        if (x >= size.width) {
          x = size.width - 1; this.posX = step*x
          if (y == size.height - 1) {
            this.gameover = true
            this.successCallback()
            console.log('success');
            return ;
          }
        }
        if (y<0) { y = 0; this.posY = 0 }
        if (y >= size.height) { y = size.height - 1; this.posY = step*y }

        let p = wallMap[`${x}-${y}`]
        let pX = x*step
        let pY = y*step

        if (pX>this.posX&&p.l) { this.posX = pX }
        if (pX<this.posX&&p.r) { this.posX = pX }
        if (pY>this.posY&&p.t) { this.posY = pY }
        if (pY<this.posY&&p.b) { this.posY = pY }

        if (!ArrowLeft &&!ArrowRight) { this.posX = pX }
        if (!ArrowDown &&!ArrowUp) { this.posY = pY }

        if ((this.lastX != this.posX || this.lastY != this.posY)&&(!ArrowDown&&!ArrowUp&&!ArrowLeft&&!ArrowRight)) {
          this.playerRef.child(`${this.name}`).set([this.posX,this.posY])
          [this.lastX,this.lastY] = [this.posX,this.posY]
        }

      }
    }
  </script>
  <script comment="Player" type="text/javascript">
    class Player {
      constructor(size,playerRef,username) {
        this.size = size
        this.playerRef = playerRef
        this.username = username
        this.posX = 0
        this.posY = 0
        this.loadHead()
        this.register()
      }

      loadHead(){
        const {username} = this
        var img = new Image()
        img.src = `https://www.gravatar.com/avatar/${encodeURIComponent(username)}uuuuu?s=40&d=monsterid`
        console.log(`https://www.gravatar.com/avatar/${encodeURIComponent(username)}uuuu?s=40&d=monsterid`);
        img.crossOrigin = 'Anonymous'
        img.onload= ()=>{
          var c = document.createElement('canvas')
          c.width = img.width
          c.height = img.height
          var g = c.getContext('2d')
          g.drawImage(img,0,0)
          var imgData = g.getImageData(0,0,img.width,img.height)
          let buf = imgData.data
          this.color = buf.slice(0,4)
          for (var i = 0; i < buf.length; i++) {
            let r = buf[i*4+0]
            let g = buf[i*4+1]
            let b = buf[i*4+2]
            let a = buf[i*4+3]
            if (r==this.color[0]&&g==this.color[1]&&b==this.color[2]){
              buf[i*4+3] = 0
            }
          }
          g.putImageData(imgData,0,0)
          img.onload = ()=>{
            this.img = img
          }
          img.src = c.toDataURL()
        }
      }

      render(g){
        const {canvas,size,img,posX,posY} = this
        if (!img) { return }
        const {step} = size
        const {width, height} = img
        var scale = 0.8 * step/width
        var pl = (step - width*scale) / 2
        var pt = (step - height*scale) / 2

        g.save()
        g.translate(pl,pt)
        g.beginPath()
        g.drawImage(img,posX,posY,width*scale,height*scale)
        g.closePath()
        g.restore()
      }

      register(){
        this.playerRef.child(encodeURIComponent(this.username)).on('value',(data)=>{
          // [this.posX,this.posY] = data.val()
        })
      }
    }
  </script>
  <script comment="Timer" type="text/javascript">
    class Timer {
      constructor() {
        this.lastTime = Date.now()
        this.startTime = Date.now()
        this.delta = 0
        this.startDelta = 0
      }

      render(){
        this.delta = Date.now() - this.lastTime
        this.startDelta = Date.now() - this.startTime
        this.lastTime = Date.now()
      }

      start(){
        this.delta = 0
        this.startTime = Date.now()
      }

    }
  </script>
  <script comment="Network" type="text/javascript">
    class Network {
      constructor(callback) {
        wilddog.initializeApp({ syncURL: "https://ylw-wuziqi.wilddogio.com" });
        this.ref = wilddog.sync().ref("/maze");
        window.ref = this.ref
        this.ref.once('value', (snapshot, prev)=> {
          this.data = snapshot.val();
          callback()
        },(error)=>{
          alert(error)
          console.error(error);
        });
      }
    }
  </script>
  <script comment="main" type="text/javascript">
    class App {
      constructor() {
        var network = new Network(()=>{
          this.timer = new Timer()
          var size = new SizeUtil(5,3,100)
          var maze = new Maze(size, this.timer,network)
          var role = new Role(size, this.timer,network.ref.child('players'),()=>{
            // onsuccess
            network.ref.child('players').remove()
            network.ref.child('players').child(role.name).set([0,0])
            network.data.walls = null
            maze.models = []
            maze.addRole(role)
            maze.create()
            role.reset()
            var wallMap = {}
            maze.walls.forEach((wall)=>{
              wallMap[`${wall.x}-${wall.y}`] = wall
            })
            role.setWallMap(wallMap)
            this.timer.start()
          })
          var wallMap = {}
          maze.walls.forEach((wall)=>{
            wallMap[`${wall.x}-${wall.y}`] = wall
          })
          role.setWallMap(wallMap)
          this.sence = new Scene(size, this.timer)
          this.sence.addModel(maze)
          maze.addRole(role)
          this.render()
        })
      }

      render(){
        const {sence, timer} = this
        sence.render()
        timer.render()
        requestAnimationFrame(()=>{
          this.render()
        })
      }
    }
    new App()
  </script>
</html>
