(function () {
	'use strict';

	var DEV = false;

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var index_of = Array.prototype.indexOf;
	var array_from = Array.from;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var get_descriptors = Object.getOwnPropertyDescriptors;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;
	var is_extensible = Object.isExtensible;

	/** @param {Function} fn */
	function run(fn) {
		return fn();
	}

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	/**
	 * TODO replace with Promise.withResolvers once supported widely enough
	 * @template T
	 */
	function deferred() {
		/** @type {(value: T) => void} */
		var resolve;

		/** @type {(reason: any) => void} */
		var reject;

		/** @type {Promise<T>} */
		var promise = new Promise((res, rej) => {
			resolve = res;
			reject = rej;
		});

		// @ts-expect-error
		return { promise, resolve, reject };
	}

	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const BOUNDARY_EFFECT = 1 << 7;
	const UNOWNED = 1 << 8;
	const DISCONNECTED = 1 << 9;
	const CLEAN = 1 << 10;
	const DIRTY = 1 << 11;
	const MAYBE_DIRTY = 1 << 12;
	const INERT = 1 << 13;
	const DESTROYED = 1 << 14;
	const EFFECT_RAN = 1 << 15;
	/** 'Transparent' effects do not create a transition boundary */
	const EFFECT_TRANSPARENT = 1 << 16;
	const INSPECT_EFFECT = 1 << 17;
	const HEAD_EFFECT = 1 << 18;
	const EFFECT_PRESERVED = 1 << 19;
	const USER_EFFECT = 1 << 20;

	// Flags used for async
	const REACTION_IS_UPDATING = 1 << 21;
	const ASYNC = 1 << 22;

	const ERROR_VALUE = 1 << 23;

	const STATE_SYMBOL = Symbol('$state');
	const LEGACY_PROPS = Symbol('legacy props');

	/** allow users to ignore aborted signal errors if `reason.name === 'StaleReactionError` */
	const STALE_REACTION = new (class StaleReactionError extends Error {
		name = 'StaleReactionError';
		message = 'The reaction that called `getAbortSignal()` was re-run or destroyed';
	})();

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `%name%(...)` can only be used during component initialisation
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_outside_component(name) {
		{
			throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `%rune%` cannot be used inside an effect cleanup function
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_in_teardown(rune) {
		{
			throw new Error(`https://svelte.dev/e/effect_in_teardown`);
		}
	}

	/**
	 * Effect cannot be created inside a `$derived` value that was not itself created inside an effect
	 * @returns {never}
	 */
	function effect_in_unowned_derived() {
		{
			throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
		}
	}

	/**
	 * `%rune%` can only be used inside an effect (e.g. during component initialisation)
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_orphan(rune) {
		{
			throw new Error(`https://svelte.dev/e/effect_orphan`);
		}
	}

	/**
	 * Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		{
			throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
		}
	}

	/**
	 * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value
	 * @param {string} key
	 * @returns {never}
	 */
	function props_invalid_value(key) {
		{
			throw new Error(`https://svelte.dev/e/props_invalid_value`);
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		{
			throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		{
			throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
		}
	}

	/**
	 * Updating state inside `$derived(...)`, `$inspect(...)` or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		{
			throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
		}
	}

	const PROPS_IS_RUNES = 1 << 1;
	const PROPS_IS_UPDATED = 1 << 2;
	const PROPS_IS_BINDABLE = 1 << 3;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const UNINITIALIZED = Symbol();

	/** @import { Equals } from '#client' */

	/** @type {Equals} */
	function equals(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	let legacy_mode_flag = false;
	let tracing_mode_flag = false;

	function enable_legacy_mode_flag() {
		legacy_mode_flag = true;
	}

	/** @import { ComponentContext, DevStackEntry, Effect } from '#client' */

	/** @type {ComponentContext | null} */
	let component_context = null;

	/** @param {ComponentContext | null} context */
	function set_component_context(context) {
		component_context = context;
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push(props, runes = false, fn) {
		component_context = {
			p: component_context,
			c: null,
			e: null,
			s: props,
			x: null,
			l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
		};
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		var context = /** @type {ComponentContext} */ (component_context);
		var effects = context.e;

		if (effects !== null) {
			context.e = null;

			for (var fn of effects) {
				create_user_effect(fn);
			}
		}

		component_context = context.p;

		return /** @type {T} */ ({});
	}

	/** @returns {boolean} */
	function is_runes() {
		return !legacy_mode_flag || (component_context !== null && component_context.l === null);
	}

	/** @import { Derived, Effect } from '#client' */
	/** @import { Boundary } from './dom/blocks/boundary.js' */

	const adjustments = new WeakMap();

	/**
	 * @param {unknown} error
	 */
	function handle_error(error) {
		var effect = active_effect;

		// for unowned deriveds, don't throw until we read the value
		if (effect === null) {
			/** @type {Derived} */ (active_reaction).f |= ERROR_VALUE;
			return error;
		}

		if ((effect.f & EFFECT_RAN) === 0) {
			// if the error occurred while creating this subtree, we let it
			// bubble up until it hits a boundary that can handle it
			if ((effect.f & BOUNDARY_EFFECT) === 0) {
				if (!effect.parent && error instanceof Error) {
					apply_adjustments(error);
				}

				throw error;
			}

			/** @type {Boundary} */ (effect.b).error(error);
		} else {
			// otherwise we bubble up the effect tree ourselves
			invoke_error_boundary(error, effect);
		}
	}

	/**
	 * @param {unknown} error
	 * @param {Effect | null} effect
	 */
	function invoke_error_boundary(error, effect) {
		while (effect !== null) {
			if ((effect.f & BOUNDARY_EFFECT) !== 0) {
				try {
					/** @type {Boundary} */ (effect.b).error(error);
					return;
				} catch (e) {
					error = e;
				}
			}

			effect = effect.parent;
		}

		if (error instanceof Error) {
			apply_adjustments(error);
		}

		throw error;
	}

	/**
	 * @param {Error} error
	 */
	function apply_adjustments(error) {
		const adjusted = adjustments.get(error);

		if (adjusted) {
			define_property(error, 'message', {
				value: adjusted.message
			});

			define_property(error, 'stack', {
				value: adjusted.stack
			});
		}
	}

	/** @type {Array<() => void>} */
	let micro_tasks = [];

	function run_micro_tasks() {
		var tasks = micro_tasks;
		micro_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (micro_tasks.length === 0 && true) {
			var tasks = micro_tasks;
			queueMicrotask(() => {
				// If this is false, a flushSync happened in the meantime. Do _not_ run new scheduled microtasks in that case
				// as the ordering of microtasks would be broken at that point - consider this case:
				// - queue_micro_task schedules microtask A to flush task X
				// - synchronously after, flushSync runs, processing task X
				// - synchronously after, some other microtask B is scheduled, but not through queue_micro_task but for example a Promise.resolve() in user code
				// - synchronously after, queue_micro_task schedules microtask C to flush task Y
				// - one tick later, microtask A now resolves, flushing task Y before microtask B, which is incorrect
				// This if check prevents that race condition (that realistically will only happen in tests)
				if (tasks === micro_tasks) run_micro_tasks();
			});
		}

		micro_tasks.push(fn);
	}

	/** @import { Derived, Effect, Source } from '#client' */
	/** @import { Batch } from './batch.js'; */

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived(fn) {
		var flags = DERIVED | DIRTY;
		var parent_derived =
			active_reaction !== null && (active_reaction.f & DERIVED) !== 0
				? /** @type {Derived} */ (active_reaction)
				: null;

		if (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) {
			flags |= UNOWNED;
		} else {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_PRESERVED;
		}

		/** @type {Derived<V>} */
		const signal = {
			ctx: component_context,
			deps: null,
			effects: null,
			equals,
			f: flags,
			fn,
			reactions: null,
			rv: 0,
			v: /** @type {V} */ (UNINITIALIZED),
			wv: 0,
			parent: parent_derived ?? active_effect,
			ac: null
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_effects(derived) {
		var effects = derived.effects;

		if (effects !== null) {
			derived.effects = null;

			for (var i = 0; i < effects.length; i += 1) {
				destroy_effect(/** @type {Effect} */ (effects[i]));
			}
		}
	}

	/**
	 * @param {Derived} derived
	 * @returns {Effect | null}
	 */
	function get_derived_parent_effect(derived) {
		var parent = derived.parent;
		while (parent !== null) {
			if ((parent.f & DERIVED) === 0) {
				return /** @type {Effect} */ (parent);
			}
			parent = parent.parent;
		}
		return null;
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(get_derived_parent_effect(derived));

		{
			try {
				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);

		if (!derived.equals(value)) {
			derived.v = value;
			derived.wv = increment_write_version();
		}

		// don't mark derived clean if we're reading it inside a
		// cleanup function, or it will cache a stale value
		if (is_destroying_effect) {
			return;
		}

		{
			var status =
				(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

			set_signal_status(derived, status);
		}
	}

	/** @import { Derived, Effect, Source } from '#client' */

	/** @type {Set<Batch>} */
	const batches = new Set();

	/** @type {Batch | null} */
	let current_batch = null;

	/** @type {Set<() => void>} */
	let effect_pending_updates = new Set();

	/** @type {Effect[]} */
	let queued_root_effects = [];

	/** @type {Effect | null} */
	let last_scheduled_effect = null;

	let is_flushing = false;

	class Batch {
		/**
		 * The current values of any sources that are updated in this batch
		 * They keys of this map are identical to `this.#previous`
		 * @type {Map<Source, any>}
		 */
		current = new Map();

		/**
		 * The values of any sources that are updated in this batch _before_ those updates took place.
		 * They keys of this map are identical to `this.#current`
		 * @type {Map<Source, any>}
		 */
		#previous = new Map();

		/**
		 * When the batch is committed (and the DOM is updated), we need to remove old branches
		 * and append new ones by calling the functions added inside (if/each/key/etc) blocks
		 * @type {Set<() => void>}
		 */
		#callbacks = new Set();

		/**
		 * The number of async effects that are currently in flight
		 */
		#pending = 0;

		/**
		 * A deferred that resolves when the batch is committed, used with `settled()`
		 * TODO replace with Promise.withResolvers once supported widely enough
		 * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
		 */
		#deferred = null;

		/**
		 * True if an async effect inside this batch resolved and
		 * its parent branch was already deleted
		 */
		#neutered = false;

		/**
		 * Async effects (created inside `async_derived`) encountered during processing.
		 * These run after the rest of the batch has updated, since they should
		 * always have the latest values
		 * @type {Effect[]}
		 */
		#async_effects = [];

		/**
		 * The same as `#async_effects`, but for effects inside a newly-created
		 * `<svelte:boundary>` — these do not prevent the batch from committing
		 * @type {Effect[]}
		 */
		#boundary_async_effects = [];

		/**
		 * Template effects and `$effect.pre` effects, which run when
		 * a batch is committed
		 * @type {Effect[]}
		 */
		#render_effects = [];

		/**
		 * The same as `#render_effects`, but for `$effect` (which runs after)
		 * @type {Effect[]}
		 */
		#effects = [];

		/**
		 * Block effects, which may need to re-run on subsequent flushes
		 * in order to update internal sources (e.g. each block items)
		 * @type {Effect[]}
		 */
		#block_effects = [];

		/**
		 * Deferred effects (which run after async work has completed) that are DIRTY
		 * @type {Effect[]}
		 */
		#dirty_effects = [];

		/**
		 * Deferred effects that are MAYBE_DIRTY
		 * @type {Effect[]}
		 */
		#maybe_dirty_effects = [];

		/**
		 * A set of branches that still exist, but will be destroyed when this batch
		 * is committed — we skip over these during `process`
		 * @type {Set<Effect>}
		 */
		skipped_effects = new Set();

		/**
		 *
		 * @param {Effect[]} root_effects
		 */
		process(root_effects) {
			queued_root_effects = [];

			for (const root of root_effects) {
				this.#traverse_effect_tree(root);
			}

			// if we didn't start any new async work, and no async work
			// is outstanding from a previous flush, commit
			if (this.#async_effects.length === 0 && this.#pending === 0) {
				this.#commit();

				var render_effects = this.#render_effects;
				var effects = this.#effects;

				this.#render_effects = [];
				this.#effects = [];
				this.#block_effects = [];
				current_batch = null;

				flush_queued_effects(render_effects);
				flush_queued_effects(effects);

				// Reinstate the current batch if there was no new one created, as `process()` runs in a loop in `flush_effects()`.
				// That method expects `current_batch` to be set, and could run the loop again if effects result in new effects
				// being scheduled but without writes happening in which case no new batch is created.
				if (current_batch === null) {
					current_batch = this;
				} else {
					batches.delete(this);
				}

				this.#deferred?.resolve();
			} else {
				this.#defer_effects(this.#render_effects);
				this.#defer_effects(this.#effects);
				this.#defer_effects(this.#block_effects);
			}

			for (const effect of this.#async_effects) {
				update_effect(effect);
			}

			for (const effect of this.#boundary_async_effects) {
				update_effect(effect);
			}

			this.#async_effects = [];
			this.#boundary_async_effects = [];
		}

		/**
		 * Traverse the effect tree, executing effects or stashing
		 * them for later execution as appropriate
		 * @param {Effect} root
		 */
		#traverse_effect_tree(root) {
			root.f ^= CLEAN;

			var effect = root.first;

			while (effect !== null) {
				var flags = effect.f;
				var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
				var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;

				var skip = is_skippable_branch || (flags & INERT) !== 0 || this.skipped_effects.has(effect);

				if (!skip && effect.fn !== null) {
					if (is_branch) {
						effect.f ^= CLEAN;
					} else if ((flags & EFFECT) !== 0) {
						this.#effects.push(effect);
					} else if ((flags & CLEAN) === 0) {
						if ((flags & ASYNC) !== 0) {
							var effects = effect.b?.is_pending()
								? this.#boundary_async_effects
								: this.#async_effects;

							effects.push(effect);
						} else if (is_dirty(effect)) {
							if ((effect.f & BLOCK_EFFECT) !== 0) this.#block_effects.push(effect);
							update_effect(effect);
						}
					}

					var child = effect.first;

					if (child !== null) {
						effect = child;
						continue;
					}
				}

				var parent = effect.parent;
				effect = effect.next;

				while (effect === null && parent !== null) {
					effect = parent.next;
					parent = parent.parent;
				}
			}
		}

		/**
		 * @param {Effect[]} effects
		 */
		#defer_effects(effects) {
			for (const e of effects) {
				const target = (e.f & DIRTY) !== 0 ? this.#dirty_effects : this.#maybe_dirty_effects;
				target.push(e);

				// mark as clean so they get scheduled if they depend on pending async state
				set_signal_status(e, CLEAN);
			}

			effects.length = 0;
		}

		/**
		 * Associate a change to a given source with the current
		 * batch, noting its previous and current values
		 * @param {Source} source
		 * @param {any} value
		 */
		capture(source, value) {
			if (!this.#previous.has(source)) {
				this.#previous.set(source, value);
			}

			this.current.set(source, source.v);
		}

		activate() {
			current_batch = this;
		}

		deactivate() {
			current_batch = null;

			for (const update of effect_pending_updates) {
				effect_pending_updates.delete(update);
				update();

				if (current_batch !== null) {
					// only do one at a time
					break;
				}
			}
		}

		neuter() {
			this.#neutered = true;
		}

		flush() {
			if (queued_root_effects.length > 0) {
				flush_effects();
			} else {
				this.#commit();
			}

			if (current_batch !== this) {
				// this can happen if a `flushSync` occurred during `flush_effects()`,
				// which is permitted in legacy mode despite being a terrible idea
				return;
			}

			if (this.#pending === 0) {
				batches.delete(this);
			}

			this.deactivate();
		}

		/**
		 * Append and remove branches to/from the DOM
		 */
		#commit() {
			if (!this.#neutered) {
				for (const fn of this.#callbacks) {
					fn();
				}
			}

			this.#callbacks.clear();
		}

		increment() {
			this.#pending += 1;
		}

		decrement() {
			this.#pending -= 1;

			if (this.#pending === 0) {
				for (const e of this.#dirty_effects) {
					set_signal_status(e, DIRTY);
					schedule_effect(e);
				}

				for (const e of this.#maybe_dirty_effects) {
					set_signal_status(e, MAYBE_DIRTY);
					schedule_effect(e);
				}

				this.#render_effects = [];
				this.#effects = [];

				this.flush();
			} else {
				this.deactivate();
			}
		}

		/** @param {() => void} fn */
		add_callback(fn) {
			this.#callbacks.add(fn);
		}

		settled() {
			return (this.#deferred ??= deferred()).promise;
		}

		static ensure() {
			if (current_batch === null) {
				const batch = (current_batch = new Batch());
				batches.add(current_batch);

				{
					Batch.enqueue(() => {
						if (current_batch !== batch) {
							// a flushSync happened in the meantime
							return;
						}

						batch.flush();
					});
				}
			}

			return current_batch;
		}

		/** @param {() => void} task */
		static enqueue(task) {
			queue_micro_task(task);
		}
	}

	function flush_effects() {
		var was_updating_effect = is_updating_effect;
		is_flushing = true;

		try {
			var flush_count = 0;
			set_is_updating_effect(true);

			while (queued_root_effects.length > 0) {
				var batch = Batch.ensure();

				if (flush_count++ > 1000) {
					var updates, entry; if (DEV) ;

					infinite_loop_guard();
				}

				batch.process(queued_root_effects);
				old_values.clear();
			}
		} finally {
			is_flushing = false;
			set_is_updating_effect(was_updating_effect);

			last_scheduled_effect = null;
		}
	}

	function infinite_loop_guard() {
		try {
			effect_update_depth_exceeded();
		} catch (error) {

			// Best effort: invoke the boundary nearest the most recent
			// effect and hope that it's relevant to the infinite loop
			invoke_error_boundary(error, last_scheduled_effect);
		}
	}

	/** @type {Effect[] | null} */
	let eager_block_effects = null;

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		var i = 0;

		while (i < length) {
			var effect = effects[i++];

			if ((effect.f & (DESTROYED | INERT)) === 0 && is_dirty(effect)) {
				eager_block_effects = [];

				update_effect(effect);

				// Effects with no dependencies or teardown do not get added to the effect tree.
				// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
				// don't know if we need to keep them until they are executed. Doing the check
				// here (rather than in `update_effect`) allows us to skip the work for
				// immediate effects.
				if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
					// if there's no teardown or abort controller we completely unlink
					// the effect from the graph
					if (effect.teardown === null && effect.ac === null) {
						// remove this effect from the graph
						unlink_effect(effect);
					} else {
						// keep the effect in the graph, but free up some memory
						effect.fn = null;
					}
				}

				// If update_effect() has a flushSync() in it, we may have flushed another flush_queued_effects(),
				// which already handled this logic and did set eager_block_effects to null.
				if (eager_block_effects?.length > 0) {
					// TODO this feels incorrect! it gets the tests passing
					old_values.clear();

					for (const e of eager_block_effects) {
						update_effect(e);
					}

					eager_block_effects = [];
				}
			}
		}

		eager_block_effects = null;
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		var effect = (last_scheduled_effect = signal);

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			// if the effect is being scheduled because a parent (each/await/etc) block
			// updated an internal source, bail out or we'll cause a second flush
			if (is_flushing && effect === active_effect && (flags & BLOCK_EFFECT) !== 0) {
				return;
			}

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/** @import { Derived, Effect, Source, Value } from '#client' */

	/** @type {Map<Source, any>} */
	const old_values = new Map();

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 * @returns {Source<V>}
	 */
	// TODO rename this to `state` throughout the codebase
	function source(v, stack) {
		/** @type {Value} */
		var signal = {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals,
			rv: 0,
			wv: 0
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function state(v, stack) {
		const s = source(v);

		push_reaction_value(s);

		return s;
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false, trackable = true) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		// bind the signal to the component context, in case we need to
		// track updates to trigger beforeUpdate/afterUpdate callbacks
		if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
			(component_context.l.s ??= []).push(s);
		}

		return s;
	}

	/**
	 * @template V
	 * @param {Value<V>} source
	 * @param {V} value
	 */
	function mutate(source, value) {
		set(
			source,
			untrack(() => get(source))
		);
		return value;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @param {boolean} [should_proxy]
	 * @returns {V}
	 */
	function set(source, value, should_proxy = false) {
		if (
			active_reaction !== null &&
			// since we are untracking the function inside `$inspect.with` we need to add this check
			// to ensure we error if state is set inside an inspect effect
			(!untracking || (active_reaction.f & INSPECT_EFFECT) !== 0) &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | INSPECT_EFFECT)) !== 0 &&
			!current_sources?.includes(source)
		) {
			state_unsafe_mutation();
		}

		let new_value = should_proxy ? proxy(value) : value;

		return internal_set(source, new_value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			var old_value = source.v;

			if (is_destroying_effect) {
				old_values.set(source, value);
			} else {
				old_values.set(source, old_value);
			}

			source.v = value;

			var batch = Batch.ensure();
			batch.capture(source, old_value);

			if ((source.f & DERIVED) !== 0) {
				// if we are assigning to a dirty derived we set it to clean/maybe dirty but we also eagerly execute it to track the dependencies
				if ((source.f & DIRTY) !== 0) {
					execute_derived(/** @type {Derived} */ (source));
				}
				set_signal_status(source, (source.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
			}

			source.wv = increment_write_version();

			mark_reactions(source, DIRTY);

			// It's possible that the current reaction might not have up-to-date dependencies
			// whilst it's actively running. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				is_runes() &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0
			) {
				if (untracked_writes === null) {
					set_untracked_writes([source]);
				} else {
					untracked_writes.push(source);
				}
			}
		}

		return value;
	}

	/**
	 * Silently (without using `get`) increment a source
	 * @param {Source<number>} source
	 */
	function increment(source) {
		set(source, source.v + 1);
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		var runes = is_runes();
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// In legacy mode, skip the current effect to prevent infinite loops
			if (!runes && reaction === active_effect) continue;

			var not_dirty = (flags & DIRTY) === 0;

			// don't set a DIRTY reaction to MAYBE_DIRTY
			if (not_dirty) {
				set_signal_status(reaction, status);
			}

			if ((flags & DERIVED) !== 0) {
				mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
			} else if (not_dirty) {
				if ((flags & BLOCK_EFFECT) !== 0) {
					if (eager_block_effects !== null) {
						eager_block_effects.push(/** @type {Effect} */ (reaction));
					}
				}

				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/** @import { Source } from '#client' */

	/**
	 * @template T
	 * @param {T} value
	 * @returns {T}
	 */
	function proxy(value) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = state(0);
		var parent_version = update_version;

		/**
		 * Executes the proxy in the context of the reaction it was originally created in, if any
		 * @template T
		 * @param {() => T} fn
		 */
		var with_parent = (fn) => {
			if (update_version === parent_version) {
				return fn();
			}

			// child source is being created after the initial proxy —
			// prevent it from being associated with the current reaction
			var reaction = active_reaction;
			var version = update_version;

			set_active_reaction(null);
			set_update_version(parent_version);

			var result = fn();

			set_active_reaction(reaction);
			set_update_version(version);

			return result;
		};

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', state(/** @type {any[]} */ (value).length));
		}

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object — which we avoid, so that state can be forked — we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}
				var s = sources.get(prop);
				if (s === undefined) {
					s = with_parent(() => {
						var s = state(descriptor.value);
						sources.set(prop, s);
						return s;
					});
				} else {
					set(s, descriptor.value, true);
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						const s = with_parent(() => state(UNINITIALIZED));
						sources.set(prop, s);
						increment(version);
					}
				} else {
					set(s, UNINITIALIZED);
					increment(version);
				}

				return true;
			},

			get(target, prop, receiver) {
				if (prop === STATE_SYMBOL) {
					return value;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = with_parent(() => {
						var p = proxy(exists ? target[prop] : UNINITIALIZED);
						var s = state(p);

						return s;
					});

					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get(s);
					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {
				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = with_parent(() => {
							var p = has ? proxy(target[prop]) : UNINITIALIZED;
							var s = state(p);

							return s;
						});

						sources.set(prop, s);
					}

					var value = get(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create a uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = with_parent(() => state(UNINITIALIZED));
							sources.set(i + '', other_s);
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = with_parent(() => state(undefined));
						set(s, proxy(value));

						sources.set(prop, s);
					}
				} else {
					has = s.v !== UNINITIALIZED;

					var p = with_parent(() => proxy(value));
					set(s, p);
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set(ls, n + 1);
						}
					}

					increment(version);
				}

				return true;
			},

			ownKeys(target) {
				get(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/** @import { Effect, TemplateNode } from '#client' */

	// export these for reference in the compiled code, making global name deduplication unnecessary
	/** @type {Window} */
	var $window;

	/** @type {boolean} */
	var is_firefox;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * Initialize these lazily to avoid issues when using the runtime in a server context
	 * where these globals are not available while avoiding a separate server entry point
	 */
	function init_operations() {
		if ($window !== undefined) {
			return;
		}

		$window = window;
		is_firefox = /Firefox/.test(navigator.userAgent);

		var element_prototype = Element.prototype;
		var node_prototype = Node.prototype;
		var text_prototype = Text.prototype;

		// @ts-ignore
		first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
		// @ts-ignore
		next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;

		if (is_extensible(element_prototype)) {
			// the following assignments improve perf of lookups on DOM nodes
			// @ts-expect-error
			element_prototype.__click = undefined;
			// @ts-expect-error
			element_prototype.__className = undefined;
			// @ts-expect-error
			element_prototype.__attributes = null;
			// @ts-expect-error
			element_prototype.__style = undefined;
			// @ts-expect-error
			element_prototype.__e = undefined;
		}

		if (is_extensible(text_prototype)) {
			// @ts-expect-error
			text_prototype.__t = undefined;
		}
	}

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return first_child_getter.call(node);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return next_sibling_getter.call(node);
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function child(node, is_text) {
		{
			return get_first_child(node);
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {DocumentFragment | TemplateNode[]} fragment
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function first_child(fragment, is_text) {
		{
			// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)
			var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));

			// TODO prevent user comments with the empty string when preserveComments is true
			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

			return first;
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = node;

		while (count--) {
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		{
			return next_sibling;
		}
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 */
	function without_reactive_context(fn) {
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);
		try {
			return fn();
		} finally {
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {'$effect' | '$effect.pre' | '$inspect'} rune
	 */
	function validate_effect(rune) {
		if (active_effect === null && active_reaction === null) {
			effect_orphan();
		}

		if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
			effect_in_unowned_derived();
		}

		if (is_destroying_effect) {
			effect_in_teardown();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @param {boolean} push
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync, push = true) {
		var parent = active_effect;

		if (parent !== null && (parent.f & INERT) !== 0) {
			type |= INERT;
		}

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			nodes_start: null,
			nodes_end: null,
			f: type | DIRTY,
			first: null,
			fn,
			last: null,
			next: null,
			parent,
			b: parent && parent.b,
			prev: null,
			teardown: null,
			transitions: null,
			wv: 0,
			ac: null
		};

		if (sync) {
			try {
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		if (push) {
			/** @type {Effect | null} */
			var e = effect;

			// if an effect has already ran and doesn't need to be kept in the tree
			// (because it won't re-run, has no DOM, and has no teardown etc)
			// then we skip it and go to its child (if any)
			if (
				sync &&
				e.deps === null &&
				e.teardown === null &&
				e.nodes_start === null &&
				e.first === e.last && // either `null`, or a singular child
				(e.f & EFFECT_PRESERVED) === 0
			) {
				e = e.first;
			}

			if (e !== null) {
				e.parent = parent;

				if (parent !== null) {
					push_effect(e, parent);
				}

				// if we're in a derived, add the effect there too
				if (
					active_reaction !== null &&
					(active_reaction.f & DERIVED) !== 0 &&
					(type & ROOT_EFFECT) === 0
				) {
					var derived = /** @type {Derived} */ (active_reaction);
					(derived.effects ??= []).push(e);
				}
			}
		}

		return effect;
	}

	/**
	 * Internal representation of `$effect(...)`
	 * @param {() => void | (() => void)} fn
	 */
	function user_effect(fn) {
		validate_effect();

		// Non-nested `$effect(...)` in a component should be deferred
		// until the component is mounted
		var flags = /** @type {Effect} */ (active_effect).f;
		var defer = !active_reaction && (flags & BRANCH_EFFECT) !== 0 && (flags & EFFECT_RAN) === 0;

		if (defer) {
			// Top-level `$effect(...)` in an unmounted component — defer until mount
			var context = /** @type {ComponentContext} */ (component_context);
			(context.e ??= []).push(fn);
		} else {
			// Everything else — create immediately
			return create_user_effect(fn);
		}
	}

	/**
	 * @param {() => void | (() => void)} fn
	 */
	function create_user_effect(fn) {
		return create_effect(EFFECT | USER_EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$effect.pre(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function user_pre_effect(fn) {
		validate_effect();
		return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true);
	}

	/**
	 * An effect root whose children can transition out
	 * @param {() => void} fn
	 * @returns {(options?: { outro?: boolean }) => Promise<void>}
	 */
	function component_root(fn) {
		Batch.ensure();
		const effect = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);

		return (options = {}) => {
			return new Promise((fulfil) => {
				if (options.outro) {
					pause_effect(effect, () => {
						destroy_effect(effect);
						fulfil(undefined);
					});
				} else {
					destroy_effect(effect);
					fulfil(undefined);
				}
			});
		};
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function effect(fn) {
		return create_effect(EFFECT, fn, false);
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {boolean} [push]
	 */
	function branch(fn, push = true) {
		return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true, push);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			const controller = effect.ac;

			if (controller !== null) {
				without_reactive_context(() => {
					controller.abort(STALE_REACTION);
				});
			}

			var next = effect.next;

			if ((effect.f & ROOT_EFFECT) !== 0) {
				// this is now an independent root
				effect.parent = null;
			} else {
				destroy_effect(effect, remove_dom);
			}

			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if (
			(remove_dom || (effect.f & HEAD_EFFECT) !== 0) &&
			effect.nodes_start !== null &&
			effect.nodes_end !== null
		) {
			remove_effect_dom(effect.nodes_start, /** @type {TemplateNode} */ (effect.nodes_end));
			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.transitions;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		// `first` and `child` are nulled out in destroy_effect_children
		// we don't null out `parent` so that error propagation can work correctly
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.fn =
			effect.nodes_start =
			effect.nodes_end =
			effect.ac =
				null;
	}

	/**
	 *
	 * @param {TemplateNode | null} node
	 * @param {TemplateNode} end
	 */
	function remove_effect_dom(node, end) {
		while (node !== null) {
			/** @type {TemplateNode | null} */
			var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

			node.remove();
			node = next;
		}
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 */
	function pause_effect(effect, callback) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		run_out_transitions(transitions, () => {
			destroy_effect(effect);
			if (callback) callback();
		});
	}

	/**
	 * @param {TransitionManager[]} transitions
	 * @param {() => void} fn
	 */
	function run_out_transitions(transitions, fn) {
		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/** @import { Derived, Effect, Reaction, Signal, Source, Value } from '#client' */

	let is_updating_effect = false;

	/** @param {boolean} value */
	function set_is_updating_effect(value) {
		is_updating_effect = value;
	}

	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	/** @type {null | Reaction} */
	let active_reaction = null;

	let untracking = false;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a reaction, reading and writing
	 * them within that reaction should not cause a re-run
	 * @type {null | Source[]}
	 */
	let current_sources = null;

	/** @param {Value} value */
	function push_reaction_value(value) {
		if (active_reaction !== null && (true)) {
			if (current_sources === null) {
				current_sources = [value];
			} else {
				current_sources.push(value);
			}
		}
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed — we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/**
	 * @type {number} Used by sources and deriveds for handling updates.
	 * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing
	 **/
	let write_version = 1;

	/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */
	let read_version = 0;

	let update_version = read_version;

	/** @param {number} value */
	function set_update_version(value) {
		update_version = value;
	}

	// If we are working with a get() chain that has no active container,
	// to prevent memory leaks, we skip adding the reaction.
	let skip_reaction = false;

	function increment_write_version() {
		return ++write_version;
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function is_dirty(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;
			var is_unowned = (flags & UNOWNED) !== 0;

			if (dependencies !== null) {
				var i;
				var dependency;
				var is_disconnected = (flags & DISCONNECTED) !== 0;
				var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
				var length = dependencies.length;

				// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect)
				// then we need to re-connect the reaction to the dependency, unless the effect has already been destroyed
				// (which can happen if the derived is read by an async derived)
				if (
					(is_disconnected || is_unowned_connected) &&
					(active_effect === null || (active_effect.f & DESTROYED) === 0)
				) {
					var derived = /** @type {Derived} */ (reaction);
					var parent = derived.parent;

					for (i = 0; i < length; i++) {
						dependency = dependencies[i];

						// We always re-add all reactions (even duplicates) if the derived was
						// previously disconnected, however we don't if it was unowned as we
						// de-duplicate dependencies in that case
						if (is_disconnected || !dependency?.reactions?.includes(derived)) {
							(dependency.reactions ??= []).push(derived);
						}
					}

					if (is_disconnected) {
						derived.f ^= DISCONNECTED;
					}
					// If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent
					// and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned
					// flag
					if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
						derived.f ^= UNOWNED;
					}
				}

				for (i = 0; i < length; i++) {
					dependency = dependencies[i];

					if (is_dirty(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					if (dependency.wv > reaction.wv) {
						return true;
					}
				}
			}

			// Unowned signals should never be marked as clean unless they
			// are used within an active_effect without skip_reaction
			if (!is_unowned || (active_effect !== null && !skip_reaction)) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {Value} signal
	 * @param {Effect} effect
	 * @param {boolean} [root]
	 */
	function schedule_possible_effect_self_invalidation(signal, effect, root = true) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		if (current_sources?.includes(signal)) {
			return;
		}

		for (var i = 0; i < reactions.length; i++) {
			var reaction = reactions[i];

			if ((reaction.f & DERIVED) !== 0) {
				schedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false);
			} else if (effect === reaction) {
				if (root) {
					set_signal_status(reaction, DIRTY);
				} else if ((reaction.f & CLEAN) !== 0) {
					set_signal_status(reaction, MAYBE_DIRTY);
				}
				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/** @param {Reaction} reaction */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_skip_reaction = skip_reaction;
		var previous_sources = current_sources;
		var previous_component_context = component_context;
		var previous_untracking = untracking;
		var previous_update_version = update_version;

		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		skip_reaction =
			(flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;

		current_sources = null;
		set_component_context(reaction.ctx);
		untracking = false;
		update_version = ++read_version;

		if (reaction.ac !== null) {
			without_reactive_context(() => {
				/** @type {AbortController} */ (reaction.ac).abort(STALE_REACTION);
			});

			reaction.ac = null;
		}

		try {
			reaction.f |= REACTION_IS_UPDATING;
			var fn = /** @type {Function} */ (reaction.fn);
			var result = fn();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (
					!skip_reaction ||
					// Deriveds that already have reactions can cleanup, so we still add them as reactions
					((flags & DERIVED) !== 0 &&
						/** @type {import('#client').Derived} */ (reaction).reactions !== null)
				) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			// If we're inside an effect and we have untracked writes, then we need to
			// ensure that if any of those untracked writes result in re-invalidation
			// of the current effect, then that happens accordingly
			if (
				is_runes() &&
				untracked_writes !== null &&
				!untracking &&
				deps !== null &&
				(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
			) {
				for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {
					schedule_possible_effect_self_invalidation(
						untracked_writes[i],
						/** @type {Effect} */ (reaction)
					);
				}
			}

			// If we are returning to an previous reaction then
			// we need to increment the read version to ensure that
			// any dependencies in this reaction aren't marked with
			// the same version
			if (previous_reaction !== null && previous_reaction !== reaction) {
				read_version++;

				if (untracked_writes !== null) {
					if (previous_untracked_writes === null) {
						previous_untracked_writes = untracked_writes;
					} else {
						previous_untracked_writes.push(.../** @type {Source[]} */ (untracked_writes));
					}
				}
			}

			if ((reaction.f & ERROR_VALUE) !== 0) {
				reaction.f ^= ERROR_VALUE;
			}

			return result;
		} catch (error) {
			return handle_error(error);
		} finally {
			reaction.f ^= REACTION_IS_UPDATING;
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			skip_reaction = previous_skip_reaction;
			current_sources = previous_sources;
			set_component_context(previous_component_context);
			untracking = previous_untracking;
			update_version = previous_update_version;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = index_of.call(reactions, signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}

		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected.
			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
				dependency.f ^= DISCONNECTED;
			}
			// Disconnect any reactions owned by this reaction
			destroy_derived_effects(/** @type {Derived} **/ (dependency));
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;
		var was_updating_effect = is_updating_effect;

		active_effect = effect;
		is_updating_effect = true;

		try {
			if ((flags & BLOCK_EFFECT) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.wv = write_version;

			// In DEV, increment versions of any sources that were written to during the effect,
			// so that they are correctly marked as dirty when the effect re-runs
			var dep; if (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && effect.deps !== null) ;
		} finally {
			is_updating_effect = was_updating_effect;
			active_effect = previous_effect;
		}
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null && !untracking) {
			// if we're in a derived that is being read inside an _async_ derived,
			// it's possible that the effect was already destroyed. In this case,
			// we don't add the dependency, because that would create a memory leak
			var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;

			if (!destroyed && !current_sources?.includes(signal)) {
				var deps = active_reaction.deps;

				if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
					// we're in the effect init/update cycle
					if (signal.rv < read_version) {
						signal.rv = read_version;

						// If the signal is accessing the same dependencies in the same
						// order as it did last time, increment `skipped_deps`
						// rather than updating `new_deps`, which creates GC cost
						if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
							skipped_deps++;
						} else if (new_deps === null) {
							new_deps = [signal];
						} else if (!skip_reaction || !new_deps.includes(signal)) {
							// Normally we can push duplicated dependencies to `new_deps`, but if we're inside
							// an unowned derived because skip_reaction is true, then we need to ensure that
							// we don't have duplicates
							new_deps.push(signal);
						}
					}
				} else {
					// we're adding a dependency outside the init/update cycle
					// (i.e. after an `await`)
					(active_reaction.deps ??= []).push(signal);

					var reactions = signal.reactions;

					if (reactions === null) {
						signal.reactions = [active_reaction];
					} else if (!reactions.includes(active_reaction)) {
						reactions.push(active_reaction);
					}
				}
			}
		} else if (
			is_derived &&
			/** @type {Derived} */ (signal).deps === null &&
			/** @type {Derived} */ (signal).effects === null
		) {
			var derived = /** @type {Derived} */ (signal);
			var parent = derived.parent;

			if (parent !== null && (parent.f & UNOWNED) === 0) {
				// If the derived is owned by another derived then mark it as unowned
				// as the derived value might have been referenced in a different context
				// since and thus its parent might not be its true owner anymore
				derived.f ^= UNOWNED;
			}
		}

		if (is_destroying_effect) {
			if (old_values.has(signal)) {
				return old_values.get(signal);
			}

			if (is_derived) {
				derived = /** @type {Derived} */ (signal);

				var value = derived.v;

				// if the derived is dirty and has reactions, or depends on the values that just changed, re-execute
				// (a derived can be maybe_dirty due to the effect destroy removing its last reaction)
				if (
					((derived.f & CLEAN) === 0 && derived.reactions !== null) ||
					depends_on_old_values(derived)
				) {
					value = execute_derived(derived);
				}

				old_values.set(derived, value);

				return value;
			}
		} else if (is_derived) {
			derived = /** @type {Derived} */ (signal);

			if (is_dirty(derived)) {
				update_derived(derived);
			}
		}

		if ((signal.f & ERROR_VALUE) !== 0) {
			throw signal.v;
		}

		return signal.v;
	}

	/** @param {Derived} derived */
	function depends_on_old_values(derived) {
		if (derived.v === UNINITIALIZED) return true; // we don't know, so assume the worst
		if (derived.deps === null) return false;

		for (const dep of derived.deps) {
			if (old_values.has(dep)) {
				return true;
			}

			if ((dep.f & DERIVED) !== 0 && depends_on_old_values(/** @type {Derived} */ (dep))) {
				return true;
			}
		}

		return false;
	}

	/**
	 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
	 * any state read inside `fn` will not be treated as a dependency.
	 *
	 * ```ts
	 * $effect(() => {
	 *   // this will run when `data` changes, but not when `time` changes
	 *   save(data, {
	 *     timestamp: untrack(() => time)
	 *   });
	 * });
	 * ```
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		var previous_untracking = untracking;
		try {
			untracking = true;
			return fn();
		} finally {
			untracking = previous_untracking;
		}
	}

	const STATUS_MASK = -7169;

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/**
	 * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.
	 * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).
	 * @param {any} value
	 * @returns {void}
	 */
	function deep_read_state(value) {
		if (typeof value !== 'object' || !value || value instanceof EventTarget) {
			return;
		}

		if (STATE_SYMBOL in value) {
			deep_read(value);
		} else if (!Array.isArray(value)) {
			for (let key in value) {
				const prop = value[key];
				if (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {
					deep_read(prop);
				}
			}
		}
	}

	/**
	 * Deeply traverse an object and read all its properties
	 * so that they're all reactive in case this is `$state`
	 * @param {any} value
	 * @param {Set<any>} visited
	 * @returns {void}
	 */
	function deep_read(value, visited = new Set()) {
		if (
			typeof value === 'object' &&
			value !== null &&
			// We don't want to traverse DOM elements
			!(value instanceof EventTarget) &&
			!visited.has(value)
		) {
			visited.add(value);
			// When working with a possible SvelteDate, this
			// will ensure we capture changes to it.
			if (value instanceof Date) {
				value.getTime();
			}
			for (let key in value) {
				try {
					deep_read(value[key], visited);
				} catch (e) {
					// continue
				}
			}
			const proto = get_prototype_of(value);
			if (
				proto !== Object.prototype &&
				proto !== Array.prototype &&
				proto !== Map.prototype &&
				proto !== Set.prototype &&
				proto !== Date.prototype
			) {
				const descriptors = get_descriptors(proto);
				for (let key in descriptors) {
					const get = descriptors[key].get;
					if (get) {
						try {
							get.call(value);
						} catch (e) {
							// continue
						}
					}
				}
			}
		}
	}

	/**
	 * Subset of delegated events which should be passive by default.
	 * These two are already passive via browser defaults on window, document and body.
	 * But since
	 * - we're delegating them
	 * - they happen often
	 * - they apply to mobile which is generally less performant
	 * we're marking them as passive by default for other elements, too.
	 */
	const PASSIVE_EVENTS = ['touchstart', 'touchmove'];

	/**
	 * Returns `true` if `name` is a passive event
	 * @param {string} name
	 */
	function is_passive_event(name) {
		return PASSIVE_EVENTS.includes(name);
	}

	/** @type {Set<string>} */
	const all_registered_events = new Set();

	/** @type {Set<(events: Array<string>) => void>} */
	const root_event_handles = new Set();

	/**
	 * @param {Array<string>} events
	 * @returns {void}
	 */
	function delegate(events) {
		for (var i = 0; i < events.length; i++) {
			all_registered_events.add(events[i]);
		}

		for (var fn of root_event_handles) {
			fn(events);
		}
	}

	// used to store the reference to the currently propagated event
	// to prevent garbage collection between microtasks in Firefox
	// If the event object is GCed too early, the expando __root property
	// set on the event object is lost, causing the event delegation
	// to process the event twice
	let last_propagated_event = null;

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		last_propagated_event = event;

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// the `last_propagated_event === event` check is redundant, but
		// without it the variable will be DCE'd and things will
		// fail mysteriously in Firefox
		// @ts-expect-error is added below
		var handled_at = last_propagated_event === event && event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (
						delegated != null &&
						(!(/** @type {any} */ (current_target).disabled) ||
							// DOM could've been updated already by the time this is reached, so we check this as well
							// -> the target could not have been disabled because it emits the event in the first place
							event.target === current_target)
					) {
						if (is_array(delegated)) {
							var [fn, ...data] = delegated;
							fn.apply(current_target, [event, ...data]);
						} else {
							delegated.call(current_target, event);
						}
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html.replaceAll('<!>', '<!---->'); // XHTML compliance
		return elem.content;
	}

	/** @import { Effect, TemplateNode } from '#client' */
	/** @import { TemplateStructure } from './types' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes_start === null) {
			effect.nodes_start = start;
			effect.nodes_end = end;
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function from_html(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {

		if (anchor === null) {
			// edge case — void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

	/**
	 * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
	 * Transitions will play during the initial render unless the `intro` option is set to `false`.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {MountOptions<Props>} options
	 * @returns {Exports}
	 */
	function mount(component, options) {
		return _mount(component, options);
	}

	/** @type {Map<string, number>} */
	const document_listeners = new Map();

	/**
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
	 * @param {MountOptions} options
	 * @returns {Exports}
	 */
	function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
		init_operations();

		/** @type {Set<string>} */
		var registered_events = new Set();

		/** @param {Array<string>} events */
		var event_handle = (events) => {
			for (var i = 0; i < events.length; i++) {
				var event_name = events[i];

				if (registered_events.has(event_name)) continue;
				registered_events.add(event_name);

				var passive = is_passive_event(event_name);

				// Add the event listener to both the container and the document.
				// The container listener ensures we catch events from within in case
				// the outer content stops propagation of the event.
				target.addEventListener(event_name, handle_event_propagation, { passive });

				var n = document_listeners.get(event_name);

				if (n === undefined) {
					// The document listener ensures we catch events that originate from elements that were
					// manually moved outside of the container (e.g. via manual portals).
					document.addEventListener(event_name, handle_event_propagation, { passive });
					document_listeners.set(event_name, 1);
				} else {
					document_listeners.set(event_name, n + 1);
				}
			}
		};

		event_handle(array_from(all_registered_events));
		root_event_handles.add(event_handle);

		/** @type {Exports} */
		// @ts-expect-error will be defined because the render effect runs synchronously
		var component = undefined;

		var unmount = component_root(() => {
			var anchor_node = anchor ?? target.appendChild(create_text());

			branch(() => {
				if (context) {
					push({});
					var ctx = /** @type {ComponentContext} */ (component_context);
					ctx.c = context;
				}

				if (events) {
					// We can't spread the object or else we'd lose the state proxy stuff, if it is one
					/** @type {any} */ (props).$$events = events;
				}
				// @ts-expect-error the public typings are not what the actual function looks like
				component = Component(anchor_node, props) || {};

				if (context) {
					pop();
				}
			});

			return () => {
				for (var event_name of registered_events) {
					target.removeEventListener(event_name, handle_event_propagation);

					var n = /** @type {number} */ (document_listeners.get(event_name));

					if (--n === 0) {
						document.removeEventListener(event_name, handle_event_propagation);
						document_listeners.delete(event_name);
					} else {
						document_listeners.set(event_name, n);
					}
				}

				root_event_handles.delete(event_handle);

				if (anchor_node !== anchor) {
					anchor_node.parentNode?.removeChild(anchor_node);
				}
			};
		});

		mounted_components.set(component, unmount);
		return component;
	}

	/**
	 * References of the components that were mounted or hydrated.
	 * Uses a `WeakMap` to avoid memory leaks.
	 */
	let mounted_components = new WeakMap();

	/**
	 * Unmounts a component that was previously mounted using `mount` or `hydrate`.
	 *
	 * Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM.
	 *
	 * Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
	 *
	 * ```js
	 * import { mount, unmount } from 'svelte';
	 * import App from './App.svelte';
	 *
	 * const app = mount(App, { target: document.body });
	 *
	 * // later...
	 * unmount(app, { outro: true });
	 * ```
	 * @param {Record<string, any>} component
	 * @param {{ outro?: boolean }} [options]
	 * @returns {Promise<void>}
	 */
	function unmount(component, options) {
		const fn = mounted_components.get(component);

		if (fn) {
			mounted_components.delete(component);
			return fn(options);
		}

		return Promise.resolve();
	}

	/**
	 * @param {any} bound_value
	 * @param {Element} element_or_component
	 * @returns {boolean}
	 */
	function is_bound_this(bound_value, element_or_component) {
		return (
			bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component
		);
	}

	/**
	 * @param {any} element_or_component
	 * @param {(value: unknown, ...parts: unknown[]) => void} update
	 * @param {(...parts: unknown[]) => unknown} get_value
	 * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,
	 * 										returns all the parts of the each block context that are used in the expression
	 * @returns {void}
	 */
	function bind_this(element_or_component = {}, update, get_value, get_parts) {
		effect(() => {
			/** @type {unknown[]} */
			var old_parts;

			/** @type {unknown[]} */
			var parts;

			render_effect(() => {
				old_parts = parts;
				// We only track changes to the parts, not the value itself to avoid unnecessary reruns.
				parts = [];

				untrack(() => {
					if (element_or_component !== get_value(...parts)) {
						update(element_or_component, ...parts);
						// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at
						// the previous position if it isn't already taken over by a different effect.
						if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
							update(null, ...old_parts);
						}
					}
				});
			});

			return () => {
				// We cannot use effects in the teardown phase, we we use a microtask instead.
				queue_micro_task(() => {
					if (parts && is_bound_this(get_value(...parts), element_or_component)) {
						update(null, ...parts);
					}
				});
			};
		});

		return element_or_component;
	}

	/** @import { ComponentContextLegacy } from '#client' */

	/**
	 * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects
	 * @param {boolean} [immutable]
	 */
	function init(immutable = false) {
		const context = /** @type {ComponentContextLegacy} */ (component_context);

		const callbacks = context.l.u;
		if (!callbacks) return;

		let props = () => deep_read_state(context.s);

		if (immutable) {
			let version = 0;
			let prev = /** @type {Record<string, any>} */ ({});

			// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes
			const d = derived(() => {
				let changed = false;
				const props = context.s;
				for (const key in props) {
					if (props[key] !== prev[key]) {
						prev[key] = props[key];
						changed = true;
					}
				}
				if (changed) version++;
				return version;
			});

			props = () => get(d);
		}

		// beforeUpdate
		if (callbacks.b.length) {
			user_pre_effect(() => {
				observe_all(context, props);
				run_all(callbacks.b);
			});
		}

		// onMount (must run before afterUpdate)
		user_effect(() => {
			const fns = untrack(() => callbacks.m.map(run));
			return () => {
				for (const fn of fns) {
					if (typeof fn === 'function') {
						fn();
					}
				}
			};
		});

		// afterUpdate
		if (callbacks.a.length) {
			user_effect(() => {
				observe_all(context, props);
				run_all(callbacks.a);
			});
		}
	}

	/**
	 * Invoke the getter of all signals associated with a component
	 * so they can be registered to the effect this function is called in.
	 * @param {ComponentContextLegacy} context
	 * @param {(() => void)} props
	 */
	function observe_all(context, props) {
		if (context.l.s) {
			for (const signal of context.l.s) get(signal);
		}

		props();
	}

	/** @import { StoreReferencesContainer } from '#client' */
	/** @import { Store } from '#shared' */

	/**
	 * Whether or not the prop currently being read is a store binding, as in
	 * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in
	 * runes mode, and skip `binding_property_non_reactive` validation
	 */
	let is_store_binding = false;

	/**
	 * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.
	 * Used to prevent `binding_property_non_reactive` validation false positives and
	 * ensure that these props are treated as mutable even in runes mode
	 * @template T
	 * @param {() => T} fn
	 * @returns {[T, boolean]}
	 */
	function capture_store_binding(fn) {
		var previous_is_store_binding = is_store_binding;

		try {
			is_store_binding = false;
			return [fn(), is_store_binding];
		} finally {
			is_store_binding = previous_is_store_binding;
		}
	}

	/** @import { Effect, Source } from './types.js' */

	/**
	 * This function is responsible for synchronizing a possibly bound prop with the inner component state.
	 * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} key
	 * @param {number} flags
	 * @param {V | (() => V)} [fallback]
	 * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}
	 */
	function prop(props, key, flags, fallback) {
		var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;
		var bindable = (flags & PROPS_IS_BINDABLE) !== 0;

		var fallback_value = /** @type {V} */ (fallback);
		var fallback_dirty = true;

		var get_fallback = () => {
			if (fallback_dirty) {
				fallback_dirty = false;

				fallback_value = /** @type {V} */ (fallback);
			}

			return fallback_value;
		};

		/** @type {((v: V) => void) | undefined} */
		var setter;

		{
			// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`
			// or `createClassComponent(Component, props)`
			var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;

			setter =
				get_descriptor(props, key)?.set ??
				(is_entry_props && key in props ? (v) => (props[key] = v) : undefined);
		}

		var initial_value;
		var is_store_sub = false;

		{
			[initial_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));
		}

		if (initial_value === undefined && fallback !== undefined) {
			initial_value = get_fallback();

			if (setter) {
				if (runes) props_invalid_value();
				setter(initial_value);
			}
		}

		/** @type {() => V} */
		var getter;

		if (runes) {
			getter = () => {
				var value = /** @type {V} */ (props[key]);
				if (value === undefined) return get_fallback();
				fallback_dirty = true;
				return value;
			};
		} else {
			getter = () => {
				var value = /** @type {V} */ (props[key]);

				if (value !== undefined) {
					// in legacy mode, we don't revert to the fallback value
					// if the prop goes from defined to undefined. The easiest
					// way to model this is to make the fallback undefined
					// as soon as the prop has a value
					fallback_value = /** @type {V} */ (undefined);
				}

				return value === undefined ? fallback_value : value;
			};
		}

		// prop is never written to — we only need a getter
		if (runes && (flags & PROPS_IS_UPDATED) === 0) {
			return getter;
		}

		// prop is written to, but the parent component had `bind:foo` which
		// means we can just call `$$props.foo = value` directly
		if (setter) {
			var legacy_parent = props.$$legacy;
			return /** @type {() => V} */ (
				function (/** @type {V} */ value, /** @type {boolean} */ mutation) {
					if (arguments.length > 0) {
						// We don't want to notify if the value was mutated and the parent is in runes mode.
						// In that case the state proxy (if it exists) should take care of the notification.
						// If the parent is not in runes mode, we need to notify on mutation, too, that the prop
						// has changed because the parent will not be able to detect the change otherwise.
						if (!runes || !mutation || legacy_parent || is_store_sub) {
							/** @type {Function} */ (setter)(mutation ? getter() : value);
						}

						return value;
					}

					return getter();
				}
			);
		}

		// Either prop is written to, but there's no binding, which means we
		// create a derived that we can write to locally.
		// Or we are in legacy mode where we always create a derived to replicate that
		// Svelte 4 did not trigger updates when a primitive value was updated to the same value.
		var overridden = false;

		var d = (derived_safe_equal)(() => {
			overridden = false;
			return getter();
		});

		// Capture the initial value if it's bindable
		get(d);

		var parent_effect = /** @type {Effect} */ (active_effect);

		return /** @type {() => V} */ (
			function (/** @type {any} */ value, /** @type {boolean} */ mutation) {
				if (arguments.length > 0) {
					const new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;

					set(d, new_value);
					overridden = true;

					if (fallback_value !== undefined) {
						fallback_value = new_value;
					}

					return value;
				}

				// special case — avoid recalculating the derived if we're in a
				// teardown function and the prop was overridden locally, or the
				// component was already destroyed (this latter part is necessary
				// because `bind:this` can read props after the component has
				// been destroyed. TODO simplify `bind:this`
				if ((is_destroying_effect && overridden) || (parent_effect.f & DESTROYED) !== 0) {
					return d.v;
				}

				return get(d);
			}
		);
	}

	/** @import { ComponentContext, ComponentContextLegacy } from '#client' */
	/** @import { EventDispatcher } from './index.js' */
	/** @import { NotFunction } from './internal/types.js' */

	/**
	 * `onMount`, like [`$effect`](https://svelte.dev/docs/svelte/$effect), schedules a function to run as soon as the component has been mounted to the DOM.
	 * Unlike `$effect`, the provided function only runs once.
	 *
	 * It must be called during the component's initialisation (but doesn't need to live _inside_ the component;
	 * it can be called from an external module). If a function is returned _synchronously_ from `onMount`,
	 * it will be called when the component is unmounted.
	 *
	 * `onMount` functions do not run during [server-side rendering](https://svelte.dev/docs/svelte/svelte-server#render).
	 *
	 * @template T
	 * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		if (component_context === null) {
			lifecycle_outside_component();
		}

		if (legacy_mode_flag && component_context.l !== null) {
			init_update_callbacks(component_context).m.push(fn);
		} else {
			user_effect(() => {
				const cleanup = untrack(fn);
				if (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);
			});
		}
	}

	/**
	 * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate
	 * @param {ComponentContext} context
	 */
	function init_update_callbacks(context) {
		var l = /** @type {ComponentContextLegacy} */ (context).l;
		return (l.u ??= { a: [], b: [], m: [] });
	}

	/** @type{HTMLScriptElement[]} */
	let scriptNodes = [];

	let KEY_LAST_CDN_NODE = '399bcb0da1a821b8cf06e187022c1778';

	/**
	 * @param {(o:object)=>void} resolve
	 * @param {string} path
	 * @param {string} name
	 */
	function loadScript(resolve, path, name) {
	    if (!scriptNodes) { return }
	    let node = document.createElement('script');
	    scriptNodes.push(node);
	    node.type = 'text/javascript';
	    node.async = true;
	    node.src = path + name;
	    node.onload = () => {
	        /** @type{any} */
	        let require = window['require'];
	        if (require?.config && scriptNodes) {
	            console.log('path', path);
	            require.config({ paths: { 'vs': path } });
	            scriptNodes.filter(o => o != node).forEach(o => {
	                o.src = '';
	                o.remove();
	            });
	            scriptNodes = null;
	            resolve(require);
	            localStorage.setItem(KEY_LAST_CDN_NODE, [path, name].join('{#}'));
	        }
	    };
	    document.head.appendChild(node);
	}

	// https://microsoft.github.io/monaco-editor/index.html
	async function getRequireLoader() {
	    let requireLoader = await new Promise(async (resolve) => {
	        let [path, name] = (localStorage.getItem(KEY_LAST_CDN_NODE) || '').split('{#}');
	        if (path && name) {
	            loadScript(resolve, path, name);
	            await new Promise((resolve) => setTimeout(resolve, 100));
	        }
	        loadScript(resolve, 'https://cdn.staticfile.net/monaco-editor/0.53.0/min/vs', '/loader.js');
	        loadScript(resolve, 'https://lib.baomitu.com/monaco-editor/0.53.0/min/vs', '/loader.js');
	        loadScript(resolve, 'https://cdn.bootcdn.net/ajax/libs/monaco-editor/0.53.0/min/vs', '/loader.js');
	        loadScript(resolve, 'https://cdn.jsdelivr.net/npm/monaco-editor@0.53.0/min/vs', '/loader.js');
	        loadScript(resolve, 'https://microsoft.github.io/monaco-editor/node_modules/monaco-editor/min/vs', '/loader.js');
	        loadScript(resolve, 'https://unpkg.com/monaco-editor@0.53.0/min/vs', '/loader.js');
	        loadScript(resolve, 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.53.0/min/vs', '/loader.js');
	    });
	    return requireLoader
	}

	let monacoPromise;

	/**
	 * @returns {Promise<import('monaco-editor')>}
	 */
	async function loadMonaco() {
	    if (monacoPromise) return monacoPromise
	    monacoPromise = new Promise((resolve) => {
	        (async () => {
	            let require = await getRequireLoader();
	            require(['vs/editor/editor.main'], () => {
	                const monaco = window['monaco'];
	                resolve(monaco);
	            });
	        })();
	    });
	    return monacoPromise
	}

	var MonacoLoader = {
	    load: loadMonaco
	};

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function getAugmentedNamespace(n) {
	  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
	  var f = n.default;
		if (typeof f == "function") {
			var a = function a () {
				var isInstance = false;
	      try {
	        isInstance = this instanceof a;
	      } catch {}
				if (isInstance) {
	        return Reflect.construct(f, arguments, this.constructor);
				}
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	/**
	* vkBeautify - javascript plugin to pretty-print or minify text in XML, JSON, CSS and SQL formats.
	*
	* Copyright (c) 2012 Vadim Kiryukhin
	* vkiryukhin @ gmail.com
	* http://www.eslinstructor.net/vkbeautify/
	*
	* Dual licensed under the MIT and GPL licenses:
	*   http://www.opensource.org/licenses/mit-license.php
	*   http://www.gnu.org/licenses/gpl.html
	*
	*   Pretty print
	*
	*        vkbeautify.xml(text [,indent_pattern]);
	*        vkbeautify.json(text [,indent_pattern]);
	*        vkbeautify.css(text [,indent_pattern]);
	*        vkbeautify.sql(text [,indent_pattern]);
	*
	*        @text - String; text to beatufy;
	*        @indent_pattern - Integer | String;
	*                Integer:  number of white spaces;
	*                String:   character string to visualize indentation ( can also be a set of white spaces )
	*   Minify
	*
	*        vkbeautify.xmlmin(text [,preserve_comments]);
	*        vkbeautify.jsonmin(text);
	*        vkbeautify.cssmin(text [,preserve_comments]);
	*        vkbeautify.sqlmin(text);
	*
	*        @text - String; text to minify;
	*        @preserve_comments - Bool; [optional];
	*                Set this flag to true to prevent removing comments from @text ( minxml and mincss functions only. )
	*
	*   Examples:
	*        vkbeautify.xml(text); // pretty print XML
	*        vkbeautify.json(text, 4 ); // pretty print JSON
	*        vkbeautify.css(text, '. . . .'); // pretty print CSS
	*        vkbeautify.sql(text, '----'); // pretty print SQL
	*
	*        vkbeautify.xmlmin(text, true);// minify XML, preserve comments
	*        vkbeautify.jsonmin(text);// minify JSON
	*        vkbeautify.cssmin(text);// minify CSS, remove comments ( default )
	*        vkbeautify.sqlmin(text);// minify SQL
	*
	*/

	var vkbeautify_1;
	var hasRequiredVkbeautify;

	function requireVkbeautify () {
		if (hasRequiredVkbeautify) return vkbeautify_1;
		hasRequiredVkbeautify = 1;
		function createShiftArr(step) {

			var space = '    ';

			if ( isNaN(parseInt(step)) ) {  // argument is string
				space = step;
			} else { // argument is integer
				switch(step) {
					case 1: space = ' '; break;
					case 2: space = '  '; break;
					case 3: space = '   '; break;
					case 4: space = '    '; break;
					case 5: space = '     '; break;
					case 6: space = '      '; break;
					case 7: space = '       '; break;
					case 8: space = '        '; break;
					case 9: space = '         '; break;
					case 10: space = '          '; break;
					case 11: space = '           '; break;
					case 12: space = '            '; break;
				}
			}

			var shift = ['\n']; // array of shifts
			for(var ix=0;ix<100;ix++) {
				shift.push(shift[ix]+space);
			}
			return shift;
		}

		function vkbeautify(){
			this.step = '    '; // 4 spaces
			this.shift = createShiftArr(this.step);
		}
		vkbeautify.prototype.xml = function(text,step) {

			var ar = text.replace(/>\s{0,}</g,"><")
						 .replace(/</g,"~::~<")
						 .replace(/\s*xmlns\:/g,"~::~xmlns:")
						 .replace(/\s*xmlns\=/g,"~::~xmlns=")
						 .split('~::~'),
				len = ar.length,
				inComment = false,
				deep = 0,
				str = '',
				ix = 0,
				shift = step ? createShiftArr(step) : this.shift;

				for(ix=0;ix<len;ix++) {
					// start comment or <![CDATA[...]]> or <!DOCTYPE //
					if(ar[ix].search(/<!/) > -1) {
						str += shift[deep]+ar[ix];
						inComment = true;
						// end comment  or <![CDATA[...]]> //
						if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1 || ar[ix].search(/!DOCTYPE/) > -1 ) {
							inComment = false;
						}
					} else
					// end comment  or <![CDATA[...]]> //
					if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1) {
						str += ar[ix];
						inComment = false;
					} else
					// <elm></elm> //
					if( /^<\w/.exec(ar[ix-1]) && /^<\/\w/.exec(ar[ix]) &&
						/^<[\w:\-\.\,]+/.exec(ar[ix-1]) == /^<\/[\w:\-\.\,]+/.exec(ar[ix])[0].replace('/','')) {
						str += ar[ix];
						if(!inComment) deep--;
					} else
					 // <elm> //
					if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) == -1 && ar[ix].search(/\/>/) == -1 ) {
						str = !inComment ? str += shift[deep++]+ar[ix] : str += ar[ix];
					} else
					 // <elm>...</elm> //
					if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) > -1) {
						str = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];
					} else
					// </elm> //
					if(ar[ix].search(/<\//) > -1) {
						str = !inComment ? str += shift[--deep]+ar[ix] : str += ar[ix];
					} else
					// <elm/> //
					if(ar[ix].search(/\/>/) > -1 ) {
						str = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];
					} else
					// <? xml ... ?> //
					if(ar[ix].search(/<\?/) > -1) {
						str += shift[deep]+ar[ix];
					} else
					// xmlns //
					if( ar[ix].search(/xmlns\:/) > -1  || ar[ix].search(/xmlns\=/) > -1) {
						str += shift[deep]+ar[ix];
					}

					else {
						str += ar[ix];
					}
				}

			return  (str[0] == '\n') ? str.slice(1) : str;
		};

		vkbeautify.prototype.json = function(text,step) {

			var step = step ? step : this.step;

			if (typeof JSON === 'undefined' ) return text;

			if ( typeof text === "string" ) return JSON.stringify(JSON.parse(text), null, step);
			if ( typeof text === "object" ) return JSON.stringify(text, null, step);

			return text; // text is not string nor object
		};

		vkbeautify.prototype.css = function(text, step) {

			var ar = text.replace(/\s{1,}/g,' ')
						.replace(/\{/g,"{~::~")
						.replace(/\}/g,"~::~}~::~")
						.replace(/\;/g,";~::~")
						.replace(/\/\*/g,"~::~/*")
						.replace(/\*\//g,"*/~::~")
						.replace(/~::~\s{0,}~::~/g,"~::~")
						.split('~::~'),
				len = ar.length,
				deep = 0,
				str = '',
				ix = 0,
				shift = step ? createShiftArr(step) : this.shift;

				for(ix=0;ix<len;ix++) {

					if( /\{/.exec(ar[ix]))  {
						str += shift[deep++]+ar[ix];
					} else
					if( /\}/.exec(ar[ix]))  {
						str += shift[--deep]+ar[ix];
					} else
					if( /\*\\/.exec(ar[ix]))  {
						str += shift[deep]+ar[ix];
					}
					else {
						str += shift[deep]+ar[ix];
					}
				}
				return str.replace(/^\n{1,}/,'');
		};

		//----------------------------------------------------------------------------

		function isSubquery(str, parenthesisLevel) {
			return  parenthesisLevel - (str.replace(/\(/g,'').length - str.replace(/\)/g,'').length )
		}

		function split_sql(str, tab) {

			return str.replace(/\s{1,}/g," ")

						.replace(/ AND /ig,"~::~"+tab+tab+"AND ")
						.replace(/ BETWEEN /ig,"~::~"+tab+"BETWEEN ")
						.replace(/ CASE /ig,"~::~"+tab+"CASE ")
						.replace(/ ELSE /ig,"~::~"+tab+"ELSE ")
						.replace(/ END /ig,"~::~"+tab+"END ")
						.replace(/ FROM /ig,"~::~FROM ")
						.replace(/ GROUP\s{1,}BY/ig,"~::~GROUP BY ")
						.replace(/ HAVING /ig,"~::~HAVING ")
						//.replace(/ SET /ig," SET~::~")
						.replace(/ IN /ig," IN ")

						.replace(/ JOIN /ig,"~::~JOIN ")
						.replace(/ CROSS~::~{1,}JOIN /ig,"~::~CROSS JOIN ")
						.replace(/ INNER~::~{1,}JOIN /ig,"~::~INNER JOIN ")
						.replace(/ LEFT~::~{1,}JOIN /ig,"~::~LEFT JOIN ")
						.replace(/ RIGHT~::~{1,}JOIN /ig,"~::~RIGHT JOIN ")

						.replace(/ ON /ig,"~::~"+tab+"ON ")
						.replace(/ OR /ig,"~::~"+tab+tab+"OR ")
						.replace(/ ORDER\s{1,}BY/ig,"~::~ORDER BY ")
						.replace(/ OVER /ig,"~::~"+tab+"OVER ")

						.replace(/\(\s{0,}SELECT /ig,"~::~(SELECT ")
						.replace(/\)\s{0,}SELECT /ig,")~::~SELECT ")

						.replace(/ THEN /ig," THEN~::~"+tab+"")
						.replace(/ UNION /ig,"~::~UNION~::~")
						.replace(/ USING /ig,"~::~USING ")
						.replace(/ WHEN /ig,"~::~"+tab+"WHEN ")
						.replace(/ WHERE /ig,"~::~WHERE ")
						.replace(/ WITH /ig,"~::~WITH ")

						//.replace(/\,\s{0,}\(/ig,",~::~( ")
						//.replace(/\,/ig,",~::~"+tab+tab+"")

						.replace(/ ALL /ig," ALL ")
						.replace(/ AS /ig," AS ")
						.replace(/ ASC /ig," ASC ")
						.replace(/ DESC /ig," DESC ")
						.replace(/ DISTINCT /ig," DISTINCT ")
						.replace(/ EXISTS /ig," EXISTS ")
						.replace(/ NOT /ig," NOT ")
						.replace(/ NULL /ig," NULL ")
						.replace(/ LIKE /ig," LIKE ")
						.replace(/\s{0,}SELECT /ig,"SELECT ")
						.replace(/\s{0,}UPDATE /ig,"UPDATE ")
						.replace(/ SET /ig," SET ")

						.replace(/~::~{1,}/g,"~::~")
						.split('~::~');
		}

		vkbeautify.prototype.sql = function(text,step) {

			var ar_by_quote = text.replace(/\s{1,}/g," ")
									.replace(/\'/ig,"~::~\'")
									.split('~::~'),
				len = ar_by_quote.length,
				ar = [],
				deep = 0,
				tab = this.step,//+this.step,
				parenthesisLevel = 0,
				str = '',
				ix = 0,
				shift = step ? createShiftArr(step) : this.shift;
				for(ix=0;ix<len;ix++) {
					if(ix%2) {
						ar = ar.concat(ar_by_quote[ix]);
					} else {
						ar = ar.concat(split_sql(ar_by_quote[ix], tab) );
					}
				}

				len = ar.length;
				for(ix=0;ix<len;ix++) {

					parenthesisLevel = isSubquery(ar[ix], parenthesisLevel);

					if( /\s{0,}\s{0,}SELECT\s{0,}/.exec(ar[ix]))  {
						ar[ix] = ar[ix].replace(/\,/g,",\n"+tab+tab+"");
					}

					if( /\s{0,}\s{0,}SET\s{0,}/.exec(ar[ix]))  {
						ar[ix] = ar[ix].replace(/\,/g,",\n"+tab+tab+"");
					}

					if( /\s{0,}\(\s{0,}SELECT\s{0,}/.exec(ar[ix]))  {
						deep++;
						str += shift[deep]+ar[ix];
					} else
					if( /\'/.exec(ar[ix]) )  {
						if(parenthesisLevel<1 && deep) {
							deep--;
						}
						str += ar[ix];
					}
					else  {
						str += shift[deep]+ar[ix];
						if(parenthesisLevel<1 && deep) {
							deep--;
						}
					}
				}

				str = str.replace(/^\n{1,}/,'').replace(/\n{1,}/g,"\n");
				return str;
		};


		vkbeautify.prototype.xmlmin = function(text, preserveComments) {

			var str = preserveComments ? text
									   : text.replace(/\<![ \r\n\t]*(--([^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)\>/g,"")
											 .replace(/[ \r\n\t]{1,}xmlns/g, ' xmlns');
			return  str.replace(/>\s{0,}</g,"><");
		};

		vkbeautify.prototype.jsonmin = function(text) {

			if (typeof JSON === 'undefined' ) return text;

			return JSON.stringify(JSON.parse(text), null, 0);

		};

		vkbeautify.prototype.cssmin = function(text, preserveComments) {

			var str = preserveComments ? text
									   : text.replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//g,"") ;

			return str.replace(/\s{1,}/g,' ')
					  .replace(/\{\s{1,}/g,"{")
					  .replace(/\}\s{1,}/g,"}")
					  .replace(/\;\s{1,}/g,";")
					  .replace(/\/\*\s{1,}/g,"/*")
					  .replace(/\*\/\s{1,}/g,"*/");
		};

		vkbeautify.prototype.sqlmin = function(text) {
			return text.replace(/\s{1,}/g," ").replace(/\s{1,}\(/,"(").replace(/\s{1,}\)/,")");
		};

		vkbeautify_1 = new vkbeautify();
		return vkbeautify_1;
	}

	var vkbeautifyExports = requireVkbeautify();
	var vkbeautify = /*@__PURE__*/getDefaultExportFromCjs(vkbeautifyExports);

	var js = {exports: {}};

	var src$2 = {};

	var javascript = {exports: {}};

	var beautifier$2 = {};

	var output = {};

	/*jshint node:true */

	var hasRequiredOutput;

	function requireOutput () {
		if (hasRequiredOutput) return output;
		hasRequiredOutput = 1;

		function OutputLine(parent) {
		  this.__parent = parent;
		  this.__character_count = 0;
		  // use indent_count as a marker for this.__lines that have preserved indentation
		  this.__indent_count = -1;
		  this.__alignment_count = 0;
		  this.__wrap_point_index = 0;
		  this.__wrap_point_character_count = 0;
		  this.__wrap_point_indent_count = -1;
		  this.__wrap_point_alignment_count = 0;

		  this.__items = [];
		}

		OutputLine.prototype.clone_empty = function() {
		  var line = new OutputLine(this.__parent);
		  line.set_indent(this.__indent_count, this.__alignment_count);
		  return line;
		};

		OutputLine.prototype.item = function(index) {
		  if (index < 0) {
		    return this.__items[this.__items.length + index];
		  } else {
		    return this.__items[index];
		  }
		};

		OutputLine.prototype.has_match = function(pattern) {
		  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
		    if (this.__items[lastCheckedOutput].match(pattern)) {
		      return true;
		    }
		  }
		  return false;
		};

		OutputLine.prototype.set_indent = function(indent, alignment) {
		  if (this.is_empty()) {
		    this.__indent_count = indent || 0;
		    this.__alignment_count = alignment || 0;
		    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
		  }
		};

		OutputLine.prototype._set_wrap_point = function() {
		  if (this.__parent.wrap_line_length) {
		    this.__wrap_point_index = this.__items.length;
		    this.__wrap_point_character_count = this.__character_count;
		    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
		    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
		  }
		};

		OutputLine.prototype._should_wrap = function() {
		  return this.__wrap_point_index &&
		    this.__character_count > this.__parent.wrap_line_length &&
		    this.__wrap_point_character_count > this.__parent.next_line.__character_count;
		};

		OutputLine.prototype._allow_wrap = function() {
		  if (this._should_wrap()) {
		    this.__parent.add_new_line();
		    var next = this.__parent.current_line;
		    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
		    next.__items = this.__items.slice(this.__wrap_point_index);
		    this.__items = this.__items.slice(0, this.__wrap_point_index);

		    next.__character_count += this.__character_count - this.__wrap_point_character_count;
		    this.__character_count = this.__wrap_point_character_count;

		    if (next.__items[0] === " ") {
		      next.__items.splice(0, 1);
		      next.__character_count -= 1;
		    }
		    return true;
		  }
		  return false;
		};

		OutputLine.prototype.is_empty = function() {
		  return this.__items.length === 0;
		};

		OutputLine.prototype.last = function() {
		  if (!this.is_empty()) {
		    return this.__items[this.__items.length - 1];
		  } else {
		    return null;
		  }
		};

		OutputLine.prototype.push = function(item) {
		  this.__items.push(item);
		  var last_newline_index = item.lastIndexOf('\n');
		  if (last_newline_index !== -1) {
		    this.__character_count = item.length - last_newline_index;
		  } else {
		    this.__character_count += item.length;
		  }
		};

		OutputLine.prototype.pop = function() {
		  var item = null;
		  if (!this.is_empty()) {
		    item = this.__items.pop();
		    this.__character_count -= item.length;
		  }
		  return item;
		};


		OutputLine.prototype._remove_indent = function() {
		  if (this.__indent_count > 0) {
		    this.__indent_count -= 1;
		    this.__character_count -= this.__parent.indent_size;
		  }
		};

		OutputLine.prototype._remove_wrap_indent = function() {
		  if (this.__wrap_point_indent_count > 0) {
		    this.__wrap_point_indent_count -= 1;
		  }
		};
		OutputLine.prototype.trim = function() {
		  while (this.last() === ' ') {
		    this.__items.pop();
		    this.__character_count -= 1;
		  }
		};

		OutputLine.prototype.toString = function() {
		  var result = '';
		  if (this.is_empty()) {
		    if (this.__parent.indent_empty_lines) {
		      result = this.__parent.get_indent_string(this.__indent_count);
		    }
		  } else {
		    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
		    result += this.__items.join('');
		  }
		  return result;
		};

		function IndentStringCache(options, baseIndentString) {
		  this.__cache = [''];
		  this.__indent_size = options.indent_size;
		  this.__indent_string = options.indent_char;
		  if (!options.indent_with_tabs) {
		    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
		  }

		  // Set to null to continue support for auto detection of base indent
		  baseIndentString = baseIndentString || '';
		  if (options.indent_level > 0) {
		    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
		  }

		  this.__base_string = baseIndentString;
		  this.__base_string_length = baseIndentString.length;
		}

		IndentStringCache.prototype.get_indent_size = function(indent, column) {
		  var result = this.__base_string_length;
		  column = column || 0;
		  if (indent < 0) {
		    result = 0;
		  }
		  result += indent * this.__indent_size;
		  result += column;
		  return result;
		};

		IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
		  var result = this.__base_string;
		  column = column || 0;
		  if (indent_level < 0) {
		    indent_level = 0;
		    result = '';
		  }
		  column += indent_level * this.__indent_size;
		  this.__ensure_cache(column);
		  result += this.__cache[column];
		  return result;
		};

		IndentStringCache.prototype.__ensure_cache = function(column) {
		  while (column >= this.__cache.length) {
		    this.__add_column();
		  }
		};

		IndentStringCache.prototype.__add_column = function() {
		  var column = this.__cache.length;
		  var indent = 0;
		  var result = '';
		  if (this.__indent_size && column >= this.__indent_size) {
		    indent = Math.floor(column / this.__indent_size);
		    column -= indent * this.__indent_size;
		    result = new Array(indent + 1).join(this.__indent_string);
		  }
		  if (column) {
		    result += new Array(column + 1).join(' ');
		  }

		  this.__cache.push(result);
		};

		function Output(options, baseIndentString) {
		  this.__indent_cache = new IndentStringCache(options, baseIndentString);
		  this.raw = false;
		  this._end_with_newline = options.end_with_newline;
		  this.indent_size = options.indent_size;
		  this.wrap_line_length = options.wrap_line_length;
		  this.indent_empty_lines = options.indent_empty_lines;
		  this.__lines = [];
		  this.previous_line = null;
		  this.current_line = null;
		  this.next_line = new OutputLine(this);
		  this.space_before_token = false;
		  this.non_breaking_space = false;
		  this.previous_token_wrapped = false;
		  // initialize
		  this.__add_outputline();
		}

		Output.prototype.__add_outputline = function() {
		  this.previous_line = this.current_line;
		  this.current_line = this.next_line.clone_empty();
		  this.__lines.push(this.current_line);
		};

		Output.prototype.get_line_number = function() {
		  return this.__lines.length;
		};

		Output.prototype.get_indent_string = function(indent, column) {
		  return this.__indent_cache.get_indent_string(indent, column);
		};

		Output.prototype.get_indent_size = function(indent, column) {
		  return this.__indent_cache.get_indent_size(indent, column);
		};

		Output.prototype.is_empty = function() {
		  return !this.previous_line && this.current_line.is_empty();
		};

		Output.prototype.add_new_line = function(force_newline) {
		  // never newline at the start of file
		  // otherwise, newline only if we didn't just add one or we're forced
		  if (this.is_empty() ||
		    (!force_newline && this.just_added_newline())) {
		    return false;
		  }

		  // if raw output is enabled, don't print additional newlines,
		  // but still return True as though you had
		  if (!this.raw) {
		    this.__add_outputline();
		  }
		  return true;
		};

		Output.prototype.get_code = function(eol) {
		  this.trim(true);

		  // handle some edge cases where the last tokens
		  // has text that ends with newline(s)
		  var last_item = this.current_line.pop();
		  if (last_item) {
		    if (last_item[last_item.length - 1] === '\n') {
		      last_item = last_item.replace(/\n+$/g, '');
		    }
		    this.current_line.push(last_item);
		  }

		  if (this._end_with_newline) {
		    this.__add_outputline();
		  }

		  var sweet_code = this.__lines.join('\n');

		  if (eol !== '\n') {
		    sweet_code = sweet_code.replace(/[\n]/g, eol);
		  }
		  return sweet_code;
		};

		Output.prototype.set_wrap_point = function() {
		  this.current_line._set_wrap_point();
		};

		Output.prototype.set_indent = function(indent, alignment) {
		  indent = indent || 0;
		  alignment = alignment || 0;

		  // Next line stores alignment values
		  this.next_line.set_indent(indent, alignment);

		  // Never indent your first output indent at the start of the file
		  if (this.__lines.length > 1) {
		    this.current_line.set_indent(indent, alignment);
		    return true;
		  }

		  this.current_line.set_indent();
		  return false;
		};

		Output.prototype.add_raw_token = function(token) {
		  for (var x = 0; x < token.newlines; x++) {
		    this.__add_outputline();
		  }
		  this.current_line.set_indent(-1);
		  this.current_line.push(token.whitespace_before);
		  this.current_line.push(token.text);
		  this.space_before_token = false;
		  this.non_breaking_space = false;
		  this.previous_token_wrapped = false;
		};

		Output.prototype.add_token = function(printable_token) {
		  this.__add_space_before_token();
		  this.current_line.push(printable_token);
		  this.space_before_token = false;
		  this.non_breaking_space = false;
		  this.previous_token_wrapped = this.current_line._allow_wrap();
		};

		Output.prototype.__add_space_before_token = function() {
		  if (this.space_before_token && !this.just_added_newline()) {
		    if (!this.non_breaking_space) {
		      this.set_wrap_point();
		    }
		    this.current_line.push(' ');
		  }
		};

		Output.prototype.remove_indent = function(index) {
		  var output_length = this.__lines.length;
		  while (index < output_length) {
		    this.__lines[index]._remove_indent();
		    index++;
		  }
		  this.current_line._remove_wrap_indent();
		};

		Output.prototype.trim = function(eat_newlines) {
		  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

		  this.current_line.trim();

		  while (eat_newlines && this.__lines.length > 1 &&
		    this.current_line.is_empty()) {
		    this.__lines.pop();
		    this.current_line = this.__lines[this.__lines.length - 1];
		    this.current_line.trim();
		  }

		  this.previous_line = this.__lines.length > 1 ?
		    this.__lines[this.__lines.length - 2] : null;
		};

		Output.prototype.just_added_newline = function() {
		  return this.current_line.is_empty();
		};

		Output.prototype.just_added_blankline = function() {
		  return this.is_empty() ||
		    (this.current_line.is_empty() && this.previous_line.is_empty());
		};

		Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
		  var index = this.__lines.length - 2;
		  while (index >= 0) {
		    var potentialEmptyLine = this.__lines[index];
		    if (potentialEmptyLine.is_empty()) {
		      break;
		    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&
		      potentialEmptyLine.item(-1) !== ends_with) {
		      this.__lines.splice(index + 1, 0, new OutputLine(this));
		      this.previous_line = this.__lines[this.__lines.length - 2];
		      break;
		    }
		    index--;
		  }
		};

		output.Output = Output;
		return output;
	}

	var token = {};

	/*jshint node:true */

	var hasRequiredToken;

	function requireToken () {
		if (hasRequiredToken) return token;
		hasRequiredToken = 1;

		function Token(type, text, newlines, whitespace_before) {
		  this.type = type;
		  this.text = text;

		  // comments_before are
		  // comments that have a new line before them
		  // and may or may not have a newline after
		  // this is a set of comments before
		  this.comments_before = null; /* inline comment*/


		  // this.comments_after =  new TokenStream(); // no new line before and newline after
		  this.newlines = newlines || 0;
		  this.whitespace_before = whitespace_before || '';
		  this.parent = null;
		  this.next = null;
		  this.previous = null;
		  this.opened = null;
		  this.closed = null;
		  this.directives = null;
		}


		token.Token = Token;
		return token;
	}

	var acorn = {};

	/* jshint node: true, curly: false */

	var hasRequiredAcorn;

	function requireAcorn () {
		if (hasRequiredAcorn) return acorn;
		hasRequiredAcorn = 1;
		(function (exports) {

			// acorn used char codes to squeeze the last bit of performance out
			// Beautifier is okay without that, so we're using regex
			// permit # (23), $ (36), and @ (64). @ is used in ES7 decorators.
			// 65 through 91 are uppercase letters.
			// permit _ (95).
			// 97 through 123 are lowercase letters.
			var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";

			// inside an identifier @ is not allowed but 0-9 are.
			var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";

			// Big ugly regular expressions that match characters in the
			// whitespace, identifier, and identifier-start categories. These
			// are only applied when a character is found to actually have a
			// code point above 128.
			var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
			var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
			//var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
			//var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

			var unicodeEscapeOrCodePoint = "\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]+\\}";
			var identifierStart = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
			var identifierChars = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";

			exports.identifier = new RegExp(identifierStart + identifierChars, 'g');
			exports.identifierStart = new RegExp(identifierStart);
			exports.identifierMatch = new RegExp("(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");

			// Whether a single character denotes a newline.

			exports.newline = /[\n\r\u2028\u2029]/;

			// Matches a whole line break (where CRLF is considered a single
			// line break). Used to count lines.

			// in javascript, these two differ
			// in python they are the same, different methods are called on them
			exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
			exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g'); 
		} (acorn));
		return acorn;
	}

	var options$3 = {};

	var options$2 = {};

	/*jshint node:true */

	var hasRequiredOptions$3;

	function requireOptions$3 () {
		if (hasRequiredOptions$3) return options$2;
		hasRequiredOptions$3 = 1;

		function Options(options, merge_child_field) {
		  this.raw_options = _mergeOpts(options, merge_child_field);

		  // Support passing the source text back with no change
		  this.disabled = this._get_boolean('disabled');

		  this.eol = this._get_characters('eol', 'auto');
		  this.end_with_newline = this._get_boolean('end_with_newline');
		  this.indent_size = this._get_number('indent_size', 4);
		  this.indent_char = this._get_characters('indent_char', ' ');
		  this.indent_level = this._get_number('indent_level');

		  this.preserve_newlines = this._get_boolean('preserve_newlines', true);
		  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);
		  if (!this.preserve_newlines) {
		    this.max_preserve_newlines = 0;
		  }

		  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\t');
		  if (this.indent_with_tabs) {
		    this.indent_char = '\t';

		    // indent_size behavior changed after 1.8.6
		    // It used to be that indent_size would be
		    // set to 1 for indent_with_tabs. That is no longer needed and
		    // actually doesn't make sense - why not use spaces? Further,
		    // that might produce unexpected behavior - tabs being used
		    // for single-column alignment. So, when indent_with_tabs is true
		    // and indent_size is 1, reset indent_size to 4.
		    if (this.indent_size === 1) {
		      this.indent_size = 4;
		    }
		  }

		  // Backwards compat with 1.3.x
		  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));

		  this.indent_empty_lines = this._get_boolean('indent_empty_lines');

		  // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty', 'angular']
		  // For now, 'auto' = all off for javascript, all except angular on for html (and inline javascript/css).
		  // other values ignored
		  this.templating = this._get_selection_list('templating', ['auto', 'none', 'angular', 'django', 'erb', 'handlebars', 'php', 'smarty'], ['auto']);
		}

		Options.prototype._get_array = function(name, default_value) {
		  var option_value = this.raw_options[name];
		  var result = default_value || [];
		  if (typeof option_value === 'object') {
		    if (option_value !== null && typeof option_value.concat === 'function') {
		      result = option_value.concat();
		    }
		  } else if (typeof option_value === 'string') {
		    result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
		  }
		  return result;
		};

		Options.prototype._get_boolean = function(name, default_value) {
		  var option_value = this.raw_options[name];
		  var result = option_value === undefined ? !!default_value : !!option_value;
		  return result;
		};

		Options.prototype._get_characters = function(name, default_value) {
		  var option_value = this.raw_options[name];
		  var result = default_value || '';
		  if (typeof option_value === 'string') {
		    result = option_value.replace(/\\r/, '\r').replace(/\\n/, '\n').replace(/\\t/, '\t');
		  }
		  return result;
		};

		Options.prototype._get_number = function(name, default_value) {
		  var option_value = this.raw_options[name];
		  default_value = parseInt(default_value, 10);
		  if (isNaN(default_value)) {
		    default_value = 0;
		  }
		  var result = parseInt(option_value, 10);
		  if (isNaN(result)) {
		    result = default_value;
		  }
		  return result;
		};

		Options.prototype._get_selection = function(name, selection_list, default_value) {
		  var result = this._get_selection_list(name, selection_list, default_value);
		  if (result.length !== 1) {
		    throw new Error(
		      "Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" +
		      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
		  }

		  return result[0];
		};


		Options.prototype._get_selection_list = function(name, selection_list, default_value) {
		  if (!selection_list || selection_list.length === 0) {
		    throw new Error("Selection list cannot be empty.");
		  }

		  default_value = default_value || [selection_list[0]];
		  if (!this._is_valid_selection(default_value, selection_list)) {
		    throw new Error("Invalid Default Value!");
		  }

		  var result = this._get_array(name, default_value);
		  if (!this._is_valid_selection(result, selection_list)) {
		    throw new Error(
		      "Invalid Option Value: The option '" + name + "' can contain only the following values:\n" +
		      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
		  }

		  return result;
		};

		Options.prototype._is_valid_selection = function(result, selection_list) {
		  return result.length && selection_list.length &&
		    !result.some(function(item) { return selection_list.indexOf(item) === -1; });
		};


		// merges child options up with the parent options object
		// Example: obj = {a: 1, b: {a: 2}}
		//          mergeOpts(obj, 'b')
		//
		//          Returns: {a: 2}
		function _mergeOpts(allOptions, childFieldName) {
		  var finalOpts = {};
		  allOptions = _normalizeOpts(allOptions);
		  var name;

		  for (name in allOptions) {
		    if (name !== childFieldName) {
		      finalOpts[name] = allOptions[name];
		    }
		  }

		  //merge in the per type settings for the childFieldName
		  if (childFieldName && allOptions[childFieldName]) {
		    for (name in allOptions[childFieldName]) {
		      finalOpts[name] = allOptions[childFieldName][name];
		    }
		  }
		  return finalOpts;
		}

		function _normalizeOpts(options) {
		  var convertedOpts = {};
		  var key;

		  for (key in options) {
		    var newKey = key.replace(/-/g, "_");
		    convertedOpts[newKey] = options[key];
		  }
		  return convertedOpts;
		}

		options$2.Options = Options;
		options$2.normalizeOpts = _normalizeOpts;
		options$2.mergeOpts = _mergeOpts;
		return options$2;
	}

	/*jshint node:true */

	var hasRequiredOptions$2;

	function requireOptions$2 () {
		if (hasRequiredOptions$2) return options$3;
		hasRequiredOptions$2 = 1;

		var BaseOptions = requireOptions$3().Options;

		var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

		function Options(options) {
		  BaseOptions.call(this, options, 'js');

		  // compatibility, re
		  var raw_brace_style = this.raw_options.brace_style || null;
		  if (raw_brace_style === "expand-strict") { //graceful handling of deprecated option
		    this.raw_options.brace_style = "expand";
		  } else if (raw_brace_style === "collapse-preserve-inline") { //graceful handling of deprecated option
		    this.raw_options.brace_style = "collapse,preserve-inline";
		  } else if (this.raw_options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
		    this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
		    // } else if (!raw_brace_style) { //Nothing exists to set it
		    //   raw_brace_style = "collapse";
		  }

		  //preserve-inline in delimited string will trigger brace_preserve_inline, everything
		  //else is considered a brace_style and the last one only will have an effect

		  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);

		  this.brace_preserve_inline = false; //Defaults in case one or other was not specified in meta-option
		  this.brace_style = "collapse";

		  for (var bs = 0; bs < brace_style_split.length; bs++) {
		    if (brace_style_split[bs] === "preserve-inline") {
		      this.brace_preserve_inline = true;
		    } else {
		      this.brace_style = brace_style_split[bs];
		    }
		  }

		  this.unindent_chained_methods = this._get_boolean('unindent_chained_methods');
		  this.break_chained_methods = this._get_boolean('break_chained_methods');
		  this.space_in_paren = this._get_boolean('space_in_paren');
		  this.space_in_empty_paren = this._get_boolean('space_in_empty_paren');
		  this.jslint_happy = this._get_boolean('jslint_happy');
		  this.space_after_anon_function = this._get_boolean('space_after_anon_function');
		  this.space_after_named_function = this._get_boolean('space_after_named_function');
		  this.keep_array_indentation = this._get_boolean('keep_array_indentation');
		  this.space_before_conditional = this._get_boolean('space_before_conditional', true);
		  this.unescape_strings = this._get_boolean('unescape_strings');
		  this.e4x = this._get_boolean('e4x');
		  this.comma_first = this._get_boolean('comma_first');
		  this.operator_position = this._get_selection('operator_position', validPositionValues);

		  // For testing of beautify preserve:start directive
		  this.test_output_raw = this._get_boolean('test_output_raw');

		  // force this._options.space_after_anon_function to true if this._options.jslint_happy
		  if (this.jslint_happy) {
		    this.space_after_anon_function = true;
		  }

		}
		Options.prototype = new BaseOptions();



		options$3.Options = Options;
		return options$3;
	}

	var tokenizer$2 = {};

	var inputscanner = {};

	/*jshint node:true */

	var hasRequiredInputscanner;

	function requireInputscanner () {
		if (hasRequiredInputscanner) return inputscanner;
		hasRequiredInputscanner = 1;

		var regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');

		function InputScanner(input_string) {
		  this.__input = input_string || '';
		  this.__input_length = this.__input.length;
		  this.__position = 0;
		}

		InputScanner.prototype.restart = function() {
		  this.__position = 0;
		};

		InputScanner.prototype.back = function() {
		  if (this.__position > 0) {
		    this.__position -= 1;
		  }
		};

		InputScanner.prototype.hasNext = function() {
		  return this.__position < this.__input_length;
		};

		InputScanner.prototype.next = function() {
		  var val = null;
		  if (this.hasNext()) {
		    val = this.__input.charAt(this.__position);
		    this.__position += 1;
		  }
		  return val;
		};

		InputScanner.prototype.peek = function(index) {
		  var val = null;
		  index = index || 0;
		  index += this.__position;
		  if (index >= 0 && index < this.__input_length) {
		    val = this.__input.charAt(index);
		  }
		  return val;
		};

		// This is a JavaScript only helper function (not in python)
		// Javascript doesn't have a match method
		// and not all implementation support "sticky" flag.
		// If they do not support sticky then both this.match() and this.test() method
		// must get the match and check the index of the match.
		// If sticky is supported and set, this method will use it.
		// Otherwise it will check that global is set, and fall back to the slower method.
		InputScanner.prototype.__match = function(pattern, index) {
		  pattern.lastIndex = index;
		  var pattern_match = pattern.exec(this.__input);

		  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
		    if (pattern_match.index !== index) {
		      pattern_match = null;
		    }
		  }

		  return pattern_match;
		};

		InputScanner.prototype.test = function(pattern, index) {
		  index = index || 0;
		  index += this.__position;

		  if (index >= 0 && index < this.__input_length) {
		    return !!this.__match(pattern, index);
		  } else {
		    return false;
		  }
		};

		InputScanner.prototype.testChar = function(pattern, index) {
		  // test one character regex match
		  var val = this.peek(index);
		  pattern.lastIndex = 0;
		  return val !== null && pattern.test(val);
		};

		InputScanner.prototype.match = function(pattern) {
		  var pattern_match = this.__match(pattern, this.__position);
		  if (pattern_match) {
		    this.__position += pattern_match[0].length;
		  } else {
		    pattern_match = null;
		  }
		  return pattern_match;
		};

		InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
		  var val = '';
		  var match;
		  if (starting_pattern) {
		    match = this.match(starting_pattern);
		    if (match) {
		      val += match[0];
		    }
		  }
		  if (until_pattern && (match || !starting_pattern)) {
		    val += this.readUntil(until_pattern, until_after);
		  }
		  return val;
		};

		InputScanner.prototype.readUntil = function(pattern, until_after) {
		  var val = '';
		  var match_index = this.__position;
		  pattern.lastIndex = this.__position;
		  var pattern_match = pattern.exec(this.__input);
		  if (pattern_match) {
		    match_index = pattern_match.index;
		    if (until_after) {
		      match_index += pattern_match[0].length;
		    }
		  } else {
		    match_index = this.__input_length;
		  }

		  val = this.__input.substring(this.__position, match_index);
		  this.__position = match_index;
		  return val;
		};

		InputScanner.prototype.readUntilAfter = function(pattern) {
		  return this.readUntil(pattern, true);
		};

		InputScanner.prototype.get_regexp = function(pattern, match_from) {
		  var result = null;
		  var flags = 'g';
		  if (match_from && regexp_has_sticky) {
		    flags = 'y';
		  }
		  // strings are converted to regexp
		  if (typeof pattern === "string" && pattern !== '') {
		    // result = new RegExp(pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), flags);
		    result = new RegExp(pattern, flags);
		  } else if (pattern) {
		    result = new RegExp(pattern.source, flags);
		  }
		  return result;
		};

		InputScanner.prototype.get_literal_regexp = function(literal_string) {
		  return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
		};

		/* css beautifier legacy helpers */
		InputScanner.prototype.peekUntilAfter = function(pattern) {
		  var start = this.__position;
		  var val = this.readUntilAfter(pattern);
		  this.__position = start;
		  return val;
		};

		InputScanner.prototype.lookBack = function(testVal) {
		  var start = this.__position - 1;
		  return start >= testVal.length && this.__input.substring(start - testVal.length, start)
		    .toLowerCase() === testVal;
		};

		inputscanner.InputScanner = InputScanner;
		return inputscanner;
	}

	var tokenizer$1 = {};

	var tokenstream = {};

	/*jshint node:true */

	var hasRequiredTokenstream;

	function requireTokenstream () {
		if (hasRequiredTokenstream) return tokenstream;
		hasRequiredTokenstream = 1;

		function TokenStream(parent_token) {
		  // private
		  this.__tokens = [];
		  this.__tokens_length = this.__tokens.length;
		  this.__position = 0;
		  this.__parent_token = parent_token;
		}

		TokenStream.prototype.restart = function() {
		  this.__position = 0;
		};

		TokenStream.prototype.isEmpty = function() {
		  return this.__tokens_length === 0;
		};

		TokenStream.prototype.hasNext = function() {
		  return this.__position < this.__tokens_length;
		};

		TokenStream.prototype.next = function() {
		  var val = null;
		  if (this.hasNext()) {
		    val = this.__tokens[this.__position];
		    this.__position += 1;
		  }
		  return val;
		};

		TokenStream.prototype.peek = function(index) {
		  var val = null;
		  index = index || 0;
		  index += this.__position;
		  if (index >= 0 && index < this.__tokens_length) {
		    val = this.__tokens[index];
		  }
		  return val;
		};

		TokenStream.prototype.add = function(token) {
		  if (this.__parent_token) {
		    token.parent = this.__parent_token;
		  }
		  this.__tokens.push(token);
		  this.__tokens_length += 1;
		};

		tokenstream.TokenStream = TokenStream;
		return tokenstream;
	}

	var whitespacepattern = {};

	var pattern = {};

	/*jshint node:true */

	var hasRequiredPattern;

	function requirePattern () {
		if (hasRequiredPattern) return pattern;
		hasRequiredPattern = 1;

		function Pattern(input_scanner, parent) {
		  this._input = input_scanner;
		  this._starting_pattern = null;
		  this._match_pattern = null;
		  this._until_pattern = null;
		  this._until_after = false;

		  if (parent) {
		    this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
		    this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
		    this._until_pattern = this._input.get_regexp(parent._until_pattern);
		    this._until_after = parent._until_after;
		  }
		}

		Pattern.prototype.read = function() {
		  var result = this._input.read(this._starting_pattern);
		  if (!this._starting_pattern || result) {
		    result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
		  }
		  return result;
		};

		Pattern.prototype.read_match = function() {
		  return this._input.match(this._match_pattern);
		};

		Pattern.prototype.until_after = function(pattern) {
		  var result = this._create();
		  result._until_after = true;
		  result._until_pattern = this._input.get_regexp(pattern);
		  result._update();
		  return result;
		};

		Pattern.prototype.until = function(pattern) {
		  var result = this._create();
		  result._until_after = false;
		  result._until_pattern = this._input.get_regexp(pattern);
		  result._update();
		  return result;
		};

		Pattern.prototype.starting_with = function(pattern) {
		  var result = this._create();
		  result._starting_pattern = this._input.get_regexp(pattern, true);
		  result._update();
		  return result;
		};

		Pattern.prototype.matching = function(pattern) {
		  var result = this._create();
		  result._match_pattern = this._input.get_regexp(pattern, true);
		  result._update();
		  return result;
		};

		Pattern.prototype._create = function() {
		  return new Pattern(this._input, this);
		};

		Pattern.prototype._update = function() {};

		pattern.Pattern = Pattern;
		return pattern;
	}

	/*jshint node:true */

	var hasRequiredWhitespacepattern;

	function requireWhitespacepattern () {
		if (hasRequiredWhitespacepattern) return whitespacepattern;
		hasRequiredWhitespacepattern = 1;

		var Pattern = requirePattern().Pattern;

		function WhitespacePattern(input_scanner, parent) {
		  Pattern.call(this, input_scanner, parent);
		  if (parent) {
		    this._line_regexp = this._input.get_regexp(parent._line_regexp);
		  } else {
		    this.__set_whitespace_patterns('', '');
		  }

		  this.newline_count = 0;
		  this.whitespace_before_token = '';
		}
		WhitespacePattern.prototype = new Pattern();

		WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
		  whitespace_chars += '\\t ';
		  newline_chars += '\\n\\r';

		  this._match_pattern = this._input.get_regexp(
		    '[' + whitespace_chars + newline_chars + ']+', true);
		  this._newline_regexp = this._input.get_regexp(
		    '\\r\\n|[' + newline_chars + ']');
		};

		WhitespacePattern.prototype.read = function() {
		  this.newline_count = 0;
		  this.whitespace_before_token = '';

		  var resulting_string = this._input.read(this._match_pattern);
		  if (resulting_string === ' ') {
		    this.whitespace_before_token = ' ';
		  } else if (resulting_string) {
		    var matches = this.__split(this._newline_regexp, resulting_string);
		    this.newline_count = matches.length - 1;
		    this.whitespace_before_token = matches[this.newline_count];
		  }

		  return resulting_string;
		};

		WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
		  var result = this._create();
		  result.__set_whitespace_patterns(whitespace_chars, newline_chars);
		  result._update();
		  return result;
		};

		WhitespacePattern.prototype._create = function() {
		  return new WhitespacePattern(this._input, this);
		};

		WhitespacePattern.prototype.__split = function(regexp, input_string) {
		  regexp.lastIndex = 0;
		  var start_index = 0;
		  var result = [];
		  var next_match = regexp.exec(input_string);
		  while (next_match) {
		    result.push(input_string.substring(start_index, next_match.index));
		    start_index = next_match.index + next_match[0].length;
		    next_match = regexp.exec(input_string);
		  }

		  if (start_index < input_string.length) {
		    result.push(input_string.substring(start_index, input_string.length));
		  } else {
		    result.push('');
		  }

		  return result;
		};



		whitespacepattern.WhitespacePattern = WhitespacePattern;
		return whitespacepattern;
	}

	/*jshint node:true */

	var hasRequiredTokenizer$2;

	function requireTokenizer$2 () {
		if (hasRequiredTokenizer$2) return tokenizer$1;
		hasRequiredTokenizer$2 = 1;

		var InputScanner = requireInputscanner().InputScanner;
		var Token = requireToken().Token;
		var TokenStream = requireTokenstream().TokenStream;
		var WhitespacePattern = requireWhitespacepattern().WhitespacePattern;

		var TOKEN = {
		  START: 'TK_START',
		  RAW: 'TK_RAW',
		  EOF: 'TK_EOF'
		};

		var Tokenizer = function(input_string, options) {
		  this._input = new InputScanner(input_string);
		  this._options = options || {};
		  this.__tokens = null;

		  this._patterns = {};
		  this._patterns.whitespace = new WhitespacePattern(this._input);
		};

		Tokenizer.prototype.tokenize = function() {
		  this._input.restart();
		  this.__tokens = new TokenStream();

		  this._reset();

		  var current;
		  var previous = new Token(TOKEN.START, '');
		  var open_token = null;
		  var open_stack = [];
		  var comments = new TokenStream();

		  while (previous.type !== TOKEN.EOF) {
		    current = this._get_next_token(previous, open_token);
		    while (this._is_comment(current)) {
		      comments.add(current);
		      current = this._get_next_token(previous, open_token);
		    }

		    if (!comments.isEmpty()) {
		      current.comments_before = comments;
		      comments = new TokenStream();
		    }

		    current.parent = open_token;

		    if (this._is_opening(current)) {
		      open_stack.push(open_token);
		      open_token = current;
		    } else if (open_token && this._is_closing(current, open_token)) {
		      current.opened = open_token;
		      open_token.closed = current;
		      open_token = open_stack.pop();
		      current.parent = open_token;
		    }

		    current.previous = previous;
		    previous.next = current;

		    this.__tokens.add(current);
		    previous = current;
		  }

		  return this.__tokens;
		};


		Tokenizer.prototype._is_first_token = function() {
		  return this.__tokens.isEmpty();
		};

		Tokenizer.prototype._reset = function() {};

		Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
		  this._readWhitespace();
		  var resulting_string = this._input.read(/.+/g);
		  if (resulting_string) {
		    return this._create_token(TOKEN.RAW, resulting_string);
		  } else {
		    return this._create_token(TOKEN.EOF, '');
		  }
		};

		Tokenizer.prototype._is_comment = function(current_token) { // jshint unused:false
		  return false;
		};

		Tokenizer.prototype._is_opening = function(current_token) { // jshint unused:false
		  return false;
		};

		Tokenizer.prototype._is_closing = function(current_token, open_token) { // jshint unused:false
		  return false;
		};

		Tokenizer.prototype._create_token = function(type, text) {
		  var token = new Token(type, text,
		    this._patterns.whitespace.newline_count,
		    this._patterns.whitespace.whitespace_before_token);
		  return token;
		};

		Tokenizer.prototype._readWhitespace = function() {
		  return this._patterns.whitespace.read();
		};



		tokenizer$1.Tokenizer = Tokenizer;
		tokenizer$1.TOKEN = TOKEN;
		return tokenizer$1;
	}

	var directives = {};

	/*jshint node:true */

	var hasRequiredDirectives;

	function requireDirectives () {
		if (hasRequiredDirectives) return directives;
		hasRequiredDirectives = 1;

		function Directives(start_block_pattern, end_block_pattern) {
		  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;
		  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;
		  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, 'g');
		  this.__directive_pattern = / (\w+)[:](\w+)/g;

		  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, 'g');
		}

		Directives.prototype.get_directives = function(text) {
		  if (!text.match(this.__directives_block_pattern)) {
		    return null;
		  }

		  var directives = {};
		  this.__directive_pattern.lastIndex = 0;
		  var directive_match = this.__directive_pattern.exec(text);

		  while (directive_match) {
		    directives[directive_match[1]] = directive_match[2];
		    directive_match = this.__directive_pattern.exec(text);
		  }

		  return directives;
		};

		Directives.prototype.readIgnored = function(input) {
		  return input.readUntilAfter(this.__directives_end_ignore_pattern);
		};


		directives.Directives = Directives;
		return directives;
	}

	var templatablepattern = {};

	/*jshint node:true */

	var hasRequiredTemplatablepattern;

	function requireTemplatablepattern () {
		if (hasRequiredTemplatablepattern) return templatablepattern;
		hasRequiredTemplatablepattern = 1;

		var Pattern = requirePattern().Pattern;


		var template_names = {
		  django: false,
		  erb: false,
		  handlebars: false,
		  php: false,
		  smarty: false,
		  angular: false
		};

		// This lets templates appear anywhere we would do a readUntil
		// The cost is higher but it is pay to play.
		function TemplatablePattern(input_scanner, parent) {
		  Pattern.call(this, input_scanner, parent);
		  this.__template_pattern = null;
		  this._disabled = Object.assign({}, template_names);
		  this._excluded = Object.assign({}, template_names);

		  if (parent) {
		    this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
		    this._excluded = Object.assign(this._excluded, parent._excluded);
		    this._disabled = Object.assign(this._disabled, parent._disabled);
		  }
		  var pattern = new Pattern(input_scanner);
		  this.__patterns = {
		    handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),
		    handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),
		    handlebars: pattern.starting_with(/{{/).until_after(/}}/),
		    php: pattern.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
		    erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),
		    // django coflicts with handlebars a bit.
		    django: pattern.starting_with(/{%/).until_after(/%}/),
		    django_value: pattern.starting_with(/{{/).until_after(/}}/),
		    django_comment: pattern.starting_with(/{#/).until_after(/#}/),
		    smarty: pattern.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
		    smarty_comment: pattern.starting_with(/{\*/).until_after(/\*}/),
		    smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\/literal}/)
		  };
		}
		TemplatablePattern.prototype = new Pattern();

		TemplatablePattern.prototype._create = function() {
		  return new TemplatablePattern(this._input, this);
		};

		TemplatablePattern.prototype._update = function() {
		  this.__set_templated_pattern();
		};

		TemplatablePattern.prototype.disable = function(language) {
		  var result = this._create();
		  result._disabled[language] = true;
		  result._update();
		  return result;
		};

		TemplatablePattern.prototype.read_options = function(options) {
		  var result = this._create();
		  for (var language in template_names) {
		    result._disabled[language] = options.templating.indexOf(language) === -1;
		  }
		  result._update();
		  return result;
		};

		TemplatablePattern.prototype.exclude = function(language) {
		  var result = this._create();
		  result._excluded[language] = true;
		  result._update();
		  return result;
		};

		TemplatablePattern.prototype.read = function() {
		  var result = '';
		  if (this._match_pattern) {
		    result = this._input.read(this._starting_pattern);
		  } else {
		    result = this._input.read(this._starting_pattern, this.__template_pattern);
		  }
		  var next = this._read_template();
		  while (next) {
		    if (this._match_pattern) {
		      next += this._input.read(this._match_pattern);
		    } else {
		      next += this._input.readUntil(this.__template_pattern);
		    }
		    result += next;
		    next = this._read_template();
		  }

		  if (this._until_after) {
		    result += this._input.readUntilAfter(this._until_pattern);
		  }
		  return result;
		};

		TemplatablePattern.prototype.__set_templated_pattern = function() {
		  var items = [];

		  if (!this._disabled.php) {
		    items.push(this.__patterns.php._starting_pattern.source);
		  }
		  if (!this._disabled.handlebars) {
		    items.push(this.__patterns.handlebars._starting_pattern.source);
		  }
		  if (!this._disabled.angular) {
		    // Handlebars ('{{' and '}}') are also special tokens in Angular)
		    items.push(this.__patterns.handlebars._starting_pattern.source);
		  }
		  if (!this._disabled.erb) {
		    items.push(this.__patterns.erb._starting_pattern.source);
		  }
		  if (!this._disabled.django) {
		    items.push(this.__patterns.django._starting_pattern.source);
		    // The starting pattern for django is more complex because it has different
		    // patterns for value, comment, and other sections
		    items.push(this.__patterns.django_value._starting_pattern.source);
		    items.push(this.__patterns.django_comment._starting_pattern.source);
		  }
		  if (!this._disabled.smarty) {
		    items.push(this.__patterns.smarty._starting_pattern.source);
		  }

		  if (this._until_pattern) {
		    items.push(this._until_pattern.source);
		  }
		  this.__template_pattern = this._input.get_regexp('(?:' + items.join('|') + ')');
		};

		TemplatablePattern.prototype._read_template = function() {
		  var resulting_string = '';
		  var c = this._input.peek();
		  if (c === '<') {
		    var peek1 = this._input.peek(1);
		    //if we're in a comment, do something special
		    // We treat all comments as literals, even more than preformatted tags
		    // we just look for the appropriate close tag
		    if (!this._disabled.php && !this._excluded.php && peek1 === '?') {
		      resulting_string = resulting_string ||
		        this.__patterns.php.read();
		    }
		    if (!this._disabled.erb && !this._excluded.erb && peek1 === '%') {
		      resulting_string = resulting_string ||
		        this.__patterns.erb.read();
		    }
		  } else if (c === '{') {
		    if (!this._disabled.handlebars && !this._excluded.handlebars) {
		      resulting_string = resulting_string ||
		        this.__patterns.handlebars_comment.read();
		      resulting_string = resulting_string ||
		        this.__patterns.handlebars_unescaped.read();
		      resulting_string = resulting_string ||
		        this.__patterns.handlebars.read();
		    }
		    if (!this._disabled.django) {
		      // django coflicts with handlebars a bit.
		      if (!this._excluded.django && !this._excluded.handlebars) {
		        resulting_string = resulting_string ||
		          this.__patterns.django_value.read();
		      }
		      if (!this._excluded.django) {
		        resulting_string = resulting_string ||
		          this.__patterns.django_comment.read();
		        resulting_string = resulting_string ||
		          this.__patterns.django.read();
		      }
		    }
		    if (!this._disabled.smarty) {
		      // smarty cannot be enabled with django or handlebars enabled
		      if (this._disabled.django && this._disabled.handlebars) {
		        resulting_string = resulting_string ||
		          this.__patterns.smarty_comment.read();
		        resulting_string = resulting_string ||
		          this.__patterns.smarty_literal.read();
		        resulting_string = resulting_string ||
		          this.__patterns.smarty.read();
		      }
		    }
		  }
		  return resulting_string;
		};


		templatablepattern.TemplatablePattern = TemplatablePattern;
		return templatablepattern;
	}

	/*jshint node:true */

	var hasRequiredTokenizer$1;

	function requireTokenizer$1 () {
		if (hasRequiredTokenizer$1) return tokenizer$2;
		hasRequiredTokenizer$1 = 1;

		var InputScanner = requireInputscanner().InputScanner;
		var BaseTokenizer = requireTokenizer$2().Tokenizer;
		var BASETOKEN = requireTokenizer$2().TOKEN;
		var Directives = requireDirectives().Directives;
		var acorn = requireAcorn();
		var Pattern = requirePattern().Pattern;
		var TemplatablePattern = requireTemplatablepattern().TemplatablePattern;


		function in_array(what, arr) {
		  return arr.indexOf(what) !== -1;
		}


		var TOKEN = {
		  START_EXPR: 'TK_START_EXPR',
		  END_EXPR: 'TK_END_EXPR',
		  START_BLOCK: 'TK_START_BLOCK',
		  END_BLOCK: 'TK_END_BLOCK',
		  WORD: 'TK_WORD',
		  RESERVED: 'TK_RESERVED',
		  SEMICOLON: 'TK_SEMICOLON',
		  STRING: 'TK_STRING',
		  EQUALS: 'TK_EQUALS',
		  OPERATOR: 'TK_OPERATOR',
		  COMMA: 'TK_COMMA',
		  BLOCK_COMMENT: 'TK_BLOCK_COMMENT',
		  COMMENT: 'TK_COMMENT',
		  DOT: 'TK_DOT',
		  UNKNOWN: 'TK_UNKNOWN',
		  START: BASETOKEN.START,
		  RAW: BASETOKEN.RAW,
		  EOF: BASETOKEN.EOF
		};


		var directives_core = new Directives(/\/\*/, /\*\//);

		var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/;

		var digit = /[0-9]/;

		// Dot "." must be distinguished from "..." and decimal
		var dot_pattern = /[^\d\.]/;

		var positionable_operators = (
		  ">>> === !== &&= ??= ||= " +
		  "<< && >= ** != == <= >> || ?? |> " +
		  "< / - + > : & % ? ^ | *").split(' ');

		// IMPORTANT: this must be sorted longest to shortest or tokenizing many not work.
		// Also, you must update possitionable operators separately from punct
		var punct =
		  ">>>= " +
		  "... >>= <<= === >>> !== **= &&= ??= ||= " +
		  "=> ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> " +
		  "= ! ? > < : / ^ - + * & % ~ |";

		punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
		// ?. but not if followed by a number 
		punct = '\\?\\.(?!\\d) ' + punct;
		punct = punct.replace(/ /g, '|');

		var punct_pattern = new RegExp(punct);

		// words which should always start on new line.
		var line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
		var reserved_words = line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as', 'class', 'extends']);
		var reserved_word_pattern = new RegExp('^(?:' + reserved_words.join('|') + ')$');

		// var template_pattern = /(?:(?:<\?php|<\?=)[\s\S]*?\?>)|(?:<%[\s\S]*?%>)/g;

		var in_html_comment;

		var Tokenizer = function(input_string, options) {
		  BaseTokenizer.call(this, input_string, options);

		  this._patterns.whitespace = this._patterns.whitespace.matching(
		    /\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source,
		    /\u2028\u2029/.source);

		  var pattern_reader = new Pattern(this._input);
		  var templatable = new TemplatablePattern(this._input)
		    .read_options(this._options);

		  this.__patterns = {
		    template: templatable,
		    identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),
		    number: pattern_reader.matching(number_pattern),
		    punct: pattern_reader.matching(punct_pattern),
		    // comment ends just before nearest linefeed or end of file
		    comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
		    //  /* ... */ comment ends with nearest */ or end of file
		    block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
		    html_comment_start: pattern_reader.matching(/<!--/),
		    html_comment_end: pattern_reader.matching(/-->/),
		    include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),
		    shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),
		    xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\[CDATA\[[^\]]*?\]\]|)(\s*{[^}]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\s*(\/?)\s*>/),
		    single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
		    double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
		    template_text: templatable.until(/[`\\$]/),
		    template_expression: templatable.until(/[`}\\]/)
		  };

		};
		Tokenizer.prototype = new BaseTokenizer();

		Tokenizer.prototype._is_comment = function(current_token) {
		  return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;
		};

		Tokenizer.prototype._is_opening = function(current_token) {
		  return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;
		};

		Tokenizer.prototype._is_closing = function(current_token, open_token) {
		  return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) &&
		    (open_token && (
		      (current_token.text === ']' && open_token.text === '[') ||
		      (current_token.text === ')' && open_token.text === '(') ||
		      (current_token.text === '}' && open_token.text === '{')));
		};

		Tokenizer.prototype._reset = function() {
		  in_html_comment = false;
		};

		Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
		  var token = null;
		  this._readWhitespace();
		  var c = this._input.peek();

		  if (c === null) {
		    return this._create_token(TOKEN.EOF, '');
		  }

		  token = token || this._read_non_javascript(c);
		  token = token || this._read_string(c);
		  token = token || this._read_pair(c, this._input.peek(1)); // Issue #2062 hack for record type '#{'
		  token = token || this._read_word(previous_token);
		  token = token || this._read_singles(c);
		  token = token || this._read_comment(c);
		  token = token || this._read_regexp(c, previous_token);
		  token = token || this._read_xml(c, previous_token);
		  token = token || this._read_punctuation();
		  token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());

		  return token;
		};

		Tokenizer.prototype._read_word = function(previous_token) {
		  var resulting_string;
		  resulting_string = this.__patterns.identifier.read();
		  if (resulting_string !== '') {
		    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\n');
		    if (!(previous_token.type === TOKEN.DOT ||
		        (previous_token.type === TOKEN.RESERVED && (previous_token.text === 'set' || previous_token.text === 'get'))) &&
		      reserved_word_pattern.test(resulting_string)) {
		      if ((resulting_string === 'in' || resulting_string === 'of') &&
		        (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) { // hack for 'in' and 'of' operators
		        return this._create_token(TOKEN.OPERATOR, resulting_string);
		      }
		      return this._create_token(TOKEN.RESERVED, resulting_string);
		    }
		    return this._create_token(TOKEN.WORD, resulting_string);
		  }

		  resulting_string = this.__patterns.number.read();
		  if (resulting_string !== '') {
		    return this._create_token(TOKEN.WORD, resulting_string);
		  }
		};

		Tokenizer.prototype._read_singles = function(c) {
		  var token = null;
		  if (c === '(' || c === '[') {
		    token = this._create_token(TOKEN.START_EXPR, c);
		  } else if (c === ')' || c === ']') {
		    token = this._create_token(TOKEN.END_EXPR, c);
		  } else if (c === '{') {
		    token = this._create_token(TOKEN.START_BLOCK, c);
		  } else if (c === '}') {
		    token = this._create_token(TOKEN.END_BLOCK, c);
		  } else if (c === ';') {
		    token = this._create_token(TOKEN.SEMICOLON, c);
		  } else if (c === '.' && dot_pattern.test(this._input.peek(1))) {
		    token = this._create_token(TOKEN.DOT, c);
		  } else if (c === ',') {
		    token = this._create_token(TOKEN.COMMA, c);
		  }

		  if (token) {
		    this._input.next();
		  }
		  return token;
		};

		Tokenizer.prototype._read_pair = function(c, d) {
		  var token = null;
		  if (c === '#' && d === '{') {
		    token = this._create_token(TOKEN.START_BLOCK, c + d);
		  }

		  if (token) {
		    this._input.next();
		    this._input.next();
		  }
		  return token;
		};

		Tokenizer.prototype._read_punctuation = function() {
		  var resulting_string = this.__patterns.punct.read();

		  if (resulting_string !== '') {
		    if (resulting_string === '=') {
		      return this._create_token(TOKEN.EQUALS, resulting_string);
		    } else if (resulting_string === '?.') {
		      return this._create_token(TOKEN.DOT, resulting_string);
		    } else {
		      return this._create_token(TOKEN.OPERATOR, resulting_string);
		    }
		  }
		};

		Tokenizer.prototype._read_non_javascript = function(c) {
		  var resulting_string = '';

		  if (c === '#') {
		    if (this._is_first_token()) {
		      resulting_string = this.__patterns.shebang.read();

		      if (resulting_string) {
		        return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + '\n');
		      }
		    }

		    // handles extendscript #includes
		    resulting_string = this.__patterns.include.read();

		    if (resulting_string) {
		      return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + '\n');
		    }

		    c = this._input.next();

		    // Spidermonkey-specific sharp variables for circular references. Considered obsolete.
		    var sharp = '#';
		    if (this._input.hasNext() && this._input.testChar(digit)) {
		      do {
		        c = this._input.next();
		        sharp += c;
		      } while (this._input.hasNext() && c !== '#' && c !== '=');
		      if (c === '#') ; else if (this._input.peek() === '[' && this._input.peek(1) === ']') {
		        sharp += '[]';
		        this._input.next();
		        this._input.next();
		      } else if (this._input.peek() === '{' && this._input.peek(1) === '}') {
		        sharp += '{}';
		        this._input.next();
		        this._input.next();
		      }
		      return this._create_token(TOKEN.WORD, sharp);
		    }

		    this._input.back();

		  } else if (c === '<' && this._is_first_token()) {
		    resulting_string = this.__patterns.html_comment_start.read();
		    if (resulting_string) {
		      while (this._input.hasNext() && !this._input.testChar(acorn.newline)) {
		        resulting_string += this._input.next();
		      }
		      in_html_comment = true;
		      return this._create_token(TOKEN.COMMENT, resulting_string);
		    }
		  } else if (in_html_comment && c === '-') {
		    resulting_string = this.__patterns.html_comment_end.read();
		    if (resulting_string) {
		      in_html_comment = false;
		      return this._create_token(TOKEN.COMMENT, resulting_string);
		    }
		  }

		  return null;
		};

		Tokenizer.prototype._read_comment = function(c) {
		  var token = null;
		  if (c === '/') {
		    var comment = '';
		    if (this._input.peek(1) === '*') {
		      // peek for comment /* ... */
		      comment = this.__patterns.block_comment.read();
		      var directives = directives_core.get_directives(comment);
		      if (directives && directives.ignore === 'start') {
		        comment += directives_core.readIgnored(this._input);
		      }
		      comment = comment.replace(acorn.allLineBreaks, '\n');
		      token = this._create_token(TOKEN.BLOCK_COMMENT, comment);
		      token.directives = directives;
		    } else if (this._input.peek(1) === '/') {
		      // peek for comment // ...
		      comment = this.__patterns.comment.read();
		      token = this._create_token(TOKEN.COMMENT, comment);
		    }
		  }
		  return token;
		};

		Tokenizer.prototype._read_string = function(c) {
		  if (c === '`' || c === "'" || c === '"') {
		    var resulting_string = this._input.next();
		    this.has_char_escapes = false;

		    if (c === '`') {
		      resulting_string += this._read_string_recursive('`', true, '${');
		    } else {
		      resulting_string += this._read_string_recursive(c);
		    }

		    if (this.has_char_escapes && this._options.unescape_strings) {
		      resulting_string = unescape_string(resulting_string);
		    }

		    if (this._input.peek() === c) {
		      resulting_string += this._input.next();
		    }

		    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\n');

		    return this._create_token(TOKEN.STRING, resulting_string);
		  }

		  return null;
		};

		Tokenizer.prototype._allow_regexp_or_xml = function(previous_token) {
		  // regex and xml can only appear in specific locations during parsing
		  return (previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
		    (previous_token.type === TOKEN.END_EXPR && previous_token.text === ')' &&
		      previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ['if', 'while', 'for'])) ||
		    (in_array(previous_token.type, [TOKEN.COMMENT, TOKEN.START_EXPR, TOKEN.START_BLOCK, TOKEN.START,
		      TOKEN.END_BLOCK, TOKEN.OPERATOR, TOKEN.EQUALS, TOKEN.EOF, TOKEN.SEMICOLON, TOKEN.COMMA
		    ]));
		};

		Tokenizer.prototype._read_regexp = function(c, previous_token) {

		  if (c === '/' && this._allow_regexp_or_xml(previous_token)) {
		    // handle regexp
		    //
		    var resulting_string = this._input.next();
		    var esc = false;

		    var in_char_class = false;
		    while (this._input.hasNext() &&
		      ((esc || in_char_class || this._input.peek() !== c) &&
		        !this._input.testChar(acorn.newline))) {
		      resulting_string += this._input.peek();
		      if (!esc) {
		        esc = this._input.peek() === '\\';
		        if (this._input.peek() === '[') {
		          in_char_class = true;
		        } else if (this._input.peek() === ']') {
		          in_char_class = false;
		        }
		      } else {
		        esc = false;
		      }
		      this._input.next();
		    }

		    if (this._input.peek() === c) {
		      resulting_string += this._input.next();

		      // regexps may have modifiers /regexp/MOD , so fetch those, too
		      // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
		      resulting_string += this._input.read(acorn.identifier);
		    }
		    return this._create_token(TOKEN.STRING, resulting_string);
		  }
		  return null;
		};

		Tokenizer.prototype._read_xml = function(c, previous_token) {

		  if (this._options.e4x && c === "<" && this._allow_regexp_or_xml(previous_token)) {
		    var xmlStr = '';
		    var match = this.__patterns.xml.read_match();
		    // handle e4x xml literals
		    //
		    if (match) {
		      // Trim root tag to attempt to
		      var rootTag = match[2].replace(/^{\s+/, '{').replace(/\s+}$/, '}');
		      var isCurlyRoot = rootTag.indexOf('{') === 0;
		      var depth = 0;
		      while (match) {
		        var isEndTag = !!match[1];
		        var tagName = match[2];
		        var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
		        if (!isSingletonTag &&
		          (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\s+/, '{').replace(/\s+}$/, '}')))) {
		          if (isEndTag) {
		            --depth;
		          } else {
		            ++depth;
		          }
		        }
		        xmlStr += match[0];
		        if (depth <= 0) {
		          break;
		        }
		        match = this.__patterns.xml.read_match();
		      }
		      // if we didn't close correctly, keep unformatted.
		      if (!match) {
		        xmlStr += this._input.match(/[\s\S]*/g)[0];
		      }
		      xmlStr = xmlStr.replace(acorn.allLineBreaks, '\n');
		      return this._create_token(TOKEN.STRING, xmlStr);
		    }
		  }

		  return null;
		};

		function unescape_string(s) {
		  // You think that a regex would work for this
		  // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
		  //         return String.fromCharCode(parseInt(val, 16));
		  //     })
		  // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
		  var out = '',
		    escaped = 0;

		  var input_scan = new InputScanner(s);
		  var matched = null;

		  while (input_scan.hasNext()) {
		    // Keep any whitespace, non-slash characters
		    // also keep slash pairs.
		    matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);

		    if (matched) {
		      out += matched[0];
		    }

		    if (input_scan.peek() === '\\') {
		      input_scan.next();
		      if (input_scan.peek() === 'x') {
		        matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
		      } else if (input_scan.peek() === 'u') {
		        matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
		        if (!matched) {
		          matched = input_scan.match(/u\{([0-9A-Fa-f]+)\}/g);
		        }
		      } else {
		        out += '\\';
		        if (input_scan.hasNext()) {
		          out += input_scan.next();
		        }
		        continue;
		      }

		      // If there's some error decoding, return the original string
		      if (!matched) {
		        return s;
		      }

		      escaped = parseInt(matched[1], 16);

		      if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {
		        // we bail out on \x7f..\xff,
		        // leaving whole string escaped,
		        // as it's probably completely binary
		        return s;
		      } else if (escaped >= 0x00 && escaped < 0x20) {
		        // leave 0x00...0x1f escaped
		        out += '\\' + matched[0];
		      } else if (escaped > 0x10FFFF) {
		        // If the escape sequence is out of bounds, keep the original sequence and continue conversion
		        out += '\\' + matched[0];
		      } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
		        // single-quote, apostrophe, backslash - escape these
		        out += '\\' + String.fromCharCode(escaped);
		      } else {
		        out += String.fromCharCode(escaped);
		      }
		    }
		  }

		  return out;
		}

		// handle string
		//
		Tokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
		  var current_char;
		  var pattern;
		  if (delimiter === '\'') {
		    pattern = this.__patterns.single_quote;
		  } else if (delimiter === '"') {
		    pattern = this.__patterns.double_quote;
		  } else if (delimiter === '`') {
		    pattern = this.__patterns.template_text;
		  } else if (delimiter === '}') {
		    pattern = this.__patterns.template_expression;
		  }

		  var resulting_string = pattern.read();
		  var next = '';
		  while (this._input.hasNext()) {
		    next = this._input.next();
		    if (next === delimiter ||
		      (!allow_unescaped_newlines && acorn.newline.test(next))) {
		      this._input.back();
		      break;
		    } else if (next === '\\' && this._input.hasNext()) {
		      current_char = this._input.peek();

		      if (current_char === 'x' || current_char === 'u') {
		        this.has_char_escapes = true;
		      } else if (current_char === '\r' && this._input.peek(1) === '\n') {
		        this._input.next();
		      }
		      next += this._input.next();
		    } else if (start_sub) {
		      if (start_sub === '${' && next === '$' && this._input.peek() === '{') {
		        next += this._input.next();
		      }

		      if (start_sub === next) {
		        if (delimiter === '`') {
		          next += this._read_string_recursive('}', allow_unescaped_newlines, '`');
		        } else {
		          next += this._read_string_recursive('`', allow_unescaped_newlines, '${');
		        }
		        if (this._input.hasNext()) {
		          next += this._input.next();
		        }
		      }
		    }
		    next += pattern.read();
		    resulting_string += next;
		  }

		  return resulting_string;
		};

		tokenizer$2.Tokenizer = Tokenizer;
		tokenizer$2.TOKEN = TOKEN;
		tokenizer$2.positionable_operators = positionable_operators.slice();
		tokenizer$2.line_starters = line_starters.slice();
		return tokenizer$2;
	}

	/*jshint node:true */

	var hasRequiredBeautifier$2;

	function requireBeautifier$2 () {
		if (hasRequiredBeautifier$2) return beautifier$2;
		hasRequiredBeautifier$2 = 1;

		var Output = requireOutput().Output;
		var Token = requireToken().Token;
		var acorn = requireAcorn();
		var Options = requireOptions$2().Options;
		var Tokenizer = requireTokenizer$1().Tokenizer;
		var line_starters = requireTokenizer$1().line_starters;
		var positionable_operators = requireTokenizer$1().positionable_operators;
		var TOKEN = requireTokenizer$1().TOKEN;


		function in_array(what, arr) {
		  return arr.indexOf(what) !== -1;
		}

		function ltrim(s) {
		  return s.replace(/^\s+/g, '');
		}

		function generateMapFromStrings(list) {
		  var result = {};
		  for (var x = 0; x < list.length; x++) {
		    // make the mapped names underscored instead of dash
		    result[list[x].replace(/-/g, '_')] = list[x];
		  }
		  return result;
		}

		function reserved_word(token, word) {
		  return token && token.type === TOKEN.RESERVED && token.text === word;
		}

		function reserved_array(token, words) {
		  return token && token.type === TOKEN.RESERVED && in_array(token.text, words);
		}
		// Unsure of what they mean, but they work. Worth cleaning up in future.
		var special_words = ['case', 'return', 'do', 'if', 'throw', 'else', 'await', 'break', 'continue', 'async'];

		var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

		// Generate map from array
		var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);

		var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];

		var MODE = {
		  BlockStatement: 'BlockStatement', // 'BLOCK'
		  Statement: 'Statement', // 'STATEMENT'
		  ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
		  ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
		  ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
		  Conditional: 'Conditional', //'(COND-EXPRESSION)',
		  Expression: 'Expression' //'(EXPRESSION)'
		};

		function remove_redundant_indentation(output, frame) {
		  // This implementation is effective but has some issues:
		  //     - can cause line wrap to happen too soon due to indent removal
		  //           after wrap points are calculated
		  // These issues are minor compared to ugly indentation.

		  if (frame.multiline_frame ||
		    frame.mode === MODE.ForInitializer ||
		    frame.mode === MODE.Conditional) {
		    return;
		  }

		  // remove one indent from each line inside this section
		  output.remove_indent(frame.start_line_index);
		}

		// we could use just string.split, but
		// IE doesn't like returning empty strings
		function split_linebreaks(s) {
		  //return s.split(/\x0d\x0a|\x0a/);

		  s = s.replace(acorn.allLineBreaks, '\n');
		  var out = [],
		    idx = s.indexOf("\n");
		  while (idx !== -1) {
		    out.push(s.substring(0, idx));
		    s = s.substring(idx + 1);
		    idx = s.indexOf("\n");
		  }
		  if (s.length) {
		    out.push(s);
		  }
		  return out;
		}

		function is_array(mode) {
		  return mode === MODE.ArrayLiteral;
		}

		function is_expression(mode) {
		  return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
		}

		function all_lines_start_with(lines, c) {
		  for (var i = 0; i < lines.length; i++) {
		    var line = lines[i].trim();
		    if (line.charAt(0) !== c) {
		      return false;
		    }
		  }
		  return true;
		}

		function each_line_matches_indent(lines, indent) {
		  var i = 0,
		    len = lines.length,
		    line;
		  for (; i < len; i++) {
		    line = lines[i];
		    // allow empty lines to pass through
		    if (line && line.indexOf(indent) !== 0) {
		      return false;
		    }
		  }
		  return true;
		}


		function Beautifier(source_text, options) {
		  options = options || {};
		  this._source_text = source_text || '';

		  this._output = null;
		  this._tokens = null;
		  this._last_last_text = null;
		  this._flags = null;
		  this._previous_flags = null;

		  this._flag_store = null;
		  this._options = new Options(options);
		}

		Beautifier.prototype.create_flags = function(flags_base, mode) {
		  var next_indent_level = 0;
		  if (flags_base) {
		    next_indent_level = flags_base.indentation_level;
		    if (!this._output.just_added_newline() &&
		      flags_base.line_indent_level > next_indent_level) {
		      next_indent_level = flags_base.line_indent_level;
		    }
		  }

		  var next_flags = {
		    mode: mode,
		    parent: flags_base,
		    last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, ''), // last token text
		    last_word: flags_base ? flags_base.last_word : '', // last TOKEN.WORD passed
		    declaration_statement: false,
		    declaration_assignment: false,
		    multiline_frame: false,
		    inline_frame: false,
		    if_block: false,
		    else_block: false,
		    class_start_block: false, // class A { INSIDE HERE } or class B extends C { INSIDE HERE }
		    do_block: false,
		    do_while: false,
		    import_block: false,
		    in_case_statement: false, // switch(..){ INSIDE HERE }
		    in_case: false, // we're on the exact line with "case 0:"
		    case_body: false, // the indented case-action block
		    case_block: false, // the indented case-action block is wrapped with {}
		    indentation_level: next_indent_level,
		    alignment: 0,
		    line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
		    start_line_index: this._output.get_line_number(),
		    ternary_depth: 0
		  };
		  return next_flags;
		};

		Beautifier.prototype._reset = function(source_text) {
		  var baseIndentString = source_text.match(/^[\t ]*/)[0];

		  this._last_last_text = ''; // pre-last token text
		  this._output = new Output(this._options, baseIndentString);

		  // If testing the ignore directive, start with output disable set to true
		  this._output.raw = this._options.test_output_raw;


		  // Stack of parsing/formatting states, including MODE.
		  // We tokenize, parse, and output in an almost purely a forward-only stream of token input
		  // and formatted output.  This makes the beautifier less accurate than full parsers
		  // but also far more tolerant of syntax errors.
		  //
		  // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
		  // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
		  // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
		  // most full parsers would die, but the beautifier gracefully falls back to
		  // MODE.BlockStatement and continues on.
		  this._flag_store = [];
		  this.set_mode(MODE.BlockStatement);
		  var tokenizer = new Tokenizer(source_text, this._options);
		  this._tokens = tokenizer.tokenize();
		  return source_text;
		};

		Beautifier.prototype.beautify = function() {
		  // if disabled, return the input unchanged.
		  if (this._options.disabled) {
		    return this._source_text;
		  }

		  var sweet_code;
		  var source_text = this._reset(this._source_text);

		  var eol = this._options.eol;
		  if (this._options.eol === 'auto') {
		    eol = '\n';
		    if (source_text && acorn.lineBreak.test(source_text || '')) {
		      eol = source_text.match(acorn.lineBreak)[0];
		    }
		  }

		  var current_token = this._tokens.next();
		  while (current_token) {
		    this.handle_token(current_token);

		    this._last_last_text = this._flags.last_token.text;
		    this._flags.last_token = current_token;

		    current_token = this._tokens.next();
		  }

		  sweet_code = this._output.get_code(eol);

		  return sweet_code;
		};

		Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
		  if (current_token.type === TOKEN.START_EXPR) {
		    this.handle_start_expr(current_token);
		  } else if (current_token.type === TOKEN.END_EXPR) {
		    this.handle_end_expr(current_token);
		  } else if (current_token.type === TOKEN.START_BLOCK) {
		    this.handle_start_block(current_token);
		  } else if (current_token.type === TOKEN.END_BLOCK) {
		    this.handle_end_block(current_token);
		  } else if (current_token.type === TOKEN.WORD) {
		    this.handle_word(current_token);
		  } else if (current_token.type === TOKEN.RESERVED) {
		    this.handle_word(current_token);
		  } else if (current_token.type === TOKEN.SEMICOLON) {
		    this.handle_semicolon(current_token);
		  } else if (current_token.type === TOKEN.STRING) {
		    this.handle_string(current_token);
		  } else if (current_token.type === TOKEN.EQUALS) {
		    this.handle_equals(current_token);
		  } else if (current_token.type === TOKEN.OPERATOR) {
		    this.handle_operator(current_token);
		  } else if (current_token.type === TOKEN.COMMA) {
		    this.handle_comma(current_token);
		  } else if (current_token.type === TOKEN.BLOCK_COMMENT) {
		    this.handle_block_comment(current_token, preserve_statement_flags);
		  } else if (current_token.type === TOKEN.COMMENT) {
		    this.handle_comment(current_token, preserve_statement_flags);
		  } else if (current_token.type === TOKEN.DOT) {
		    this.handle_dot(current_token);
		  } else if (current_token.type === TOKEN.EOF) {
		    this.handle_eof(current_token);
		  } else if (current_token.type === TOKEN.UNKNOWN) {
		    this.handle_unknown(current_token, preserve_statement_flags);
		  } else {
		    this.handle_unknown(current_token, preserve_statement_flags);
		  }
		};

		Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
		  var newlines = current_token.newlines;
		  var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);

		  if (current_token.comments_before) {
		    var comment_token = current_token.comments_before.next();
		    while (comment_token) {
		      // The cleanest handling of inline comments is to treat them as though they aren't there.
		      // Just continue formatting and the behavior should be logical.
		      // Also ignore unknown tokens.  Again, this should result in better behavior.
		      this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
		      this.handle_token(comment_token, preserve_statement_flags);
		      comment_token = current_token.comments_before.next();
		    }
		  }

		  if (keep_whitespace) {
		    for (var i = 0; i < newlines; i += 1) {
		      this.print_newline(i > 0, preserve_statement_flags);
		    }
		  } else {
		    if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
		      newlines = this._options.max_preserve_newlines;
		    }

		    if (this._options.preserve_newlines) {
		      if (newlines > 1) {
		        this.print_newline(false, preserve_statement_flags);
		        for (var j = 1; j < newlines; j += 1) {
		          this.print_newline(true, preserve_statement_flags);
		        }
		      }
		    }
		  }

		};

		var newline_restricted_tokens = ['async', 'break', 'continue', 'return', 'throw', 'yield'];

		Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
		  force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

		  // Never wrap the first token on a line
		  if (this._output.just_added_newline()) {
		    return;
		  }

		  var shouldPreserveOrForce = (this._options.preserve_newlines && current_token.newlines) || force_linewrap;
		  var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) ||
		    in_array(current_token.text, positionable_operators);

		  if (operatorLogicApplies) {
		    var shouldPrintOperatorNewline = (
		        in_array(this._flags.last_token.text, positionable_operators) &&
		        in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)
		      ) ||
		      in_array(current_token.text, positionable_operators);
		    shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
		  }

		  if (shouldPreserveOrForce) {
		    this.print_newline(false, true);
		  } else if (this._options.wrap_line_length) {
		    if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
		      // These tokens should never have a newline inserted
		      // between them and the following expression.
		      return;
		    }
		    this._output.set_wrap_point();
		  }
		};

		Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
		  if (!preserve_statement_flags) {
		    if (this._flags.last_token.text !== ';' && this._flags.last_token.text !== ',' && this._flags.last_token.text !== '=' && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) {
		      var next_token = this._tokens.peek();
		      while (this._flags.mode === MODE.Statement &&
		        !(this._flags.if_block && reserved_word(next_token, 'else')) &&
		        !this._flags.do_block) {
		        this.restore_mode();
		      }
		    }
		  }

		  if (this._output.add_new_line(force_newline)) {
		    this._flags.multiline_frame = true;
		  }
		};

		Beautifier.prototype.print_token_line_indentation = function(current_token) {
		  if (this._output.just_added_newline()) {
		    if (this._options.keep_array_indentation &&
		      current_token.newlines &&
		      (current_token.text === '[' || is_array(this._flags.mode))) {
		      this._output.current_line.set_indent(-1);
		      this._output.current_line.push(current_token.whitespace_before);
		      this._output.space_before_token = false;
		    } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
		      this._flags.line_indent_level = this._flags.indentation_level;
		    }
		  }
		};

		Beautifier.prototype.print_token = function(current_token) {
		  if (this._output.raw) {
		    this._output.add_raw_token(current_token);
		    return;
		  }

		  if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA &&
		    this._output.just_added_newline()) {
		    if (this._output.previous_line.last() === ',') {
		      var popped = this._output.previous_line.pop();
		      // if the comma was already at the start of the line,
		      // pull back onto that line and reprint the indentation
		      if (this._output.previous_line.is_empty()) {
		        this._output.previous_line.push(popped);
		        this._output.trim(true);
		        this._output.current_line.pop();
		        this._output.trim();
		      }

		      // add the comma in front of the next token
		      this.print_token_line_indentation(current_token);
		      this._output.add_token(',');
		      this._output.space_before_token = true;
		    }
		  }

		  this.print_token_line_indentation(current_token);
		  this._output.non_breaking_space = true;
		  this._output.add_token(current_token.text);
		  if (this._output.previous_token_wrapped) {
		    this._flags.multiline_frame = true;
		  }
		};

		Beautifier.prototype.indent = function() {
		  this._flags.indentation_level += 1;
		  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
		};

		Beautifier.prototype.deindent = function() {
		  if (this._flags.indentation_level > 0 &&
		    ((!this._flags.parent) || this._flags.indentation_level > this._flags.parent.indentation_level)) {
		    this._flags.indentation_level -= 1;
		    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
		  }
		};

		Beautifier.prototype.set_mode = function(mode) {
		  if (this._flags) {
		    this._flag_store.push(this._flags);
		    this._previous_flags = this._flags;
		  } else {
		    this._previous_flags = this.create_flags(null, mode);
		  }

		  this._flags = this.create_flags(this._previous_flags, mode);
		  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
		};


		Beautifier.prototype.restore_mode = function() {
		  if (this._flag_store.length > 0) {
		    this._previous_flags = this._flags;
		    this._flags = this._flag_store.pop();
		    if (this._previous_flags.mode === MODE.Statement) {
		      remove_redundant_indentation(this._output, this._previous_flags);
		    }
		    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
		  }
		};

		Beautifier.prototype.start_of_object_property = function() {
		  return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (
		    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || (reserved_array(this._flags.last_token, ['get', 'set'])));
		};

		Beautifier.prototype.start_of_statement = function(current_token) {
		  var start = false;
		  start = start || reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN.WORD;
		  start = start || reserved_word(this._flags.last_token, 'do');
		  start = start || (!(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement)) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
		  start = start || reserved_word(this._flags.last_token, 'else') &&
		    !(reserved_word(current_token, 'if') && !current_token.comments_before);
		  start = start || (this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional));
		  start = start || (this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement &&
		    !this._flags.in_case &&
		    !(current_token.text === '--' || current_token.text === '++') &&
		    this._last_last_text !== 'function' &&
		    current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED);
		  start = start || (this._flags.mode === MODE.ObjectLiteral && (
		    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || reserved_array(this._flags.last_token, ['get', 'set'])));

		  if (start) {
		    this.set_mode(MODE.Statement);
		    this.indent();

		    this.handle_whitespace_and_comments(current_token, true);

		    // Issue #276:
		    // If starting a new statement with [if, for, while, do], push to a new line.
		    // if (a) if (b) if(c) d(); else e(); else f();
		    if (!this.start_of_object_property()) {
		      this.allow_wrap_or_preserved_newline(current_token,
		        reserved_array(current_token, ['do', 'for', 'if', 'while']));
		    }
		    return true;
		  }
		  return false;
		};

		Beautifier.prototype.handle_start_expr = function(current_token) {
		  // The conditional starts the statement if appropriate.
		  if (!this.start_of_statement(current_token)) {
		    this.handle_whitespace_and_comments(current_token);
		  }

		  var next_mode = MODE.Expression;
		  if (current_token.text === '[') {

		    if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ')') {
		      // this is array index specifier, break immediately
		      // a[x], fn()[x]
		      if (reserved_array(this._flags.last_token, line_starters)) {
		        this._output.space_before_token = true;
		      }
		      this.print_token(current_token);
		      this.set_mode(next_mode);
		      this.indent();
		      if (this._options.space_in_paren) {
		        this._output.space_before_token = true;
		      }
		      return;
		    }

		    next_mode = MODE.ArrayLiteral;
		    if (is_array(this._flags.mode)) {
		      if (this._flags.last_token.text === '[' ||
		        (this._flags.last_token.text === ',' && (this._last_last_text === ']' || this._last_last_text === '}'))) {
		        // ], [ goes to new line
		        // }, [ goes to new line
		        if (!this._options.keep_array_indentation) {
		          this.print_newline();
		        }
		      }
		    }

		    if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR, TOKEN.DOT])) {
		      this._output.space_before_token = true;
		    }
		  } else {
		    if (this._flags.last_token.type === TOKEN.RESERVED) {
		      if (this._flags.last_token.text === 'for') {
		        this._output.space_before_token = this._options.space_before_conditional;
		        next_mode = MODE.ForInitializer;
		      } else if (in_array(this._flags.last_token.text, ['if', 'while', 'switch'])) {
		        this._output.space_before_token = this._options.space_before_conditional;
		        next_mode = MODE.Conditional;
		      } else if (in_array(this._flags.last_word, ['await', 'async'])) {
		        // Should be a space between await and an IIFE, or async and an arrow function
		        this._output.space_before_token = true;
		      } else if (this._flags.last_token.text === 'import' && current_token.whitespace_before === '') {
		        this._output.space_before_token = false;
		      } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === 'catch') {
		        this._output.space_before_token = true;
		      }
		    } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
		      // Support of this kind of newline preservation.
		      // a = (b &&
		      //     (c || d));
		      if (!this.start_of_object_property()) {
		        this.allow_wrap_or_preserved_newline(current_token);
		      }
		    } else if (this._flags.last_token.type === TOKEN.WORD) {
		      this._output.space_before_token = false;

		      // function name() vs function name ()
		      // function* name() vs function* name ()
		      // async name() vs async name ()
		      // In ES6, you can also define the method properties of an object
		      // var obj = {a: function() {}}
		      // It can be abbreviated
		      // var obj = {a() {}}
		      // var obj = { a() {}} vs var obj = { a () {}}
		      // var obj = { * a() {}} vs var obj = { * a () {}}
		      var peek_back_two = this._tokens.peek(-3);
		      if (this._options.space_after_named_function && peek_back_two) {
		        // peek starts at next character so -1 is current token
		        var peek_back_three = this._tokens.peek(-4);
		        if (reserved_array(peek_back_two, ['async', 'function']) ||
		          (peek_back_two.text === '*' && reserved_array(peek_back_three, ['async', 'function']))) {
		          this._output.space_before_token = true;
		        } else if (this._flags.mode === MODE.ObjectLiteral) {
		          if ((peek_back_two.text === '{' || peek_back_two.text === ',') ||
		            (peek_back_two.text === '*' && (peek_back_three.text === '{' || peek_back_three.text === ','))) {
		            this._output.space_before_token = true;
		          }
		        } else if (this._flags.parent && this._flags.parent.class_start_block) {
		          this._output.space_before_token = true;
		        }
		      }
		    } else {
		      // Support preserving wrapped arrow function expressions
		      // a.b('c',
		      //     () => d.e
		      // )
		      this.allow_wrap_or_preserved_newline(current_token);
		    }

		    // function() vs function ()
		    // yield*() vs yield* ()
		    // function*() vs function* ()
		    if ((this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === 'function' || this._flags.last_word === 'typeof')) ||
		      (this._flags.last_token.text === '*' &&
		        (in_array(this._last_last_text, ['function', 'yield']) ||
		          (this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ['{', ',']))))) {
		      this._output.space_before_token = this._options.space_after_anon_function;
		    }
		  }

		  if (this._flags.last_token.text === ';' || this._flags.last_token.type === TOKEN.START_BLOCK) {
		    this.print_newline();
		  } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === '.' || this._flags.last_token.type === TOKEN.COMMA) {
		    // do nothing on (( and )( and ][ and ]( and .(
		    // TODO: Consider whether forcing this is required.  Review failing tests when removed.
		    this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
		  }

		  this.print_token(current_token);
		  this.set_mode(next_mode);
		  if (this._options.space_in_paren) {
		    this._output.space_before_token = true;
		  }

		  // In all cases, if we newline while inside an expression it should be indented.
		  this.indent();
		};

		Beautifier.prototype.handle_end_expr = function(current_token) {
		  // statements inside expressions are not valid syntax, but...
		  // statements must all be closed when their container closes
		  while (this._flags.mode === MODE.Statement) {
		    this.restore_mode();
		  }

		  this.handle_whitespace_and_comments(current_token);

		  if (this._flags.multiline_frame) {
		    this.allow_wrap_or_preserved_newline(current_token,
		      current_token.text === ']' && is_array(this._flags.mode) && !this._options.keep_array_indentation);
		  }

		  if (this._options.space_in_paren) {
		    if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {
		      // () [] no inner space in empty parens like these, ever, ref #320
		      this._output.trim();
		      this._output.space_before_token = false;
		    } else {
		      this._output.space_before_token = true;
		    }
		  }
		  this.deindent();
		  this.print_token(current_token);
		  this.restore_mode();

		  remove_redundant_indentation(this._output, this._previous_flags);

		  // do {} while () // no statement required after
		  if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
		    this._previous_flags.mode = MODE.Expression;
		    this._flags.do_block = false;
		    this._flags.do_while = false;

		  }
		};

		Beautifier.prototype.handle_start_block = function(current_token) {
		  this.handle_whitespace_and_comments(current_token);

		  // Check if this is should be treated as a ObjectLiteral
		  var next_token = this._tokens.peek();
		  var second_token = this._tokens.peek(1);
		  if (this._flags.last_word === 'switch' && this._flags.last_token.type === TOKEN.END_EXPR) {
		    this.set_mode(MODE.BlockStatement);
		    this._flags.in_case_statement = true;
		  } else if (this._flags.case_body) {
		    this.set_mode(MODE.BlockStatement);
		  } else if (second_token && (
		      (in_array(second_token.text, [':', ',']) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED])) ||
		      (in_array(next_token.text, ['get', 'set', '...']) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))
		    )) {
		    // We don't support TypeScript,but we didn't break it for a very long time.
		    // We'll try to keep not breaking it.
		    if (in_array(this._last_last_text, ['class', 'interface']) && !in_array(second_token.text, [':', ','])) {
		      this.set_mode(MODE.BlockStatement);
		    } else {
		      this.set_mode(MODE.ObjectLiteral);
		    }
		  } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === '=>') {
		    // arrow function: (param1, paramN) => { statements }
		    this.set_mode(MODE.BlockStatement);
		  } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) ||
		    reserved_array(this._flags.last_token, ['return', 'throw', 'import', 'default'])
		  ) {
		    // Detecting shorthand function syntax is difficult by scanning forward,
		    //     so check the surrounding context.
		    // If the block is being returned, imported, export default, passed as arg,
		    //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
		    this.set_mode(MODE.ObjectLiteral);
		  } else {
		    this.set_mode(MODE.BlockStatement);
		  }

		  if (this._flags.last_token) {
		    if (reserved_array(this._flags.last_token.previous, ['class', 'extends'])) {
		      this._flags.class_start_block = true;
		    }
		  }

		  var empty_braces = !next_token.comments_before && next_token.text === '}';
		  var empty_anonymous_function = empty_braces && this._flags.last_word === 'function' &&
		    this._flags.last_token.type === TOKEN.END_EXPR;

		  if (this._options.brace_preserve_inline) // check for inline, set inline_frame if so
		  {
		    // search forward for a newline wanted inside this block
		    var index = 0;
		    var check_token = null;
		    this._flags.inline_frame = true;
		    do {
		      index += 1;
		      check_token = this._tokens.peek(index - 1);
		      if (check_token.newlines) {
		        this._flags.inline_frame = false;
		        break;
		      }
		    } while (check_token.type !== TOKEN.EOF &&
		      !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));
		  }

		  if ((this._options.brace_style === "expand" ||
		      (this._options.brace_style === "none" && current_token.newlines)) &&
		    !this._flags.inline_frame) {
		    if (this._flags.last_token.type !== TOKEN.OPERATOR &&
		      (empty_anonymous_function ||
		        this._flags.last_token.type === TOKEN.EQUALS ||
		        (reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== 'else'))) {
		      this._output.space_before_token = true;
		    } else {
		      this.print_newline(false, true);
		    }
		  } else { // collapse || inline_frame
		    if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {
		      if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {
		        this._output.space_before_token = true;
		      }

		      if (this._flags.last_token.type === TOKEN.COMMA || (this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame)) {
		        this.allow_wrap_or_preserved_newline(current_token);
		        this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
		        this._flags.multiline_frame = false;
		      }
		    }
		    if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {
		      if (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.SEMICOLON]) && !this._flags.inline_frame) {
		        this.print_newline();
		      } else {
		        this._output.space_before_token = true;
		      }
		    }
		  }
		  this.print_token(current_token);
		  this.indent();

		  // Except for specific cases, open braces are followed by a new line.
		  if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
		    this.print_newline();
		  }
		};

		Beautifier.prototype.handle_end_block = function(current_token) {
		  // statements must all be closed when their container closes
		  this.handle_whitespace_and_comments(current_token);

		  while (this._flags.mode === MODE.Statement) {
		    this.restore_mode();
		  }

		  var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;

		  if (this._flags.inline_frame && !empty_braces) { // try inline_frame (only set if this._options.braces-preserve-inline) first
		    this._output.space_before_token = true;
		  } else if (this._options.brace_style === "expand") {
		    if (!empty_braces) {
		      this.print_newline();
		    }
		  } else {
		    // skip {}
		    if (!empty_braces) {
		      if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
		        // we REALLY need a newline here, but newliner would skip that
		        this._options.keep_array_indentation = false;
		        this.print_newline();
		        this._options.keep_array_indentation = true;

		      } else {
		        this.print_newline();
		      }
		    }
		  }
		  this.restore_mode();
		  this.print_token(current_token);
		};

		Beautifier.prototype.handle_word = function(current_token) {
		  if (current_token.type === TOKEN.RESERVED) {
		    if (in_array(current_token.text, ['set', 'get']) && this._flags.mode !== MODE.ObjectLiteral) {
		      current_token.type = TOKEN.WORD;
		    } else if (current_token.text === 'import' && in_array(this._tokens.peek().text, ['(', '.'])) {
		      current_token.type = TOKEN.WORD;
		    } else if (in_array(current_token.text, ['as', 'from']) && !this._flags.import_block) {
		      current_token.type = TOKEN.WORD;
		    } else if (this._flags.mode === MODE.ObjectLiteral) {
		      var next_token = this._tokens.peek();
		      if (next_token.text === ':') {
		        current_token.type = TOKEN.WORD;
		      }
		    }
		  }

		  if (this.start_of_statement(current_token)) {
		    // The conditional starts the statement if appropriate.
		    if (reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN.WORD) {
		      this._flags.declaration_statement = true;
		    }
		  } else if (current_token.newlines && !is_expression(this._flags.mode) &&
		    (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) &&
		    this._flags.last_token.type !== TOKEN.EQUALS &&
		    (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ['var', 'let', 'const', 'set', 'get']))) {
		    this.handle_whitespace_and_comments(current_token);
		    this.print_newline();
		  } else {
		    this.handle_whitespace_and_comments(current_token);
		  }

		  if (this._flags.do_block && !this._flags.do_while) {
		    if (reserved_word(current_token, 'while')) {
		      // do {} ## while ()
		      this._output.space_before_token = true;
		      this.print_token(current_token);
		      this._output.space_before_token = true;
		      this._flags.do_while = true;
		      return;
		    } else {
		      // do {} should always have while as the next word.
		      // if we don't see the expected while, recover
		      this.print_newline();
		      this._flags.do_block = false;
		    }
		  }

		  // if may be followed by else, or not
		  // Bare/inline ifs are tricky
		  // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
		  if (this._flags.if_block) {
		    if (!this._flags.else_block && reserved_word(current_token, 'else')) {
		      this._flags.else_block = true;
		    } else {
		      while (this._flags.mode === MODE.Statement) {
		        this.restore_mode();
		      }
		      this._flags.if_block = false;
		      this._flags.else_block = false;
		    }
		  }

		  if (this._flags.in_case_statement && reserved_array(current_token, ['case', 'default'])) {
		    this.print_newline();
		    if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {
		      // switch cases following one another
		      this.deindent();
		    }
		    this._flags.case_body = false;

		    this.print_token(current_token);
		    this._flags.in_case = true;
		    return;
		  }

		  if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
		    if (!this.start_of_object_property() && !(
		        // start of object property is different for numeric values with +/- prefix operators
		        in_array(this._flags.last_token.text, ['+', '-']) && this._last_last_text === ':' && this._flags.parent.mode === MODE.ObjectLiteral)) {
		      this.allow_wrap_or_preserved_newline(current_token);
		    }
		  }

		  if (reserved_word(current_token, 'function')) {
		    if (in_array(this._flags.last_token.text, ['}', ';']) ||
		      (this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ['(', '[', '{', ':', '=', ',']) || this._flags.last_token.type === TOKEN.OPERATOR))) {
		      // make sure there is a nice clean space of at least one blank line
		      // before a new function definition
		      if (!this._output.just_added_blankline() && !current_token.comments_before) {
		        this.print_newline();
		        this.print_newline(true);
		      }
		    }
		    if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {
		      if (reserved_array(this._flags.last_token, ['get', 'set', 'new', 'export']) ||
		        reserved_array(this._flags.last_token, newline_restricted_tokens)) {
		        this._output.space_before_token = true;
		      } else if (reserved_word(this._flags.last_token, 'default') && this._last_last_text === 'export') {
		        this._output.space_before_token = true;
		      } else if (this._flags.last_token.text === 'declare') {
		        // accomodates Typescript declare function formatting
		        this._output.space_before_token = true;
		      } else {
		        this.print_newline();
		      }
		    } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === '=') {
		      // foo = function
		      this._output.space_before_token = true;
		    } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) ; else {
		      this.print_newline();
		    }

		    this.print_token(current_token);
		    this._flags.last_word = current_token.text;
		    return;
		  }

		  var prefix = 'NONE';

		  if (this._flags.last_token.type === TOKEN.END_BLOCK) {

		    if (this._previous_flags.inline_frame) {
		      prefix = 'SPACE';
		    } else if (!reserved_array(current_token, ['else', 'catch', 'finally', 'from'])) {
		      prefix = 'NEWLINE';
		    } else {
		      if (this._options.brace_style === "expand" ||
		        this._options.brace_style === "end-expand" ||
		        (this._options.brace_style === "none" && current_token.newlines)) {
		        prefix = 'NEWLINE';
		      } else {
		        prefix = 'SPACE';
		        this._output.space_before_token = true;
		      }
		    }
		  } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
		    // TODO: Should this be for STATEMENT as well?
		    prefix = 'NEWLINE';
		  } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {
		    prefix = 'SPACE';
		  } else if (this._flags.last_token.type === TOKEN.STRING) {
		    prefix = 'NEWLINE';
		  } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD ||
		    (this._flags.last_token.text === '*' &&
		      (in_array(this._last_last_text, ['function', 'yield']) ||
		        (this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ['{', ',']))))) {
		    prefix = 'SPACE';
		  } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {
		    if (this._flags.inline_frame) {
		      prefix = 'SPACE';
		    } else {
		      prefix = 'NEWLINE';
		    }
		  } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
		    this._output.space_before_token = true;
		    prefix = 'NEWLINE';
		  }

		  if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {
		    if (this._flags.inline_frame || this._flags.last_token.text === 'else' || this._flags.last_token.text === 'export') {
		      prefix = 'SPACE';
		    } else {
		      prefix = 'NEWLINE';
		    }

		  }

		  if (reserved_array(current_token, ['else', 'catch', 'finally'])) {
		    if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) ||
		        this._options.brace_style === "expand" ||
		        this._options.brace_style === "end-expand" ||
		        (this._options.brace_style === "none" && current_token.newlines)) &&
		      !this._flags.inline_frame) {
		      this.print_newline();
		    } else {
		      this._output.trim(true);
		      var line = this._output.current_line;
		      // If we trimmed and there's something other than a close block before us
		      // put a newline back in.  Handles '} // comment' scenario.
		      if (line.last() !== '}') {
		        this.print_newline();
		      }
		      this._output.space_before_token = true;
		    }
		  } else if (prefix === 'NEWLINE') {
		    if (reserved_array(this._flags.last_token, special_words)) {
		      // no newline between 'return nnn'
		      this._output.space_before_token = true;
		    } else if (this._flags.last_token.text === 'declare' && reserved_array(current_token, ['var', 'let', 'const'])) {
		      // accomodates Typescript declare formatting
		      this._output.space_before_token = true;
		    } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {
		      if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ['var', 'let', 'const'])) && this._flags.last_token.text !== ':') {
		        // no need to force newline on 'var': for (var x = 0...)
		        if (reserved_word(current_token, 'if') && reserved_word(current_token.previous, 'else')) {
		          // no newline for } else if {
		          this._output.space_before_token = true;
		        } else {
		          this.print_newline();
		        }
		      }
		    } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {
		      this.print_newline();
		    }
		  } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === ',' && this._last_last_text === '}') {
		    this.print_newline(); // }, in lists get a newline treatment
		  } else if (prefix === 'SPACE') {
		    this._output.space_before_token = true;
		  }
		  if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {
		    this._output.space_before_token = true;
		  }
		  this.print_token(current_token);
		  this._flags.last_word = current_token.text;

		  if (current_token.type === TOKEN.RESERVED) {
		    if (current_token.text === 'do') {
		      this._flags.do_block = true;
		    } else if (current_token.text === 'if') {
		      this._flags.if_block = true;
		    } else if (current_token.text === 'import') {
		      this._flags.import_block = true;
		    } else if (this._flags.import_block && reserved_word(current_token, 'from')) {
		      this._flags.import_block = false;
		    }
		  }
		};

		Beautifier.prototype.handle_semicolon = function(current_token) {
		  if (this.start_of_statement(current_token)) {
		    // The conditional starts the statement if appropriate.
		    // Semicolon can be the start (and end) of a statement
		    this._output.space_before_token = false;
		  } else {
		    this.handle_whitespace_and_comments(current_token);
		  }

		  var next_token = this._tokens.peek();
		  while (this._flags.mode === MODE.Statement &&
		    !(this._flags.if_block && reserved_word(next_token, 'else')) &&
		    !this._flags.do_block) {
		    this.restore_mode();
		  }

		  // hacky but effective for the moment
		  if (this._flags.import_block) {
		    this._flags.import_block = false;
		  }
		  this.print_token(current_token);
		};

		Beautifier.prototype.handle_string = function(current_token) {
		  if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === '' && (current_token.previous.text === ')' || this._flags.last_token.type === TOKEN.WORD)) ; else if (this.start_of_statement(current_token)) {
		    // The conditional starts the statement if appropriate.
		    // One difference - strings want at least a space before
		    this._output.space_before_token = true;
		  } else {
		    this.handle_whitespace_and_comments(current_token);
		    if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {
		      this._output.space_before_token = true;
		    } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
		      if (!this.start_of_object_property()) {
		        this.allow_wrap_or_preserved_newline(current_token);
		      }
		    } else if ((current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === ']' || current_token.previous.text === ')') && current_token.newlines === 0)) {
		      this._output.space_before_token = true;
		    } else {
		      this.print_newline();
		    }
		  }
		  this.print_token(current_token);
		};

		Beautifier.prototype.handle_equals = function(current_token) {
		  if (this.start_of_statement(current_token)) ; else {
		    this.handle_whitespace_and_comments(current_token);
		  }

		  if (this._flags.declaration_statement) {
		    // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
		    this._flags.declaration_assignment = true;
		  }
		  this._output.space_before_token = true;
		  this.print_token(current_token);
		  this._output.space_before_token = true;
		};

		Beautifier.prototype.handle_comma = function(current_token) {
		  this.handle_whitespace_and_comments(current_token, true);

		  this.print_token(current_token);
		  this._output.space_before_token = true;
		  if (this._flags.declaration_statement) {
		    if (is_expression(this._flags.parent.mode)) {
		      // do not break on comma, for(var a = 1, b = 2)
		      this._flags.declaration_assignment = false;
		    }

		    if (this._flags.declaration_assignment) {
		      this._flags.declaration_assignment = false;
		      this.print_newline(false, true);
		    } else if (this._options.comma_first) {
		      // for comma-first, we want to allow a newline before the comma
		      // to turn into a newline after the comma, which we will fixup later
		      this.allow_wrap_or_preserved_newline(current_token);
		    }
		  } else if (this._flags.mode === MODE.ObjectLiteral ||
		    (this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral)) {
		    if (this._flags.mode === MODE.Statement) {
		      this.restore_mode();
		    }

		    if (!this._flags.inline_frame) {
		      this.print_newline();
		    }
		  } else if (this._options.comma_first) {
		    // EXPR or DO_BLOCK
		    // for comma-first, we want to allow a newline before the comma
		    // to turn into a newline after the comma, which we will fixup later
		    this.allow_wrap_or_preserved_newline(current_token);
		  }
		};

		Beautifier.prototype.handle_operator = function(current_token) {
		  var isGeneratorAsterisk = current_token.text === '*' &&
		    (reserved_array(this._flags.last_token, ['function', 'yield']) ||
		      (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]))
		    );
		  var isUnary = in_array(current_token.text, ['-', '+']) && (
		    in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) ||
		    in_array(this._flags.last_token.text, line_starters) ||
		    this._flags.last_token.text === ','
		  );

		  if (this.start_of_statement(current_token)) ; else {
		    var preserve_statement_flags = !isGeneratorAsterisk;
		    this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
		  }

		  // hack for actionscript's import .*;
		  if (current_token.text === '*' && this._flags.last_token.type === TOKEN.DOT) {
		    this.print_token(current_token);
		    return;
		  }

		  if (current_token.text === '::') {
		    // no spaces around exotic namespacing syntax operator
		    this.print_token(current_token);
		    return;
		  }

		  if (in_array(current_token.text, ['-', '+']) && this.start_of_object_property()) {
		    // numeric value with +/- symbol in front as a property
		    this.print_token(current_token);
		    return;
		  }

		  // Allow line wrapping between operators when operator_position is
		  //   set to before or preserve
		  if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
		    this.allow_wrap_or_preserved_newline(current_token);
		  }

		  if (current_token.text === ':' && this._flags.in_case) {
		    this.print_token(current_token);

		    this._flags.in_case = false;
		    this._flags.case_body = true;
		    if (this._tokens.peek().type !== TOKEN.START_BLOCK) {
		      this.indent();
		      this.print_newline();
		      this._flags.case_block = false;
		    } else {
		      this._flags.case_block = true;
		      this._output.space_before_token = true;
		    }
		    return;
		  }

		  var space_before = true;
		  var space_after = true;
		  var in_ternary = false;
		  if (current_token.text === ':') {
		    if (this._flags.ternary_depth === 0) {
		      // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
		      space_before = false;
		    } else {
		      this._flags.ternary_depth -= 1;
		      in_ternary = true;
		    }
		  } else if (current_token.text === '?') {
		    this._flags.ternary_depth += 1;
		  }

		  // let's handle the operator_position option prior to any conflicting logic
		  if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {
		    var isColon = current_token.text === ':';
		    var isTernaryColon = (isColon && in_ternary);
		    var isOtherColon = (isColon && !in_ternary);

		    switch (this._options.operator_position) {
		      case OPERATOR_POSITION.before_newline:
		        // if the current token is : and it's not a ternary statement then we set space_before to false
		        this._output.space_before_token = !isOtherColon;

		        this.print_token(current_token);

		        if (!isColon || isTernaryColon) {
		          this.allow_wrap_or_preserved_newline(current_token);
		        }

		        this._output.space_before_token = true;
		        return;

		      case OPERATOR_POSITION.after_newline:
		        // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
		        //   then print a newline.

		        this._output.space_before_token = true;

		        if (!isColon || isTernaryColon) {
		          if (this._tokens.peek().newlines) {
		            this.print_newline(false, true);
		          } else {
		            this.allow_wrap_or_preserved_newline(current_token);
		          }
		        } else {
		          this._output.space_before_token = false;
		        }

		        this.print_token(current_token);

		        this._output.space_before_token = true;
		        return;

		      case OPERATOR_POSITION.preserve_newline:
		        if (!isOtherColon) {
		          this.allow_wrap_or_preserved_newline(current_token);
		        }

		        // if we just added a newline, or the current token is : and it's not a ternary statement,
		        //   then we set space_before to false
		        space_before = !(this._output.just_added_newline() || isOtherColon);

		        this._output.space_before_token = space_before;
		        this.print_token(current_token);
		        this._output.space_before_token = true;
		        return;
		    }
		  }

		  if (isGeneratorAsterisk) {
		    this.allow_wrap_or_preserved_newline(current_token);
		    space_before = false;
		    var next_token = this._tokens.peek();
		    space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);
		  } else if (current_token.text === '...') {
		    this.allow_wrap_or_preserved_newline(current_token);
		    space_before = this._flags.last_token.type === TOKEN.START_BLOCK;
		    space_after = false;
		  } else if (in_array(current_token.text, ['--', '++', '!', '~']) || isUnary) {
		    // unary operators (and binary +/- pretending to be unary) special cases
		    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {
		      this.allow_wrap_or_preserved_newline(current_token);
		    }

		    space_before = false;
		    space_after = false;

		    // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
		    // if there is a newline between -- or ++ and anything else we should preserve it.
		    if (current_token.newlines && (current_token.text === '--' || current_token.text === '++' || current_token.text === '~')) {
		      var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;
		      if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {
		        this.restore_mode();
		      }
		      this.print_newline(new_line_needed, true);
		    }

		    if (this._flags.last_token.text === ';' && is_expression(this._flags.mode)) {
		      // for (;; ++i)
		      //        ^^^
		      space_before = true;
		    }

		    if (this._flags.last_token.type === TOKEN.RESERVED) {
		      space_before = true;
		    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
		      space_before = !(this._flags.last_token.text === ']' && (current_token.text === '--' || current_token.text === '++'));
		    } else if (this._flags.last_token.type === TOKEN.OPERATOR) {
		      // a++ + ++b;
		      // a - -b
		      space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(this._flags.last_token.text, ['--', '-', '++', '+']);
		      // + and - are not unary when preceeded by -- or ++ operator
		      // a-- + b
		      // a * +b
		      // a - -b
		      if (in_array(current_token.text, ['+', '-']) && in_array(this._flags.last_token.text, ['--', '++'])) {
		        space_after = true;
		      }
		    }


		    if (((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame) || this._flags.mode === MODE.Statement) &&
		      (this._flags.last_token.text === '{' || this._flags.last_token.text === ';')) {
		      // { foo; --i }
		      // foo(); --bar;
		      this.print_newline();
		    }
		  }

		  this._output.space_before_token = this._output.space_before_token || space_before;
		  this.print_token(current_token);
		  this._output.space_before_token = space_after;
		};

		Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
		  if (this._output.raw) {
		    this._output.add_raw_token(current_token);
		    if (current_token.directives && current_token.directives.preserve === 'end') {
		      // If we're testing the raw output behavior, do not allow a directive to turn it off.
		      this._output.raw = this._options.test_output_raw;
		    }
		    return;
		  }

		  if (current_token.directives) {
		    this.print_newline(false, preserve_statement_flags);
		    this.print_token(current_token);
		    if (current_token.directives.preserve === 'start') {
		      this._output.raw = true;
		    }
		    this.print_newline(false, true);
		    return;
		  }

		  // inline block
		  if (!acorn.newline.test(current_token.text) && !current_token.newlines) {
		    this._output.space_before_token = true;
		    this.print_token(current_token);
		    this._output.space_before_token = true;
		    return;
		  } else {
		    this.print_block_commment(current_token, preserve_statement_flags);
		  }
		};

		Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
		  var lines = split_linebreaks(current_token.text);
		  var j; // iterator for this case
		  var javadoc = false;
		  var starless = false;
		  var lastIndent = current_token.whitespace_before;
		  var lastIndentLength = lastIndent.length;

		  // block comment starts with a new line
		  this.print_newline(false, preserve_statement_flags);

		  // first line always indented
		  this.print_token_line_indentation(current_token);
		  this._output.add_token(lines[0]);
		  this.print_newline(false, preserve_statement_flags);


		  if (lines.length > 1) {
		    lines = lines.slice(1);
		    javadoc = all_lines_start_with(lines, '*');
		    starless = each_line_matches_indent(lines, lastIndent);

		    if (javadoc) {
		      this._flags.alignment = 1;
		    }

		    for (j = 0; j < lines.length; j++) {
		      if (javadoc) {
		        // javadoc: reformat and re-indent
		        this.print_token_line_indentation(current_token);
		        this._output.add_token(ltrim(lines[j]));
		      } else if (starless && lines[j]) {
		        // starless: re-indent non-empty content, avoiding trim
		        this.print_token_line_indentation(current_token);
		        this._output.add_token(lines[j].substring(lastIndentLength));
		      } else {
		        // normal comments output raw
		        this._output.current_line.set_indent(-1);
		        this._output.add_token(lines[j]);
		      }

		      // for comments on their own line or  more than one line, make sure there's a new line after
		      this.print_newline(false, preserve_statement_flags);
		    }

		    this._flags.alignment = 0;
		  }
		};


		Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
		  if (current_token.newlines) {
		    this.print_newline(false, preserve_statement_flags);
		  } else {
		    this._output.trim(true);
		  }

		  this._output.space_before_token = true;
		  this.print_token(current_token);
		  this.print_newline(false, preserve_statement_flags);
		};

		Beautifier.prototype.handle_dot = function(current_token) {
		  if (this.start_of_statement(current_token)) ; else {
		    this.handle_whitespace_and_comments(current_token, true);
		  }

		  if (this._flags.last_token.text.match('^[0-9]+$')) {
		    this._output.space_before_token = true;
		  }

		  if (reserved_array(this._flags.last_token, special_words)) {
		    this._output.space_before_token = false;
		  } else {
		    // allow preserved newlines before dots in general
		    // force newlines on dots after close paren when break_chained - for bar().baz()
		    this.allow_wrap_or_preserved_newline(current_token,
		      this._flags.last_token.text === ')' && this._options.break_chained_methods);
		  }

		  // Only unindent chained method dot if this dot starts a new line.
		  // Otherwise the automatic extra indentation removal will handle the over indent
		  if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
		    this.deindent();
		  }

		  this.print_token(current_token);
		};

		Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
		  this.print_token(current_token);

		  if (current_token.text[current_token.text.length - 1] === '\n') {
		    this.print_newline(false, preserve_statement_flags);
		  }
		};

		Beautifier.prototype.handle_eof = function(current_token) {
		  // Unwind any open statements
		  while (this._flags.mode === MODE.Statement) {
		    this.restore_mode();
		  }
		  this.handle_whitespace_and_comments(current_token);
		};

		beautifier$2.Beautifier = Beautifier;
		return beautifier$2;
	}

	/*jshint node:true */

	var hasRequiredJavascript;

	function requireJavascript () {
		if (hasRequiredJavascript) return javascript.exports;
		hasRequiredJavascript = 1;

		var Beautifier = requireBeautifier$2().Beautifier,
		  Options = requireOptions$2().Options;

		function js_beautify(js_source_text, options) {
		  var beautifier = new Beautifier(js_source_text, options);
		  return beautifier.beautify();
		}

		javascript.exports = js_beautify;
		javascript.exports.defaultOptions = function() {
		  return new Options();
		};
		return javascript.exports;
	}

	var css = {exports: {}};

	var beautifier$1 = {};

	var options$1 = {};

	/*jshint node:true */

	var hasRequiredOptions$1;

	function requireOptions$1 () {
		if (hasRequiredOptions$1) return options$1;
		hasRequiredOptions$1 = 1;

		var BaseOptions = requireOptions$3().Options;

		function Options(options) {
		  BaseOptions.call(this, options, 'css');

		  this.selector_separator_newline = this._get_boolean('selector_separator_newline', true);
		  this.newline_between_rules = this._get_boolean('newline_between_rules', true);
		  var space_around_selector_separator = this._get_boolean('space_around_selector_separator');
		  this.space_around_combinator = this._get_boolean('space_around_combinator') || space_around_selector_separator;

		  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);
		  this.brace_style = 'collapse';
		  for (var bs = 0; bs < brace_style_split.length; bs++) {
		    if (brace_style_split[bs] !== 'expand') {
		      // default to collapse, as only collapse|expand is implemented for now
		      this.brace_style = 'collapse';
		    } else {
		      this.brace_style = brace_style_split[bs];
		    }
		  }
		}
		Options.prototype = new BaseOptions();



		options$1.Options = Options;
		return options$1;
	}

	/*jshint node:true */

	var hasRequiredBeautifier$1;

	function requireBeautifier$1 () {
		if (hasRequiredBeautifier$1) return beautifier$1;
		hasRequiredBeautifier$1 = 1;

		var Options = requireOptions$1().Options;
		var Output = requireOutput().Output;
		var InputScanner = requireInputscanner().InputScanner;
		var Directives = requireDirectives().Directives;

		var directives_core = new Directives(/\/\*/, /\*\//);

		var lineBreak = /\r\n|[\r\n]/;
		var allLineBreaks = /\r\n|[\r\n]/g;

		// tokenizer
		var whitespaceChar = /\s/;
		var whitespacePattern = /(?:\s|\n)+/g;
		var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
		var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;

		function Beautifier(source_text, options) {
		  this._source_text = source_text || '';
		  // Allow the setting of language/file-type specific options
		  // with inheritance of overall settings
		  this._options = new Options(options);
		  this._ch = null;
		  this._input = null;

		  // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
		  this.NESTED_AT_RULE = {
		    "page": true,
		    "font-face": true,
		    "keyframes": true,
		    // also in CONDITIONAL_GROUP_RULE below
		    "media": true,
		    "supports": true,
		    "document": true
		  };
		  this.CONDITIONAL_GROUP_RULE = {
		    "media": true,
		    "supports": true,
		    "document": true
		  };
		  this.NON_SEMICOLON_NEWLINE_PROPERTY = [
		    "grid-template-areas",
		    "grid-template"
		  ];

		}

		Beautifier.prototype.eatString = function(endChars) {
		  var result = '';
		  this._ch = this._input.next();
		  while (this._ch) {
		    result += this._ch;
		    if (this._ch === "\\") {
		      result += this._input.next();
		    } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
		      break;
		    }
		    this._ch = this._input.next();
		  }
		  return result;
		};

		// Skips any white space in the source text from the current position.
		// When allowAtLeastOneNewLine is true, will output new lines for each
		// newline character found; if the user has preserve_newlines off, only
		// the first newline will be output
		Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
		  var result = whitespaceChar.test(this._input.peek());
		  var newline_count = 0;
		  while (whitespaceChar.test(this._input.peek())) {
		    this._ch = this._input.next();
		    if (allowAtLeastOneNewLine && this._ch === '\n') {
		      if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
		        newline_count++;
		        this._output.add_new_line(true);
		      }
		    }
		  }
		  return result;
		};

		// Nested pseudo-class if we are insideRule
		// and the next special character found opens
		// a new block
		Beautifier.prototype.foundNestedPseudoClass = function() {
		  var openParen = 0;
		  var i = 1;
		  var ch = this._input.peek(i);
		  while (ch) {
		    if (ch === "{") {
		      return true;
		    } else if (ch === '(') {
		      // pseudoclasses can contain ()
		      openParen += 1;
		    } else if (ch === ')') {
		      if (openParen === 0) {
		        return false;
		      }
		      openParen -= 1;
		    } else if (ch === ";" || ch === "}") {
		      return false;
		    }
		    i++;
		    ch = this._input.peek(i);
		  }
		  return false;
		};

		Beautifier.prototype.print_string = function(output_string) {
		  this._output.set_indent(this._indentLevel);
		  this._output.non_breaking_space = true;
		  this._output.add_token(output_string);
		};

		Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
		  if (isAfterSpace) {
		    this._output.space_before_token = true;
		  }
		};

		Beautifier.prototype.indent = function() {
		  this._indentLevel++;
		};

		Beautifier.prototype.outdent = function() {
		  if (this._indentLevel > 0) {
		    this._indentLevel--;
		  }
		};

		/*_____________________--------------------_____________________*/

		Beautifier.prototype.beautify = function() {
		  if (this._options.disabled) {
		    return this._source_text;
		  }

		  var source_text = this._source_text;
		  var eol = this._options.eol;
		  if (eol === 'auto') {
		    eol = '\n';
		    if (source_text && lineBreak.test(source_text || '')) {
		      eol = source_text.match(lineBreak)[0];
		    }
		  }


		  // HACK: newline parsing inconsistent. This brute force normalizes the this._input.
		  source_text = source_text.replace(allLineBreaks, '\n');

		  // reset
		  var baseIndentString = source_text.match(/^[\t ]*/)[0];

		  this._output = new Output(this._options, baseIndentString);
		  this._input = new InputScanner(source_text);
		  this._indentLevel = 0;
		  this._nestedLevel = 0;

		  this._ch = null;
		  var parenLevel = 0;

		  var insideRule = false;
		  // This is the value side of a property value pair (blue in the following ex)
		  // label { content: blue }
		  var insidePropertyValue = false;
		  var enteringConditionalGroup = false;
		  var insideNonNestedAtRule = false;
		  var insideScssMap = false;
		  var topCharacter = this._ch;
		  var insideNonSemiColonValues = false;
		  var whitespace;
		  var isAfterSpace;
		  var previous_ch;

		  while (true) {
		    whitespace = this._input.read(whitespacePattern);
		    isAfterSpace = whitespace !== '';
		    previous_ch = topCharacter;
		    this._ch = this._input.next();
		    if (this._ch === '\\' && this._input.hasNext()) {
		      this._ch += this._input.next();
		    }
		    topCharacter = this._ch;

		    if (!this._ch) {
		      break;
		    } else if (this._ch === '/' && this._input.peek() === '*') {
		      // /* css comment */
		      // Always start block comments on a new line.
		      // This handles scenarios where a block comment immediately
		      // follows a property definition on the same line or where
		      // minified code is being beautified.
		      this._output.add_new_line();
		      this._input.back();

		      var comment = this._input.read(block_comment_pattern);

		      // Handle ignore directive
		      var directives = directives_core.get_directives(comment);
		      if (directives && directives.ignore === 'start') {
		        comment += directives_core.readIgnored(this._input);
		      }

		      this.print_string(comment);

		      // Ensures any new lines following the comment are preserved
		      this.eatWhitespace(true);

		      // Block comments are followed by a new line so they don't
		      // share a line with other properties
		      this._output.add_new_line();
		    } else if (this._ch === '/' && this._input.peek() === '/') {
		      // // single line comment
		      // Preserves the space before a comment
		      // on the same line as a rule
		      this._output.space_before_token = true;
		      this._input.back();
		      this.print_string(this._input.read(comment_pattern));

		      // Ensures any new lines following the comment are preserved
		      this.eatWhitespace(true);
		    } else if (this._ch === '$') {
		      this.preserveSingleSpace(isAfterSpace);

		      this.print_string(this._ch);

		      // strip trailing space, if present, for hash property checks
		      var variable = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);

		      if (variable.match(/[ :]$/)) {
		        // we have a variable or pseudo-class, add it and insert one space before continuing
		        variable = this.eatString(": ").replace(/\s+$/, '');
		        this.print_string(variable);
		        this._output.space_before_token = true;
		      }

		      // might be sass variable
		      if (parenLevel === 0 && variable.indexOf(':') !== -1) {
		        insidePropertyValue = true;
		        this.indent();
		      }
		    } else if (this._ch === '@') {
		      this.preserveSingleSpace(isAfterSpace);

		      // deal with less property mixins @{...}
		      if (this._input.peek() === '{') {
		        this.print_string(this._ch + this.eatString('}'));
		      } else {
		        this.print_string(this._ch);

		        // strip trailing space, if present, for hash property checks
		        var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);

		        if (variableOrRule.match(/[ :]$/)) {
		          // we have a variable or pseudo-class, add it and insert one space before continuing
		          variableOrRule = this.eatString(": ").replace(/\s+$/, '');
		          this.print_string(variableOrRule);
		          this._output.space_before_token = true;
		        }

		        // might be less variable
		        if (parenLevel === 0 && variableOrRule.indexOf(':') !== -1) {
		          insidePropertyValue = true;
		          this.indent();

		          // might be a nesting at-rule
		        } else if (variableOrRule in this.NESTED_AT_RULE) {
		          this._nestedLevel += 1;
		          if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
		            enteringConditionalGroup = true;
		          }

		          // might be a non-nested at-rule
		        } else if (parenLevel === 0 && !insidePropertyValue) {
		          insideNonNestedAtRule = true;
		        }
		      }
		    } else if (this._ch === '#' && this._input.peek() === '{') {
		      this.preserveSingleSpace(isAfterSpace);
		      this.print_string(this._ch + this.eatString('}'));
		    } else if (this._ch === '{') {
		      if (insidePropertyValue) {
		        insidePropertyValue = false;
		        this.outdent();
		      }

		      // non nested at rule becomes nested
		      insideNonNestedAtRule = false;

		      // when entering conditional groups, only rulesets are allowed
		      if (enteringConditionalGroup) {
		        enteringConditionalGroup = false;
		        insideRule = (this._indentLevel >= this._nestedLevel);
		      } else {
		        // otherwise, declarations are also allowed
		        insideRule = (this._indentLevel >= this._nestedLevel - 1);
		      }
		      if (this._options.newline_between_rules && insideRule) {
		        if (this._output.previous_line && this._output.previous_line.item(-1) !== '{') {
		          this._output.ensure_empty_line_above('/', ',');
		        }
		      }

		      this._output.space_before_token = true;

		      // The difference in print_string and indent order is necessary to indent the '{' correctly
		      if (this._options.brace_style === 'expand') {
		        this._output.add_new_line();
		        this.print_string(this._ch);
		        this.indent();
		        this._output.set_indent(this._indentLevel);
		      } else {
		        // inside mixin and first param is object
		        if (previous_ch === '(') {
		          this._output.space_before_token = false;
		        } else if (previous_ch !== ',') {
		          this.indent();
		        }
		        this.print_string(this._ch);
		      }

		      this.eatWhitespace(true);
		      this._output.add_new_line();
		    } else if (this._ch === '}') {
		      this.outdent();
		      this._output.add_new_line();
		      if (previous_ch === '{') {
		        this._output.trim(true);
		      }

		      if (insidePropertyValue) {
		        this.outdent();
		        insidePropertyValue = false;
		      }
		      this.print_string(this._ch);
		      insideRule = false;
		      if (this._nestedLevel) {
		        this._nestedLevel--;
		      }

		      this.eatWhitespace(true);
		      this._output.add_new_line();

		      if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
		        if (this._input.peek() !== '}') {
		          this._output.add_new_line(true);
		        }
		      }
		      if (this._input.peek() === ')') {
		        this._output.trim(true);
		        if (this._options.brace_style === "expand") {
		          this._output.add_new_line(true);
		        }
		      }
		    } else if (this._ch === ":") {

		      for (var i = 0; i < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i++) {
		        if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i])) {
		          insideNonSemiColonValues = true;
		          break;
		        }
		      }

		      if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideNonNestedAtRule && parenLevel === 0) {
		        // 'property: value' delimiter
		        // which could be in a conditional group query

		        this.print_string(':');
		        if (!insidePropertyValue) {
		          insidePropertyValue = true;
		          this._output.space_before_token = true;
		          this.eatWhitespace(true);
		          this.indent();
		        }
		      } else {
		        // sass/less parent reference don't use a space
		        // sass nested pseudo-class don't use a space

		        // preserve space before pseudoclasses/pseudoelements, as it means "in any child"
		        if (this._input.lookBack(" ")) {
		          this._output.space_before_token = true;
		        }
		        if (this._input.peek() === ":") {
		          // pseudo-element
		          this._ch = this._input.next();
		          this.print_string("::");
		        } else {
		          // pseudo-class
		          this.print_string(':');
		        }
		      }
		    } else if (this._ch === '"' || this._ch === '\'') {
		      var preserveQuoteSpace = previous_ch === '"' || previous_ch === '\'';
		      this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);
		      this.print_string(this._ch + this.eatString(this._ch));
		      this.eatWhitespace(true);
		    } else if (this._ch === ';') {
		      insideNonSemiColonValues = false;
		      if (parenLevel === 0) {
		        if (insidePropertyValue) {
		          this.outdent();
		          insidePropertyValue = false;
		        }
		        insideNonNestedAtRule = false;
		        this.print_string(this._ch);
		        this.eatWhitespace(true);

		        // This maintains single line comments on the same
		        // line. Block comments are also affected, but
		        // a new line is always output before one inside
		        // that section
		        if (this._input.peek() !== '/') {
		          this._output.add_new_line();
		        }
		      } else {
		        this.print_string(this._ch);
		        this.eatWhitespace(true);
		        this._output.space_before_token = true;
		      }
		    } else if (this._ch === '(') { // may be a url
		      if (this._input.lookBack("url")) {
		        this.print_string(this._ch);
		        this.eatWhitespace();
		        parenLevel++;
		        this.indent();
		        this._ch = this._input.next();
		        if (this._ch === ')' || this._ch === '"' || this._ch === '\'') {
		          this._input.back();
		        } else if (this._ch) {
		          this.print_string(this._ch + this.eatString(')'));
		          if (parenLevel) {
		            parenLevel--;
		            this.outdent();
		          }
		        }
		      } else {
		        var space_needed = false;
		        if (this._input.lookBack("with")) {
		          // look back is not an accurate solution, we need tokens to confirm without whitespaces
		          space_needed = true;
		        }
		        this.preserveSingleSpace(isAfterSpace || space_needed);
		        this.print_string(this._ch);

		        // handle scss/sass map
		        if (insidePropertyValue && previous_ch === "$" && this._options.selector_separator_newline) {
		          this._output.add_new_line();
		          insideScssMap = true;
		        } else {
		          this.eatWhitespace();
		          parenLevel++;
		          this.indent();
		        }
		      }
		    } else if (this._ch === ')') {
		      if (parenLevel) {
		        parenLevel--;
		        this.outdent();
		      }
		      if (insideScssMap && this._input.peek() === ";" && this._options.selector_separator_newline) {
		        insideScssMap = false;
		        this.outdent();
		        this._output.add_new_line();
		      }
		      this.print_string(this._ch);
		    } else if (this._ch === ',') {
		      this.print_string(this._ch);
		      this.eatWhitespace(true);
		      if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideNonNestedAtRule) {
		        this._output.add_new_line();
		      } else {
		        this._output.space_before_token = true;
		      }
		    } else if ((this._ch === '>' || this._ch === '+' || this._ch === '~') && !insidePropertyValue && parenLevel === 0) {
		      //handle combinator spacing
		      if (this._options.space_around_combinator) {
		        this._output.space_before_token = true;
		        this.print_string(this._ch);
		        this._output.space_before_token = true;
		      } else {
		        this.print_string(this._ch);
		        this.eatWhitespace();
		        // squash extra whitespace
		        if (this._ch && whitespaceChar.test(this._ch)) {
		          this._ch = '';
		        }
		      }
		    } else if (this._ch === ']') {
		      this.print_string(this._ch);
		    } else if (this._ch === '[') {
		      this.preserveSingleSpace(isAfterSpace);
		      this.print_string(this._ch);
		    } else if (this._ch === '=') { // no whitespace before or after
		      this.eatWhitespace();
		      this.print_string('=');
		      if (whitespaceChar.test(this._ch)) {
		        this._ch = '';
		      }
		    } else if (this._ch === '!' && !this._input.lookBack("\\")) { // !important
		      this._output.space_before_token = true;
		      this.print_string(this._ch);
		    } else {
		      var preserveAfterSpace = previous_ch === '"' || previous_ch === '\'';
		      this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);
		      this.print_string(this._ch);

		      if (!this._output.just_added_newline() && this._input.peek() === '\n' && insideNonSemiColonValues) {
		        this._output.add_new_line();
		      }
		    }
		  }

		  var sweetCode = this._output.get_code(eol);

		  return sweetCode;
		};

		beautifier$1.Beautifier = Beautifier;
		return beautifier$1;
	}

	/*jshint node:true */

	var hasRequiredCss;

	function requireCss () {
		if (hasRequiredCss) return css.exports;
		hasRequiredCss = 1;

		var Beautifier = requireBeautifier$1().Beautifier,
		  Options = requireOptions$1().Options;

		function css_beautify(source_text, options) {
		  var beautifier = new Beautifier(source_text, options);
		  return beautifier.beautify();
		}

		css.exports = css_beautify;
		css.exports.defaultOptions = function() {
		  return new Options();
		};
		return css.exports;
	}

	var html = {exports: {}};

	var beautifier = {};

	var options = {};

	/*jshint node:true */

	var hasRequiredOptions;

	function requireOptions () {
		if (hasRequiredOptions) return options;
		hasRequiredOptions = 1;

		var BaseOptions = requireOptions$3().Options;

		function Options(options) {
		  BaseOptions.call(this, options, 'html');
		  if (this.templating.length === 1 && this.templating[0] === 'auto') {
		    this.templating = ['django', 'erb', 'handlebars', 'php'];
		  }

		  this.indent_inner_html = this._get_boolean('indent_inner_html');
		  this.indent_body_inner_html = this._get_boolean('indent_body_inner_html', true);
		  this.indent_head_inner_html = this._get_boolean('indent_head_inner_html', true);

		  this.indent_handlebars = this._get_boolean('indent_handlebars', true);
		  this.wrap_attributes = this._get_selection('wrap_attributes',
		    ['auto', 'force', 'force-aligned', 'force-expand-multiline', 'aligned-multiple', 'preserve', 'preserve-aligned']);
		  this.wrap_attributes_min_attrs = this._get_number('wrap_attributes_min_attrs', 2);
		  this.wrap_attributes_indent_size = this._get_number('wrap_attributes_indent_size', this.indent_size);
		  this.extra_liners = this._get_array('extra_liners', ['head', 'body', '/html']);

		  // Block vs inline elements
		  // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements
		  // https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements
		  // https://www.w3.org/TR/html5/dom.html#phrasing-content
		  this.inline = this._get_array('inline', [
		    'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',
		    'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',
		    'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',
		    'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',
		    'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',
		    'video', 'wbr', 'text',
		    // obsolete inline tags
		    'acronym', 'big', 'strike', 'tt'
		  ]);
		  this.inline_custom_elements = this._get_boolean('inline_custom_elements', true);
		  this.void_elements = this._get_array('void_elements', [
		    // HTLM void elements - aka self-closing tags - aka singletons
		    // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
		    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',
		    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',
		    // NOTE: Optional tags are too complex for a simple list
		    // they are hard coded in _do_optional_end_element

		    // Doctype and xml elements
		    '!doctype', '?xml',

		    // obsolete tags
		    // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm
		    // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex
		    'basefont', 'isindex'
		  ]);
		  this.unformatted = this._get_array('unformatted', []);
		  this.content_unformatted = this._get_array('content_unformatted', [
		    'pre', 'textarea'
		  ]);
		  this.unformatted_content_delimiter = this._get_characters('unformatted_content_delimiter');
		  this.indent_scripts = this._get_selection('indent_scripts', ['normal', 'keep', 'separate']);

		}
		Options.prototype = new BaseOptions();



		options.Options = Options;
		return options;
	}

	var tokenizer = {};

	/*jshint node:true */

	var hasRequiredTokenizer;

	function requireTokenizer () {
		if (hasRequiredTokenizer) return tokenizer;
		hasRequiredTokenizer = 1;

		var BaseTokenizer = requireTokenizer$2().Tokenizer;
		var BASETOKEN = requireTokenizer$2().TOKEN;
		var Directives = requireDirectives().Directives;
		var TemplatablePattern = requireTemplatablepattern().TemplatablePattern;
		var Pattern = requirePattern().Pattern;

		var TOKEN = {
		  TAG_OPEN: 'TK_TAG_OPEN',
		  TAG_CLOSE: 'TK_TAG_CLOSE',
		  CONTROL_FLOW_OPEN: 'TK_CONTROL_FLOW_OPEN',
		  CONTROL_FLOW_CLOSE: 'TK_CONTROL_FLOW_CLOSE',
		  ATTRIBUTE: 'TK_ATTRIBUTE',
		  EQUALS: 'TK_EQUALS',
		  VALUE: 'TK_VALUE',
		  COMMENT: 'TK_COMMENT',
		  TEXT: 'TK_TEXT',
		  UNKNOWN: 'TK_UNKNOWN',
		  START: BASETOKEN.START,
		  RAW: BASETOKEN.RAW,
		  EOF: BASETOKEN.EOF
		};

		var directives_core = new Directives(/<\!--/, /-->/);

		var Tokenizer = function(input_string, options) {
		  BaseTokenizer.call(this, input_string, options);
		  this._current_tag_name = '';

		  // Words end at whitespace or when a tag starts
		  // if we are indenting handlebars, they are considered tags
		  var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
		  var pattern_reader = new Pattern(this._input);

		  this.__patterns = {
		    word: templatable_reader.until(/[\n\r\t <]/),
		    word_control_flow_close_excluded: templatable_reader.until(/[\n\r\t <}]/),
		    single_quote: templatable_reader.until_after(/'/),
		    double_quote: templatable_reader.until_after(/"/),
		    attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
		    element_name: templatable_reader.until(/[\n\r\t >\/]/),

		    angular_control_flow_start: pattern_reader.matching(/\@[a-zA-Z]+[^({]*[({]/),
		    handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
		    handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
		    handlebars_open: pattern_reader.until(/[\n\r\t }]/),
		    handlebars_raw_close: pattern_reader.until(/}}/),
		    comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
		    cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
		    // https://en.wikipedia.org/wiki/Conditional_comment
		    conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
		    processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
		  };

		  if (this._options.indent_handlebars) {
		    this.__patterns.word = this.__patterns.word.exclude('handlebars');
		    this.__patterns.word_control_flow_close_excluded = this.__patterns.word_control_flow_close_excluded.exclude('handlebars');
		  }

		  this._unformatted_content_delimiter = null;

		  if (this._options.unformatted_content_delimiter) {
		    var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
		    this.__patterns.unformatted_content_delimiter =
		      pattern_reader.matching(literal_regexp)
		      .until_after(literal_regexp);
		  }
		};
		Tokenizer.prototype = new BaseTokenizer();

		Tokenizer.prototype._is_comment = function(current_token) { // jshint unused:false
		  return false; //current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.UNKNOWN;
		};

		Tokenizer.prototype._is_opening = function(current_token) {
		  return current_token.type === TOKEN.TAG_OPEN || current_token.type === TOKEN.CONTROL_FLOW_OPEN;
		};

		Tokenizer.prototype._is_closing = function(current_token, open_token) {
		  return (current_token.type === TOKEN.TAG_CLOSE &&
		    (open_token && (
		      ((current_token.text === '>' || current_token.text === '/>') && open_token.text[0] === '<') ||
		      (current_token.text === '}}' && open_token.text[0] === '{' && open_token.text[1] === '{')))
		  ) || (current_token.type === TOKEN.CONTROL_FLOW_CLOSE &&
		    (current_token.text === '}' && open_token.text.endsWith('{')));
		};

		Tokenizer.prototype._reset = function() {
		  this._current_tag_name = '';
		};

		Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
		  var token = null;
		  this._readWhitespace();
		  var c = this._input.peek();

		  if (c === null) {
		    return this._create_token(TOKEN.EOF, '');
		  }

		  token = token || this._read_open_handlebars(c, open_token);
		  token = token || this._read_attribute(c, previous_token, open_token);
		  token = token || this._read_close(c, open_token);
		  token = token || this._read_script_and_style(c, previous_token);
		  token = token || this._read_control_flows(c, open_token);
		  token = token || this._read_raw_content(c, previous_token, open_token);
		  token = token || this._read_content_word(c, open_token);
		  token = token || this._read_comment_or_cdata(c);
		  token = token || this._read_processing(c);
		  token = token || this._read_open(c, open_token);
		  token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());

		  return token;
		};

		Tokenizer.prototype._read_comment_or_cdata = function(c) { // jshint unused:false
		  var token = null;
		  var resulting_string = null;
		  var directives = null;

		  if (c === '<') {
		    var peek1 = this._input.peek(1);
		    // We treat all comments as literals, even more than preformatted tags
		    // we only look for the appropriate closing marker
		    if (peek1 === '!') {
		      resulting_string = this.__patterns.comment.read();

		      // only process directive on html comments
		      if (resulting_string) {
		        directives = directives_core.get_directives(resulting_string);
		        if (directives && directives.ignore === 'start') {
		          resulting_string += directives_core.readIgnored(this._input);
		        }
		      } else {
		        resulting_string = this.__patterns.cdata.read();
		      }
		    }

		    if (resulting_string) {
		      token = this._create_token(TOKEN.COMMENT, resulting_string);
		      token.directives = directives;
		    }
		  }

		  return token;
		};

		Tokenizer.prototype._read_processing = function(c) { // jshint unused:false
		  var token = null;
		  var resulting_string = null;
		  var directives = null;

		  if (c === '<') {
		    var peek1 = this._input.peek(1);
		    if (peek1 === '!' || peek1 === '?') {
		      resulting_string = this.__patterns.conditional_comment.read();
		      resulting_string = resulting_string || this.__patterns.processing.read();
		    }

		    if (resulting_string) {
		      token = this._create_token(TOKEN.COMMENT, resulting_string);
		      token.directives = directives;
		    }
		  }

		  return token;
		};

		Tokenizer.prototype._read_open = function(c, open_token) {
		  var resulting_string = null;
		  var token = null;
		  if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
		    if (c === '<') {

		      resulting_string = this._input.next();
		      if (this._input.peek() === '/') {
		        resulting_string += this._input.next();
		      }
		      resulting_string += this.__patterns.element_name.read();
		      token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
		    }
		  }
		  return token;
		};

		Tokenizer.prototype._read_open_handlebars = function(c, open_token) {
		  var resulting_string = null;
		  var token = null;
		  if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
		    if ((this._options.templating.includes('angular') || this._options.indent_handlebars) && c === '{' && this._input.peek(1) === '{') {
		      if (this._options.indent_handlebars && this._input.peek(2) === '!') {
		        resulting_string = this.__patterns.handlebars_comment.read();
		        resulting_string = resulting_string || this.__patterns.handlebars.read();
		        token = this._create_token(TOKEN.COMMENT, resulting_string);
		      } else {
		        resulting_string = this.__patterns.handlebars_open.read();
		        token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
		      }
		    }
		  }
		  return token;
		};

		Tokenizer.prototype._read_control_flows = function(c, open_token) {
		  var resulting_string = '';
		  var token = null;
		  // Only check for control flows if angular templating is set
		  if (!this._options.templating.includes('angular')) {
		    return token;
		  }

		  if (c === '@') {
		    resulting_string = this.__patterns.angular_control_flow_start.read();
		    if (resulting_string === '') {
		      return token;
		    }

		    var opening_parentheses_count = resulting_string.endsWith('(') ? 1 : 0;
		    var closing_parentheses_count = 0;
		    // The opening brace of the control flow is where the number of opening and closing parentheses equal
		    // e.g. @if({value: true} !== null) { 
		    while (!(resulting_string.endsWith('{') && opening_parentheses_count === closing_parentheses_count)) {
		      var next_char = this._input.next();
		      if (next_char === null) {
		        break;
		      } else if (next_char === '(') {
		        opening_parentheses_count++;
		      } else if (next_char === ')') {
		        closing_parentheses_count++;
		      }
		      resulting_string += next_char;
		    }
		    token = this._create_token(TOKEN.CONTROL_FLOW_OPEN, resulting_string);
		  } else if (c === '}' && open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
		    resulting_string = this._input.next();
		    token = this._create_token(TOKEN.CONTROL_FLOW_CLOSE, resulting_string);
		  }
		  return token;
		};


		Tokenizer.prototype._read_close = function(c, open_token) {
		  var resulting_string = null;
		  var token = null;
		  if (open_token && open_token.type === TOKEN.TAG_OPEN) {
		    if (open_token.text[0] === '<' && (c === '>' || (c === '/' && this._input.peek(1) === '>'))) {
		      resulting_string = this._input.next();
		      if (c === '/') { //  for close tag "/>"
		        resulting_string += this._input.next();
		      }
		      token = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
		    } else if (open_token.text[0] === '{' && c === '}' && this._input.peek(1) === '}') {
		      this._input.next();
		      this._input.next();
		      token = this._create_token(TOKEN.TAG_CLOSE, '}}');
		    }
		  }

		  return token;
		};

		Tokenizer.prototype._read_attribute = function(c, previous_token, open_token) {
		  var token = null;
		  var resulting_string = '';
		  if (open_token && open_token.text[0] === '<') {

		    if (c === '=') {
		      token = this._create_token(TOKEN.EQUALS, this._input.next());
		    } else if (c === '"' || c === "'") {
		      var content = this._input.next();
		      if (c === '"') {
		        content += this.__patterns.double_quote.read();
		      } else {
		        content += this.__patterns.single_quote.read();
		      }
		      token = this._create_token(TOKEN.VALUE, content);
		    } else {
		      resulting_string = this.__patterns.attribute.read();

		      if (resulting_string) {
		        if (previous_token.type === TOKEN.EQUALS) {
		          token = this._create_token(TOKEN.VALUE, resulting_string);
		        } else {
		          token = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
		        }
		      }
		    }
		  }
		  return token;
		};

		Tokenizer.prototype._is_content_unformatted = function(tag_name) {
		  // void_elements have no content and so cannot have unformatted content
		  // script and style tags should always be read as unformatted content
		  // finally content_unformatted and unformatted element contents are unformatted
		  return this._options.void_elements.indexOf(tag_name) === -1 &&
		    (this._options.content_unformatted.indexOf(tag_name) !== -1 ||
		      this._options.unformatted.indexOf(tag_name) !== -1);
		};

		Tokenizer.prototype._read_raw_content = function(c, previous_token, open_token) { // jshint unused:false
		  var resulting_string = '';
		  if (open_token && open_token.text[0] === '{') {
		    resulting_string = this.__patterns.handlebars_raw_close.read();
		  } else if (previous_token.type === TOKEN.TAG_CLOSE &&
		    previous_token.opened.text[0] === '<' && previous_token.text[0] !== '/') {
		    // ^^ empty tag has no content 
		    var tag_name = previous_token.opened.text.substr(1).toLowerCase();
		    if (this._is_content_unformatted(tag_name)) {

		      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
		    }
		  }

		  if (resulting_string) {
		    return this._create_token(TOKEN.TEXT, resulting_string);
		  }

		  return null;
		};

		Tokenizer.prototype._read_script_and_style = function(c, previous_token) { // jshint unused:false 
		  if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === '<' && previous_token.text[0] !== '/') {
		    var tag_name = previous_token.opened.text.substr(1).toLowerCase();
		    if (tag_name === 'script' || tag_name === 'style') {
		      // Script and style tags are allowed to have comments wrapping their content
		      // or just have regular content.
		      var token = this._read_comment_or_cdata(c);
		      if (token) {
		        token.type = TOKEN.TEXT;
		        return token;
		      }
		      var resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
		      if (resulting_string) {
		        return this._create_token(TOKEN.TEXT, resulting_string);
		      }
		    }
		  }
		  return null;
		};

		Tokenizer.prototype._read_content_word = function(c, open_token) {
		  var resulting_string = '';
		  if (this._options.unformatted_content_delimiter) {
		    if (c === this._options.unformatted_content_delimiter[0]) {
		      resulting_string = this.__patterns.unformatted_content_delimiter.read();
		    }
		  }

		  if (!resulting_string) {
		    resulting_string = (open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN) ? this.__patterns.word_control_flow_close_excluded.read() : this.__patterns.word.read();
		  }
		  if (resulting_string) {
		    return this._create_token(TOKEN.TEXT, resulting_string);
		  }
		  return null;
		};

		tokenizer.Tokenizer = Tokenizer;
		tokenizer.TOKEN = TOKEN;
		return tokenizer;
	}

	/*jshint node:true */

	var hasRequiredBeautifier;

	function requireBeautifier () {
		if (hasRequiredBeautifier) return beautifier;
		hasRequiredBeautifier = 1;

		var Options = requireOptions().Options;
		var Output = requireOutput().Output;
		var Tokenizer = requireTokenizer().Tokenizer;
		var TOKEN = requireTokenizer().TOKEN;

		var lineBreak = /\r\n|[\r\n]/;
		var allLineBreaks = /\r\n|[\r\n]/g;

		var Printer = function(options, base_indent_string) { //handles input/output and some other printing functions

		  this.indent_level = 0;
		  this.alignment_size = 0;
		  this.max_preserve_newlines = options.max_preserve_newlines;
		  this.preserve_newlines = options.preserve_newlines;

		  this._output = new Output(options, base_indent_string);

		};

		Printer.prototype.current_line_has_match = function(pattern) {
		  return this._output.current_line.has_match(pattern);
		};

		Printer.prototype.set_space_before_token = function(value, non_breaking) {
		  this._output.space_before_token = value;
		  this._output.non_breaking_space = non_breaking;
		};

		Printer.prototype.set_wrap_point = function() {
		  this._output.set_indent(this.indent_level, this.alignment_size);
		  this._output.set_wrap_point();
		};


		Printer.prototype.add_raw_token = function(token) {
		  this._output.add_raw_token(token);
		};

		Printer.prototype.print_preserved_newlines = function(raw_token) {
		  var newlines = 0;
		  if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
		    newlines = raw_token.newlines ? 1 : 0;
		  }

		  if (this.preserve_newlines) {
		    newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
		  }
		  for (var n = 0; n < newlines; n++) {
		    this.print_newline(n > 0);
		  }

		  return newlines !== 0;
		};

		Printer.prototype.traverse_whitespace = function(raw_token) {
		  if (raw_token.whitespace_before || raw_token.newlines) {
		    if (!this.print_preserved_newlines(raw_token)) {
		      this._output.space_before_token = true;
		    }
		    return true;
		  }
		  return false;
		};

		Printer.prototype.previous_token_wrapped = function() {
		  return this._output.previous_token_wrapped;
		};

		Printer.prototype.print_newline = function(force) {
		  this._output.add_new_line(force);
		};

		Printer.prototype.print_token = function(token) {
		  if (token.text) {
		    this._output.set_indent(this.indent_level, this.alignment_size);
		    this._output.add_token(token.text);
		  }
		};

		Printer.prototype.indent = function() {
		  this.indent_level++;
		};

		Printer.prototype.deindent = function() {
		  if (this.indent_level > 0) {
		    this.indent_level--;
		    this._output.set_indent(this.indent_level, this.alignment_size);
		  }
		};

		Printer.prototype.get_full_indent = function(level) {
		  level = this.indent_level + (level || 0);
		  if (level < 1) {
		    return '';
		  }

		  return this._output.get_indent_string(level);
		};

		var get_type_attribute = function(start_token) {
		  var result = null;
		  var raw_token = start_token.next;

		  // Search attributes for a type attribute
		  while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
		    if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === 'type') {
		      if (raw_token.next && raw_token.next.type === TOKEN.EQUALS &&
		        raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
		        result = raw_token.next.next.text;
		      }
		      break;
		    }
		    raw_token = raw_token.next;
		  }

		  return result;
		};

		var get_custom_beautifier_name = function(tag_check, raw_token) {
		  var typeAttribute = null;
		  var result = null;

		  if (!raw_token.closed) {
		    return null;
		  }

		  if (tag_check === 'script') {
		    typeAttribute = 'text/javascript';
		  } else if (tag_check === 'style') {
		    typeAttribute = 'text/css';
		  }

		  typeAttribute = get_type_attribute(raw_token) || typeAttribute;

		  // For script and style tags that have a type attribute, only enable custom beautifiers for matching values
		  // For those without a type attribute use default;
		  if (typeAttribute.search('text/css') > -1) {
		    result = 'css';
		  } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
		    result = 'javascript';
		  } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
		    result = 'html';
		  } else if (typeAttribute.search(/test\/null/) > -1) {
		    // Test only mime-type for testing the beautifier when null is passed as beautifing function
		    result = 'null';
		  }

		  return result;
		};

		function in_array(what, arr) {
		  return arr.indexOf(what) !== -1;
		}

		function TagFrame(parent, parser_token, indent_level) {
		  this.parent = parent || null;
		  this.tag = parser_token ? parser_token.tag_name : '';
		  this.indent_level = indent_level || 0;
		  this.parser_token = parser_token || null;
		}

		function TagStack(printer) {
		  this._printer = printer;
		  this._current_frame = null;
		}

		TagStack.prototype.get_parser_token = function() {
		  return this._current_frame ? this._current_frame.parser_token : null;
		};

		TagStack.prototype.record_tag = function(parser_token) { //function to record a tag and its parent in this.tags Object
		  var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
		  this._current_frame = new_frame;
		};

		TagStack.prototype._try_pop_frame = function(frame) { //function to retrieve the opening tag to the corresponding closer
		  var parser_token = null;

		  if (frame) {
		    parser_token = frame.parser_token;
		    this._printer.indent_level = frame.indent_level;
		    this._current_frame = frame.parent;
		  }

		  return parser_token;
		};

		TagStack.prototype._get_frame = function(tag_list, stop_list) { //function to retrieve the opening tag to the corresponding closer
		  var frame = this._current_frame;

		  while (frame) { //till we reach '' (the initial value);
		    if (tag_list.indexOf(frame.tag) !== -1) { //if this is it use it
		      break;
		    } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
		      frame = null;
		      break;
		    }
		    frame = frame.parent;
		  }

		  return frame;
		};

		TagStack.prototype.try_pop = function(tag, stop_list) { //function to retrieve the opening tag to the corresponding closer
		  var frame = this._get_frame([tag], stop_list);
		  return this._try_pop_frame(frame);
		};

		TagStack.prototype.indent_to_tag = function(tag_list) {
		  var frame = this._get_frame(tag_list);
		  if (frame) {
		    this._printer.indent_level = frame.indent_level;
		  }
		};

		function Beautifier(source_text, options, js_beautify, css_beautify) {
		  //Wrapper function to invoke all the necessary constructors and deal with the output.
		  this._source_text = source_text || '';
		  options = options || {};
		  this._js_beautify = js_beautify;
		  this._css_beautify = css_beautify;
		  this._tag_stack = null;

		  // Allow the setting of language/file-type specific options
		  // with inheritance of overall settings
		  var optionHtml = new Options(options, 'html');

		  this._options = optionHtml;

		  this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, 'force'.length) === 'force';
		  this._is_wrap_attributes_force_expand_multiline = (this._options.wrap_attributes === 'force-expand-multiline');
		  this._is_wrap_attributes_force_aligned = (this._options.wrap_attributes === 'force-aligned');
		  this._is_wrap_attributes_aligned_multiple = (this._options.wrap_attributes === 'aligned-multiple');
		  this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, 'preserve'.length) === 'preserve';
		  this._is_wrap_attributes_preserve_aligned = (this._options.wrap_attributes === 'preserve-aligned');
		}

		Beautifier.prototype.beautify = function() {

		  // if disabled, return the input unchanged.
		  if (this._options.disabled) {
		    return this._source_text;
		  }

		  var source_text = this._source_text;
		  var eol = this._options.eol;
		  if (this._options.eol === 'auto') {
		    eol = '\n';
		    if (source_text && lineBreak.test(source_text)) {
		      eol = source_text.match(lineBreak)[0];
		    }
		  }

		  // HACK: newline parsing inconsistent. This brute force normalizes the input.
		  source_text = source_text.replace(allLineBreaks, '\n');

		  var baseIndentString = source_text.match(/^[\t ]*/)[0];

		  var last_token = {
		    text: '',
		    type: ''
		  };

		  var last_tag_token = new TagOpenParserToken(this._options);

		  var printer = new Printer(this._options, baseIndentString);
		  var tokens = new Tokenizer(source_text, this._options).tokenize();

		  this._tag_stack = new TagStack(printer);

		  var parser_token = null;
		  var raw_token = tokens.next();
		  while (raw_token.type !== TOKEN.EOF) {

		    if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
		      parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token, tokens);
		      last_tag_token = parser_token;
		    } else if ((raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE) ||
		      (raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete)) {
		      parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, last_token);
		    } else if (raw_token.type === TOKEN.TAG_CLOSE) {
		      parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
		    } else if (raw_token.type === TOKEN.TEXT) {
		      parser_token = this._handle_text(printer, raw_token, last_tag_token);
		    } else if (raw_token.type === TOKEN.CONTROL_FLOW_OPEN) {
		      parser_token = this._handle_control_flow_open(printer, raw_token);
		    } else if (raw_token.type === TOKEN.CONTROL_FLOW_CLOSE) {
		      parser_token = this._handle_control_flow_close(printer, raw_token);
		    } else {
		      // This should never happen, but if it does. Print the raw token
		      printer.add_raw_token(raw_token);
		    }

		    last_token = parser_token;

		    raw_token = tokens.next();
		  }
		  var sweet_code = printer._output.get_code(eol);

		  return sweet_code;
		};

		Beautifier.prototype._handle_control_flow_open = function(printer, raw_token) {
		  var parser_token = {
		    text: raw_token.text,
		    type: raw_token.type
		  };
		  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
		  if (raw_token.newlines) {
		    printer.print_preserved_newlines(raw_token);
		  } else {
		    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
		  }
		  printer.print_token(raw_token);
		  printer.indent();
		  return parser_token;
		};

		Beautifier.prototype._handle_control_flow_close = function(printer, raw_token) {
		  var parser_token = {
		    text: raw_token.text,
		    type: raw_token.type
		  };

		  printer.deindent();
		  if (raw_token.newlines) {
		    printer.print_preserved_newlines(raw_token);
		  } else {
		    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
		  }
		  printer.print_token(raw_token);
		  return parser_token;
		};

		Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
		  var parser_token = {
		    text: raw_token.text,
		    type: raw_token.type
		  };
		  printer.alignment_size = 0;
		  last_tag_token.tag_complete = true;

		  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
		  if (last_tag_token.is_unformatted) {
		    printer.add_raw_token(raw_token);
		  } else {
		    if (last_tag_token.tag_start_char === '<') {
		      printer.set_space_before_token(raw_token.text[0] === '/', true); // space before />, no space before >
		      if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
		        printer.print_newline(false);
		      }
		    }
		    printer.print_token(raw_token);

		  }

		  if (last_tag_token.indent_content &&
		    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
		    printer.indent();

		    // only indent once per opened tag
		    last_tag_token.indent_content = false;
		  }

		  if (!last_tag_token.is_inline_element &&
		    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
		    printer.set_wrap_point();
		  }

		  return parser_token;
		};

		Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, last_token) {
		  var wrapped = last_tag_token.has_wrapped_attrs;
		  var parser_token = {
		    text: raw_token.text,
		    type: raw_token.type
		  };

		  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
		  if (last_tag_token.is_unformatted) {
		    printer.add_raw_token(raw_token);
		  } else if (last_tag_token.tag_start_char === '{' && raw_token.type === TOKEN.TEXT) {
		    // For the insides of handlebars allow newlines or a single space between open and contents
		    if (printer.print_preserved_newlines(raw_token)) {
		      raw_token.newlines = 0;
		      printer.add_raw_token(raw_token);
		    } else {
		      printer.print_token(raw_token);
		    }
		  } else {
		    if (raw_token.type === TOKEN.ATTRIBUTE) {
		      printer.set_space_before_token(true);
		    } else if (raw_token.type === TOKEN.EQUALS) { //no space before =
		      printer.set_space_before_token(false);
		    } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) { //no space before value
		      printer.set_space_before_token(false);
		    }

		    if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === '<') {
		      if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
		        printer.traverse_whitespace(raw_token);
		        wrapped = wrapped || raw_token.newlines !== 0;
		      }

		      // Wrap for 'force' options, and if the number of attributes is at least that specified in 'wrap_attributes_min_attrs':
		      // 1. always wrap the second and beyond attributes
		      // 2. wrap the first attribute only if 'force-expand-multiline' is specified
		      if (this._is_wrap_attributes_force &&
		        last_tag_token.attr_count >= this._options.wrap_attributes_min_attrs &&
		        (last_token.type !== TOKEN.TAG_OPEN || // ie. second attribute and beyond
		          this._is_wrap_attributes_force_expand_multiline)) {
		        printer.print_newline(false);
		        wrapped = true;
		      }
		    }
		    printer.print_token(raw_token);
		    wrapped = wrapped || printer.previous_token_wrapped();
		    last_tag_token.has_wrapped_attrs = wrapped;
		  }
		  return parser_token;
		};

		Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
		  var parser_token = {
		    text: raw_token.text,
		    type: 'TK_CONTENT'
		  };
		  if (last_tag_token.custom_beautifier_name) { //check if we need to format javascript
		    this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
		  } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
		    printer.add_raw_token(raw_token);
		  } else {
		    printer.traverse_whitespace(raw_token);
		    printer.print_token(raw_token);
		  }
		  return parser_token;
		};

		Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
		  var local = this;
		  if (raw_token.text !== '') {

		    var text = raw_token.text,
		      _beautifier,
		      script_indent_level = 1,
		      pre = '',
		      post = '';
		    if (last_tag_token.custom_beautifier_name === 'javascript' && typeof this._js_beautify === 'function') {
		      _beautifier = this._js_beautify;
		    } else if (last_tag_token.custom_beautifier_name === 'css' && typeof this._css_beautify === 'function') {
		      _beautifier = this._css_beautify;
		    } else if (last_tag_token.custom_beautifier_name === 'html') {
		      _beautifier = function(html_source, options) {
		        var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);
		        return beautifier.beautify();
		      };
		    }

		    if (this._options.indent_scripts === "keep") {
		      script_indent_level = 0;
		    } else if (this._options.indent_scripts === "separate") {
		      script_indent_level = -printer.indent_level;
		    }

		    var indentation = printer.get_full_indent(script_indent_level);

		    // if there is at least one empty line at the end of this text, strip it
		    // we'll be adding one back after the text but before the containing tag.
		    text = text.replace(/\n[ \t]*$/, '');

		    // Handle the case where content is wrapped in a comment or cdata.
		    if (last_tag_token.custom_beautifier_name !== 'html' &&
		      text[0] === '<' && text.match(/^(<!--|<!\[CDATA\[)/)) {
		      var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text);

		      // if we start to wrap but don't finish, print raw
		      if (!matched) {
		        printer.add_raw_token(raw_token);
		        return;
		      }

		      pre = indentation + matched[1] + '\n';
		      text = matched[4];
		      if (matched[5]) {
		        post = indentation + matched[5];
		      }

		      // if there is at least one empty line at the end of this text, strip it
		      // we'll be adding one back after the text but before the containing tag.
		      text = text.replace(/\n[ \t]*$/, '');

		      if (matched[2] || matched[3].indexOf('\n') !== -1) {
		        // if the first line of the non-comment text has spaces
		        // use that as the basis for indenting in null case.
		        matched = matched[3].match(/[ \t]+$/);
		        if (matched) {
		          raw_token.whitespace_before = matched[0];
		        }
		      }
		    }

		    if (text) {
		      if (_beautifier) {

		        // call the Beautifier if avaliable
		        var Child_options = function() {
		          this.eol = '\n';
		        };
		        Child_options.prototype = this._options.raw_options;
		        var child_options = new Child_options();
		        text = _beautifier(indentation + text, child_options);
		      } else {
		        // simply indent the string otherwise
		        var white = raw_token.whitespace_before;
		        if (white) {
		          text = text.replace(new RegExp('\n(' + white + ')?', 'g'), '\n');
		        }

		        text = indentation + text.replace(/\n/g, '\n' + indentation);
		      }
		    }

		    if (pre) {
		      if (!text) {
		        text = pre + post;
		      } else {
		        text = pre + text + '\n' + post;
		      }
		    }

		    printer.print_newline(false);
		    if (text) {
		      raw_token.text = text;
		      raw_token.whitespace_before = '';
		      raw_token.newlines = 0;
		      printer.add_raw_token(raw_token);
		      printer.print_newline(true);
		    }
		  }
		};

		Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token, tokens) {
		  var parser_token = this._get_tag_open_token(raw_token);

		  if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) &&
		    !last_tag_token.is_empty_element &&
		    raw_token.type === TOKEN.TAG_OPEN && !parser_token.is_start_tag) {
		    // End element tags for unformatted or content_unformatted elements
		    // are printed raw to keep any newlines inside them exactly the same.
		    printer.add_raw_token(raw_token);
		    parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
		  } else {
		    printer.traverse_whitespace(raw_token);
		    this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
		    if (!parser_token.is_inline_element) {
		      printer.set_wrap_point();
		    }
		    printer.print_token(raw_token);
		  }

		  // count the number of attributes
		  if (parser_token.is_start_tag && this._is_wrap_attributes_force) {
		    var peek_index = 0;
		    var peek_token;
		    do {
		      peek_token = tokens.peek(peek_index);
		      if (peek_token.type === TOKEN.ATTRIBUTE) {
		        parser_token.attr_count += 1;
		      }
		      peek_index += 1;
		    } while (peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);
		  }

		  //indent attributes an auto, forced, aligned or forced-align line-wrap
		  if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
		    parser_token.alignment_size = raw_token.text.length + 1;
		  }

		  if (!parser_token.tag_complete && !parser_token.is_unformatted) {
		    printer.alignment_size = parser_token.alignment_size;
		  }

		  return parser_token;
		};

		var TagOpenParserToken = function(options, parent, raw_token) {
		  this.parent = parent || null;
		  this.text = '';
		  this.type = 'TK_TAG_OPEN';
		  this.tag_name = '';
		  this.is_inline_element = false;
		  this.is_unformatted = false;
		  this.is_content_unformatted = false;
		  this.is_empty_element = false;
		  this.is_start_tag = false;
		  this.is_end_tag = false;
		  this.indent_content = false;
		  this.multiline_content = false;
		  this.custom_beautifier_name = null;
		  this.start_tag_token = null;
		  this.attr_count = 0;
		  this.has_wrapped_attrs = false;
		  this.alignment_size = 0;
		  this.tag_complete = false;
		  this.tag_start_char = '';
		  this.tag_check = '';

		  if (!raw_token) {
		    this.tag_complete = true;
		  } else {
		    var tag_check_match;

		    this.tag_start_char = raw_token.text[0];
		    this.text = raw_token.text;

		    if (this.tag_start_char === '<') {
		      tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
		      this.tag_check = tag_check_match ? tag_check_match[1] : '';
		    } else {
		      tag_check_match = raw_token.text.match(/^{{~?(?:[\^]|#\*?)?([^\s}]+)/);
		      this.tag_check = tag_check_match ? tag_check_match[1] : '';

		      // handle "{{#> myPartial}}" or "{{~#> myPartial}}"
		      if ((raw_token.text.startsWith('{{#>') || raw_token.text.startsWith('{{~#>')) && this.tag_check[0] === '>') {
		        if (this.tag_check === '>' && raw_token.next !== null) {
		          this.tag_check = raw_token.next.text.split(' ')[0];
		        } else {
		          this.tag_check = raw_token.text.split('>')[1];
		        }
		      }
		    }

		    this.tag_check = this.tag_check.toLowerCase();

		    if (raw_token.type === TOKEN.COMMENT) {
		      this.tag_complete = true;
		    }

		    this.is_start_tag = this.tag_check.charAt(0) !== '/';
		    this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
		    this.is_end_tag = !this.is_start_tag ||
		      (raw_token.closed && raw_token.closed.text === '/>');

		    // if whitespace handler ~ included (i.e. {{~#if true}}), handlebars tags start at pos 3 not pos 2
		    var handlebar_starts = 2;
		    if (this.tag_start_char === '{' && this.text.length >= 3) {
		      if (this.text.charAt(2) === '~') {
		        handlebar_starts = 3;
		      }
		    }

		    // handlebars tags that don't start with # or ^ are single_tags, and so also start and end.
		    // if they start with # or ^, they are still considered single tags if indenting of handlebars is set to false
		    this.is_end_tag = this.is_end_tag ||
		      (this.tag_start_char === '{' && (!options.indent_handlebars || this.text.length < 3 || (/[^#\^]/.test(this.text.charAt(handlebar_starts)))));
		  }
		};

		Beautifier.prototype._get_tag_open_token = function(raw_token) { //function to get a full tag and parse its type
		  var parser_token = new TagOpenParserToken(this._options, this._tag_stack.get_parser_token(), raw_token);

		  parser_token.alignment_size = this._options.wrap_attributes_indent_size;

		  parser_token.is_end_tag = parser_token.is_end_tag ||
		    in_array(parser_token.tag_check, this._options.void_elements);

		  parser_token.is_empty_element = parser_token.tag_complete ||
		    (parser_token.is_start_tag && parser_token.is_end_tag);

		  parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
		  parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
		  parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || (this._options.inline_custom_elements && parser_token.tag_name.includes("-")) || parser_token.tag_start_char === '{';

		  return parser_token;
		};

		Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {

		  if (!parser_token.is_empty_element) {
		    if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
		      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name); //remove it and all ancestors
		    } else { // it's a start-tag
		      // check if this tag is starting an element that has optional end element
		      // and do an ending needed
		      if (this._do_optional_end_element(parser_token)) {
		        if (!parser_token.is_inline_element) {
		          printer.print_newline(false);
		        }
		      }

		      this._tag_stack.record_tag(parser_token); //push it on the tag stack

		      if ((parser_token.tag_name === 'script' || parser_token.tag_name === 'style') &&
		        !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
		        parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
		      }
		    }
		  }

		  if (in_array(parser_token.tag_check, this._options.extra_liners)) { //check if this double needs an extra line
		    printer.print_newline(false);
		    if (!printer._output.just_added_blankline()) {
		      printer.print_newline(true);
		    }
		  }

		  if (parser_token.is_empty_element) { //if this tag name is a single tag type (either in the list or has a closing /)

		    // if you hit an else case, reset the indent level if you are inside an:
		    // 'if', 'unless', or 'each' block.
		    if (parser_token.tag_start_char === '{' && parser_token.tag_check === 'else') {
		      this._tag_stack.indent_to_tag(['if', 'unless', 'each']);
		      parser_token.indent_content = true;
		      // Don't add a newline if opening {{#if}} tag is on the current line
		      var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
		      if (!foundIfOnCurrentLine) {
		        printer.print_newline(false);
		      }
		    }

		    // Don't add a newline before elements that should remain where they are.
		    if (parser_token.tag_name === '!--' && last_token.type === TOKEN.TAG_CLOSE &&
		      last_tag_token.is_end_tag && parser_token.text.indexOf('\n') === -1) ; else {
		      if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
		        printer.print_newline(false);
		      }
		      this._calcluate_parent_multiline(printer, parser_token);
		    }
		  } else if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
		    var do_end_expand = false;

		    // deciding whether a block is multiline should not be this hard
		    do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
		    do_end_expand = do_end_expand || (!parser_token.is_inline_element &&
		      !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) &&
		      !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) &&
		      last_token.type !== 'TK_CONTENT'
		    );

		    if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
		      do_end_expand = false;
		    }

		    if (do_end_expand) {
		      printer.print_newline(false);
		    }
		  } else { // it's a start-tag
		    parser_token.indent_content = !parser_token.custom_beautifier_name;

		    if (parser_token.tag_start_char === '<') {
		      if (parser_token.tag_name === 'html') {
		        parser_token.indent_content = this._options.indent_inner_html;
		      } else if (parser_token.tag_name === 'head') {
		        parser_token.indent_content = this._options.indent_head_inner_html;
		      } else if (parser_token.tag_name === 'body') {
		        parser_token.indent_content = this._options.indent_body_inner_html;
		      }
		    }

		    if (!(parser_token.is_inline_element || parser_token.is_unformatted) &&
		      (last_token.type !== 'TK_CONTENT' || parser_token.is_content_unformatted)) {
		      printer.print_newline(false);
		    }

		    this._calcluate_parent_multiline(printer, parser_token);
		  }
		};

		Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {
		  if (parser_token.parent && printer._output.just_added_newline() &&
		    !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
		    parser_token.parent.multiline_content = true;
		  }
		};

		//To be used for <p> tag special case:
		var p_closers = ['address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hr', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'];
		var p_parent_excludes = ['a', 'audio', 'del', 'ins', 'map', 'noscript', 'video'];

		Beautifier.prototype._do_optional_end_element = function(parser_token) {
		  var result = null;
		  // NOTE: cases of "if there is no more content in the parent element"
		  // are handled automatically by the beautifier.
		  // It assumes parent or ancestor close tag closes all children.
		  // https://www.w3.org/TR/html5/syntax.html#optional-tags
		  if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
		    return;

		  }

		  if (parser_token.tag_name === 'body') {
		    // A head element’s end tag may be omitted if the head element is not immediately followed by a space character or a comment.
		    result = result || this._tag_stack.try_pop('head');

		    //} else if (parser_token.tag_name === 'body') {
		    // DONE: A body element’s end tag may be omitted if the body element is not immediately followed by a comment.

		  } else if (parser_token.tag_name === 'li') {
		    // An li element’s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.
		    result = result || this._tag_stack.try_pop('li', ['ol', 'ul', 'menu']);

		  } else if (parser_token.tag_name === 'dd' || parser_token.tag_name === 'dt') {
		    // A dd element’s end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.
		    // A dt element’s end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.
		    result = result || this._tag_stack.try_pop('dt', ['dl']);
		    result = result || this._tag_stack.try_pop('dd', ['dl']);


		  } else if (parser_token.parent.tag_name === 'p' && p_closers.indexOf(parser_token.tag_name) !== -1) {
		    // IMPORTANT: this else-if works because p_closers has no overlap with any other element we look for in this method
		    // check for the parent element is an HTML element that is not an <a>, <audio>, <del>, <ins>, <map>, <noscript>, or <video> element,  or an autonomous custom element.
		    // To do this right, this needs to be coded as an inclusion of the inverse of the exclusion above.
		    // But to start with (if we ignore "autonomous custom elements") the exclusion would be fine.
		    var p_parent = parser_token.parent.parent;
		    if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
		      result = result || this._tag_stack.try_pop('p');
		    }
		  } else if (parser_token.tag_name === 'rp' || parser_token.tag_name === 'rt') {
		    // An rt element’s end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
		    // An rp element’s end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
		    result = result || this._tag_stack.try_pop('rt', ['ruby', 'rtc']);
		    result = result || this._tag_stack.try_pop('rp', ['ruby', 'rtc']);

		  } else if (parser_token.tag_name === 'optgroup') {
		    // An optgroup element’s end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.
		    // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
		    result = result || this._tag_stack.try_pop('optgroup', ['select']);
		    //result = result || this._tag_stack.try_pop('option', ['select']);

		  } else if (parser_token.tag_name === 'option') {
		    // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
		    result = result || this._tag_stack.try_pop('option', ['select', 'datalist', 'optgroup']);

		  } else if (parser_token.tag_name === 'colgroup') {
		    // DONE: A colgroup element’s end tag may be omitted if the colgroup element is not immediately followed by a space character or a comment.
		    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
		    result = result || this._tag_stack.try_pop('caption', ['table']);

		  } else if (parser_token.tag_name === 'thead') {
		    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
		    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
		    result = result || this._tag_stack.try_pop('caption', ['table']);
		    result = result || this._tag_stack.try_pop('colgroup', ['table']);

		    //} else if (parser_token.tag_name === 'caption') {
		    // DONE: A caption element’s end tag may be omitted if the caption element is not immediately followed by a space character or a comment.

		  } else if (parser_token.tag_name === 'tbody' || parser_token.tag_name === 'tfoot') {
		    // A thead element’s end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.
		    // A tbody element’s end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.
		    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
		    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
		    result = result || this._tag_stack.try_pop('caption', ['table']);
		    result = result || this._tag_stack.try_pop('colgroup', ['table']);
		    result = result || this._tag_stack.try_pop('thead', ['table']);
		    result = result || this._tag_stack.try_pop('tbody', ['table']);

		    //} else if (parser_token.tag_name === 'tfoot') {
		    // DONE: A tfoot element’s end tag may be omitted if there is no more content in the parent element.

		  } else if (parser_token.tag_name === 'tr') {
		    // A tr element’s end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.
		    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
		    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
		    result = result || this._tag_stack.try_pop('caption', ['table']);
		    result = result || this._tag_stack.try_pop('colgroup', ['table']);
		    result = result || this._tag_stack.try_pop('tr', ['table', 'thead', 'tbody', 'tfoot']);

		  } else if (parser_token.tag_name === 'th' || parser_token.tag_name === 'td') {
		    // A td element’s end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.
		    // A th element’s end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.
		    result = result || this._tag_stack.try_pop('td', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
		    result = result || this._tag_stack.try_pop('th', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
		  }

		  // Start element omission not handled currently
		  // A head element’s start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.
		  // A tbody element’s start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It can’t be omitted if the element is empty.)
		  // A colgroup element’s start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It can’t be omitted if the element is empty.)

		  // Fix up the parent of the parser token
		  parser_token.parent = this._tag_stack.get_parser_token();

		  return result;
		};

		beautifier.Beautifier = Beautifier;
		return beautifier;
	}

	/*jshint node:true */

	var hasRequiredHtml;

	function requireHtml () {
		if (hasRequiredHtml) return html.exports;
		hasRequiredHtml = 1;

		var Beautifier = requireBeautifier().Beautifier,
		  Options = requireOptions().Options;

		function style_html(html_source, options, js_beautify, css_beautify) {
		  var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
		  return beautifier.beautify();
		}

		html.exports = style_html;
		html.exports.defaultOptions = function() {
		  return new Options();
		};
		return html.exports;
	}

	/*jshint node:true */

	var hasRequiredSrc$2;

	function requireSrc$2 () {
		if (hasRequiredSrc$2) return src$2;
		hasRequiredSrc$2 = 1;

		var js_beautify = requireJavascript();
		var css_beautify = requireCss();
		var html_beautify = requireHtml();

		function style_html(html_source, options, js, css) {
		  js = js || js_beautify;
		  css = css || css_beautify;
		  return html_beautify(html_source, options, js, css);
		}
		style_html.defaultOptions = html_beautify.defaultOptions;

		src$2.js = js_beautify;
		src$2.css = css_beautify;
		src$2.html = style_html;
		return src$2;
	}

	/*jshint node:true */

	var hasRequiredJs;

	function requireJs () {
		if (hasRequiredJs) return js.exports;
		hasRequiredJs = 1;
		(function (module) {

			/**
			The following batches are equivalent:

			var beautify_js = require('js-beautify');
			var beautify_js = require('js-beautify').js;
			var beautify_js = require('js-beautify').js_beautify;

			var beautify_css = require('js-beautify').css;
			var beautify_css = require('js-beautify').css_beautify;

			var beautify_html = require('js-beautify').html;
			var beautify_html = require('js-beautify').html_beautify;

			All methods returned accept two arguments, the source string and an options object.
			**/

			function get_beautify(js_beautify, css_beautify, html_beautify) {
			  // the default is js
			  var beautify = function(src, config) {
			    return js_beautify.js_beautify(src, config);
			  };

			  // short aliases
			  beautify.js = js_beautify.js_beautify;
			  beautify.css = css_beautify.css_beautify;
			  beautify.html = html_beautify.html_beautify;

			  // legacy aliases
			  beautify.js_beautify = js_beautify.js_beautify;
			  beautify.css_beautify = css_beautify.css_beautify;
			  beautify.html_beautify = html_beautify.html_beautify;

			  return beautify;
			}

			{
			  (function(mod) {
			    var beautifier = requireSrc$2();
			    beautifier.js_beautify = beautifier.js;
			    beautifier.css_beautify = beautifier.css;
			    beautifier.html_beautify = beautifier.html;

			    mod.exports = get_beautify(beautifier, beautifier, beautifier);

			  })(module);
			} 
		} (js));
		return js.exports;
	}

	var jsExports = requireJs();
	var js_beautify = /*@__PURE__*/getDefaultExportFromCjs(jsExports);

	var dayjs_min$1 = {exports: {}};

	var dayjs_min = dayjs_min$1.exports;

	var hasRequiredDayjs_min;

	function requireDayjs_min () {
		if (hasRequiredDayjs_min) return dayjs_min$1.exports;
		hasRequiredDayjs_min = 1;
		(function (module, exports) {
			!function(t,e){module.exports=e();}(dayjs_min,(function(){var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",c="month",f="quarter",h="year",d="date",l="Invalid Date",$=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(t){var e=["th","st","nd","rd"],n=t%100;return "["+t+(e[(n-20)%10]||e[n]||e[0])+"]"}},m=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return +(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return {M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},g="en",D={};D[g]=M;var p="$isDayjsObject",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else {var a=e.name;D[a]=e,i=a;}return !r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,true),this.parse(t),this.$x=this.$x||t.x||{},this[p]=true;}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return b},m.isValid=function(){return !(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v="set"+(this.$u?"UTC":"");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+"Hours",0);case u:return $(v+"Minutes",1);case s:return $(v+"Seconds",2);case i:return $(v+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,false)},m.$set=function(t,e){var n,o=b.p(t),f="set"+(this.$u?"UTC":""),l=(n={},n[a]=f+"Date",n[d]=f+"Date",n[c]=f+"Month",n[h]=f+"FullYear",n[u]=f+"Hours",n[s]=f+"Minutes",n[i]=f+"Seconds",n[r]=f+"Milliseconds",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,"0")},$=f||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case "YY":return String(e.$y).slice(-2);case "YYYY":return b.s(e.$y,4,"0");case "M":return a+1;case "MM":return b.s(a+1,2,"0");case "MMM":return h(n.monthsShort,a,c,3);case "MMMM":return h(c,a);case "D":return e.$D;case "DD":return b.s(e.$D,2,"0");case "d":return String(e.$W);case "dd":return h(n.weekdaysMin,e.$W,o,2);case "ddd":return h(n.weekdaysShort,e.$W,o,3);case "dddd":return o[e.$W];case "H":return String(s);case "HH":return b.s(s,2,"0");case "h":return d(1);case "hh":return d(2);case "a":return $(s,u,true);case "A":return $(s,u,false);case "m":return String(u);case "mm":return b.s(u,2,"0");case "s":return String(e.$s);case "ss":return b.s(e.$s,2,"0");case "SSS":return b.s(e.$ms,3,"0");case "Z":return i}return null}(t)||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g;}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,true);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",c],["$y",h],["$D",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])};})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=true),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O})); 
		} (dayjs_min$1));
		return dayjs_min$1.exports;
	}

	var dayjs_minExports = requireDayjs_min();
	var dayjs = /*@__PURE__*/getDefaultExportFromCjs(dayjs_minExports);

	var utils$3 = {};

	var hasRequiredUtils$3;

	function requireUtils$3 () {
		if (hasRequiredUtils$3) return utils$3;
		hasRequiredUtils$3 = 1;
		var REG_NUMBER = /^([+-])?0*(\d+)(\.(\d+))?$/;
		var REG_E = /^([+-])?0*(\d+)(\.(\d+))?e(([+-])?(\d+))$/i;

		/**
		 * 科学计数法转十进制
		 * 
		 * @param {string} num 科学记数法字符串
		 * @returns string 
		 */
		var e2ten = utils$3.e2ten = function (num) {
			var result = REG_E.exec(num.toString());
			if (!result) return num;
			var zs = result[2]
				, xs = result[4] || ""
				, e = result[5] ? +result[5] : 0;
			if (e > 0) {
				var _zs = xs.substr(0, e);
				_zs = _zs.length < e ? _zs + new Array(e - _zs.length + 1).join("0") : _zs;
				xs = xs.substr(e);
				zs += _zs;
			} else {
				e = -e;
				var s_start = zs.length - e;
				s_start = s_start < 0 ? 0 : s_start;
				var _xs = zs.substr(s_start, e);
				_xs = _xs.length < e ? new Array(e - _xs.length + 1).join("0") + _xs : _xs;
				zs = zs.substring(0, s_start);
				xs = _xs + xs;
			}
			zs = zs == "" ? "0" : zs;
			return (result[1] == "-" ? "-" : "") + zs + (xs ? "." + xs : "");
		};

		/**
		 * 分析数字字符串
		 * 
		 * @param {string} num NumberString
		 * @returns object
		 */
		utils$3.getNumbResult = function (num) {
			var result = REG_NUMBER.exec(num.toString());
			if (!result && REG_E.test(num.toString())) {
				result = REG_NUMBER.exec(e2ten(num.toString()));
			}
			if (result) {
				return {
					int: result[2],
					decimal: result[4],
					minus: result[1] == "-",
					num: result.slice(1, 3).join('')
				}
			}
		};

		/**
		 * 数组归一 (按索引覆盖合并数组,并清空被合并的数组)
		 * 
		 * @param {array} baseArray 基础数组
		 * @param {...array} array1 
		 * @returns array
		 */
		utils$3.centerArray = function centerArray(baseArray, array1 /*[, array2[, ...[, arrayN]]]*/) {
			baseArray.splice.apply(baseArray, [0, array1.length].concat(array1.splice(0, array1.length)));
			if (arguments.length > 2) {
				var r = [].slice.call(arguments, 2);
				r.unshift(baseArray);
				centerArray.apply(null, r);
			}
			return baseArray;
		};

		/**
		 * 检查对像属性 (非原型链)
		 * 
		 * @param {object} obj
		 * @param {string} key
		 * @returns
		 */
		var hasAttr = utils$3.hasAttr = function (obj, key) {
			return Object.prototype.hasOwnProperty.call(obj, key);
		};

		/**
		 * 扩展对像(浅复制)
		 * 
		 * @param {object} obj
		 * @param {object} obj1
		 * @returns
		 */
		utils$3.extend = function (obj) {
			var name
				, target = arguments[0] || {};
			var objs = Array.prototype.slice.call(arguments, 1);

			for (var i = 0; i < objs.length; i++) {
				var _obj = objs[i];
				for (name in _obj) {
					if (hasAttr(_obj, name)) {
						target[name] = _obj[name];
					}
				}
			}
			return target;
		};


		/**
		 * 获取真实数位
		 * 
		 * @param {number} index 中文单位的索引
		 */
		utils$3.getDigit = function (index) {
			return index >= 5 ? (index - 4) * 4 + 4 : index;
		};

		/**
		 * 往数组头部插入0
		 * 
		 * @param {array} arr 
		 * @param {number} n 
		 */
		utils$3.unshiftZero = function (arr, n) {
			if (n == null) n = 1;
			if (n <= 0) return;
			for (; n--;) arr.unshift(0);
		};

		/**
		 * 清理多余"零"
		 * 
		 * @param {any} str 
		 * @param {any} zero "零"字符
		 * @param {any} type 清理模式 ^ - 开头, $ - 结尾, nto1 - 多个连续变一个
		 * @returns 
		 */
		utils$3.clearZero = function (str, zero, type) {
			if (str == null) return "";
			var reg0 = ~"*.?+$^[](){}|\\/".indexOf(zero) ? "\\" + zero : zero;
			var arg_s = new RegExp("^" + reg0 + "+")
				, arg_e = new RegExp(reg0 + "+$")
				, arg_d = new RegExp(reg0 + "{2}", "g");
			str = str.toString();
			if (type == "^") {
				str = str.replace(arg_s, "");
			}
			if (!type || type == "$") {
				str = str.replace(arg_e, "");
			}
			if (!type || type == "nto1") {
				str = str.replace(arg_d, zero);
			}
			return str;
		};
		return utils$3;
	}

	var src$1;
	var hasRequiredSrc$1;

	function requireSrc$1 () {
		if (hasRequiredSrc$1) return src$1;
		hasRequiredSrc$1 = 1;
		var utils = requireUtils$3();

		/**
		 * 阿拉伯数字转中文数字
		 * 
		 * @param {String} num 阿拉伯数字/字符串 , 科学记数法字符串
		 * @param {Object} opration 转换配置
		 *                          {
		 *                              ww: {万万化单位 | false}
		 *                              tenMin: {十的口语化 | false}
		 *                          }
		 * @returns String
		 */
		function CL(num, options) {
			var result = utils.getNumbResult(num);
			if (!result) {
				return num;
			}
			options = options ? options : {};
			var ch = this.ch             //数字
				, ch_u = this.ch_u       //单位
				, ch_f = this.ch_f || "" //负
				, ch_d = this.ch_d || "." //点
				, n0 = ch.charAt(0); //零
			var _int = result.int             //整数部分
				, _decimal = result.decimal   //小数部分
				, _minus = result.minus;      //负数标识
			var int = ""
				, dicimal = ""
				, minus = _minus ? ch_f : ''; //符号位
			var encodeInt = function encodeInt(_int, _m, _dg) {
				_int = utils.getNumbResult(_int).int;
				var int = ""
					, tenm = arguments.length > 1 ? arguments[1] : options.tenMin
					, _length = _int.length;
				//一位整数 
				if (_length == 1) return ch.charAt(+_int);
				if (_length <= 4) { //四位及以下
					for (var i = 0, n = _length; n--;) {
						var _num = +_int.charAt(i);
						int += (tenm && _length == 2 && i == 0 && _num == 1) ? "" : ch.charAt(_num);
						int += (_num && n ? ch_u.charAt(n) : '');
						i++;
					}
				} else {  //大数递归
					var d = _int.length / 4 >> 0
						, y = _int.length % 4;
					//"兆","京"等单位处理
					while (y == 0 || !ch_u.charAt(3 + d)) {
						y += 4;
						d--;
					}
					var _maxLeft = _int.substr(0, y), //最大单位前的数字
						_other = _int.substr(y); //剩余数字

					int = encodeInt(_maxLeft, tenm) + ch_u.charAt(3 + d) 
						+ (_other.charAt(0) == '0' ? n0 : '') //单位后有0则加零 
						+ encodeInt(_other, _other.length > 4 ? tenm : false); 
				}
				int = utils.clearZero(int, n0); //修整零
				return int;
			};

			//转换小数部分
			if (_decimal) {
				_decimal = utils.clearZero(_decimal, "0", "$"); //去除尾部0
				for (var x = 0; x < _decimal.length; x++) {
					dicimal += ch.charAt(+_decimal.charAt(x));
				}
				dicimal = dicimal ? ch_d + dicimal : "";
			}

			//转换整数部分
			int = encodeInt(_int);  //转换整数

			//超级大数的万万化 
			if (options.ww && ch_u.length > 5) {
				var dw_w = ch_u.charAt(4)
					, dw_y = ch_u.charAt(5);
				var lasty = int.lastIndexOf(dw_y);
				if (~lasty) {
					int = int.substring(0, lasty).replace(new RegExp(dw_y, 'g'), dw_w + dw_w) + int.substring(lasty);
				}
			}
			return minus + int + dicimal;
		}

		/**
		 * 中文数字转阿拉伯数字
		 * 
		 * @param {string} cnnumb 中文数字字符串
		 * @returns Number
		 */
		function unCL(cnnumb, options) {
			cnnumb = cnnumb.toString();
			var result = cnnumb.split(this.ch_d);
			var _int = result[0].replace(this.ch_f, "")
				, _decimal = result[1]
				, _minus = !!~result[0].indexOf(this.ch_f);

			var dw_s = this.ch_u.charAt(1)
				, dw_w = this.ch_u.charAt(4)
				, dw_y = this.ch_u.charAt(5);

			_int = _int.replace(new RegExp(dw_w + "{2}(?!"+dw_w+")", "g"), dw_y);
			var cnarr = _int.split('');
			var dw = 0, maxdw = 0;
			var rnum_a = [], num_a = [], _num_a = [];
			for (var i = 0; i < cnarr.length; i++) {
				var chr = cnarr[i];
				var n = 0, u = 0;
				if (~(n = this.ch.indexOf(chr))) {
					//_num = _num*10 + n;
					if (n > 0) _num_a.unshift(n);
					//_num_a.unshift(n);
				} else if (~(u = this.ch_u.indexOf(chr))) {
					var digit = utils.getDigit(u);
					if (dw > u) {//正常情况
						utils.unshiftZero(_num_a, digit);
						utils.centerArray(num_a, _num_a);
					} else if (u >= maxdw) {//后跟大单位
						if (i == 0) _num_a = [1];
						utils.centerArray(rnum_a, num_a, _num_a);
						if (rnum_a.length > 0) utils.unshiftZero(rnum_a, digit);
						maxdw = u;
					} else {
						if (_num_a.length == 0 && dw_s == chr) _num_a = [1];
						utils.centerArray(num_a, _num_a);
						utils.unshiftZero(num_a, utils.getDigit(u));
						dw = u;
					}
				}
			}
			utils.centerArray(rnum_a, num_a, _num_a).reverse();
			if (rnum_a.length == 0) rnum_a.push(0);
			var decimal = 0;
			if (_decimal) {
				rnum_a.push('.');
				decimal = '0.';
				for (var i = 0; i < _decimal.length; i++) {
					decimal += this.ch.indexOf(_decimal.charAt(i));
					rnum_a.push(this.ch.indexOf(_decimal.charAt(i)));
				}
				decimal = +decimal;

			}
			if (_minus) rnum_a.unshift('-');
			return (options && options.outputString)  ? rnum_a.join('') : parseFloat(rnum_a.join(''));
		}

		/**
		 * 阿拉伯数字转金额
		 * 
		 * @param {String} num 阿拉伯数字/字符串 , 科学记数法字符串
		 * @param {Object} options 转换配置
		 *                         {
		 *                             ww:{万万化开关 | true},
		 *                             unOmitYuan: {整数为0时不省略元| false},
		 *                             complete:{完整金额格式 | false},
		 *                             outSymbol:{是否输出金额符号 | true}                             
		 *                             forceZheng:{以转换结果加“整” | false}                             
		 *                         }
		 * @returns String
		 */
		function toMoney(num, options) {
			var def = { ww: true, complete: false, outSymbol: true, unOmitYuan: false, forceZheng: false };
			var result = utils.getNumbResult(num);
			var ch_0 = this.ch.charAt(0);
			options = typeof options == "object" ? options : {};
			if (!result) { return num; }
			options = utils.extend(def, options);

			var _int = result.int
				, _decimal = result.decimal || "";
			var t_str = options.outSymbol ? this.m_t : ""
				, zs_str = result.minus ? this.ch_f : ""
				, xs_str = "";
			if (options.complete) {
				for (var i = 1; i < this.m_u.length; i++) {
					xs_str += CL.call(this, _decimal.charAt(i - 1) || "0") + this.m_u.charAt(i);
				}
				zs_str += CL.call(this, _int, options) + this.m_u.charAt(0);
			} else {
				var hasYuan = options.unOmitYuan || _int !== '0';
				_decimal = _decimal.substr(0, this.m_u.length-1); 
				_decimal = utils.clearZero(_decimal, "0", "$"); //去除尾部的0
				if (_decimal) {
					var mark_0;
					for (var i = 0; i < this.m_u.length - 1; i++) {
						if (_decimal.charAt(i) && _decimal.charAt(i) != "0") {
							xs_str += CL.call(this, _decimal.charAt(i)) + this.m_u.charAt(i + 1);
							mark_0 = false;
						}
						if (_decimal.charAt(i) === "0" && !mark_0) {
							if (i != 0 || _int !== "0") xs_str += ch_0; //当没有输出元时,小数前无需加零
							mark_0 = true;
						}
					}
					//if(_num == "0"){xs_str = utils.clearZero(xs_str,ch_0,"^")}
				}
				if (hasYuan || !xs_str) {
					zs_str += CL.call(this, _int, options) + this.m_u.charAt(0);
				}
				if(!options.forceZheng) { 
					zs_str += result.decimal ? "" : this.m_z;
				}else if(xs_str == '' || xs_str.charAt(xs_str.length-1) !== this.m_u[2]){
					xs_str += this.m_z;			
				}
				// if(result.minus) t_str += this.ch_f;
				if(options.forceZheng);
			}
			return t_str + zs_str + xs_str;
		}

		src$1 = {
			CL: CL,
			unCL: unCL,
			toMoney: toMoney
		};
		return src$1;
	}

	var autoGet;
	var hasRequiredAutoGet;

	function requireAutoGet () {
		if (hasRequiredAutoGet) return autoGet;
		hasRequiredAutoGet = 1;
		var nzhClass = requireSrc$1();
		var utils = requireUtils$3();
		function getNzhObjByLang(lang_s, lang_b) {
			return {
				encodeS: function (num, options) {
					options = utils.extend({ ww: true, tenMin: true }, options);
					return nzhClass.CL.call(lang_s, num, options);
				},
				encodeB: function (num, options) {
					options = utils.extend({ ww: true }, options);
					return nzhClass.CL.call(lang_b, num, options);
				},
				decodeS: function () {
					return nzhClass.unCL.apply(lang_s, arguments);
				},
				decodeB: function () {
					return nzhClass.unCL.apply(lang_b, arguments);
				},
				toMoney: function (num, options) {
					options = utils.extend({ ww: true }, options);
					return nzhClass.toMoney.call(lang_b, num, options);
				}
			}
		}
		autoGet = getNzhObjByLang;
		return autoGet;
	}

	var cn_s;
	var hasRequiredCn_s;

	function requireCn_s () {
		if (hasRequiredCn_s) return cn_s;
		hasRequiredCn_s = 1;
		cn_s = {
		    ch: '零一二三四五六七八九'
		    ,ch_u: '个十百千万亿'
		    ,ch_f: '负'
		    ,ch_d: '点'
		};
		return cn_s;
	}

	var cn_b;
	var hasRequiredCn_b;

	function requireCn_b () {
		if (hasRequiredCn_b) return cn_b;
		hasRequiredCn_b = 1;
		cn_b = {
		    ch: '零壹贰叁肆伍陆柒捌玖'
		    ,ch_u: '个拾佰仟万亿'
		    ,ch_f: '负'
		    ,ch_d: '点'
		    ,m_t: '人民币'
		    ,m_z: '整'
		    ,m_u: '元角分'
		};
		return cn_b;
	}

	var hk_s;
	var hasRequiredHk_s;

	function requireHk_s () {
		if (hasRequiredHk_s) return hk_s;
		hasRequiredHk_s = 1;
		hk_s = {
		    ch: '零一二三四五六七八九'
		    ,ch_u: '個十百千萬億'
		    ,ch_f: '負'
		    ,ch_d: '點'
		};
		return hk_s;
	}

	var hk_b;
	var hasRequiredHk_b;

	function requireHk_b () {
		if (hasRequiredHk_b) return hk_b;
		hasRequiredHk_b = 1;
		hk_b = {
		    ch: '零壹貳參肆伍陸柒捌玖'
		    ,ch_u: '個拾佰仟萬億'
		    ,ch_f: '負'
		    ,ch_d: '點'
		    ,m_t: '$'
		    ,m_z: '整'
		    ,m_u: '圓角分'
		};
		return hk_b;
	}

	var nzh;
	var hasRequiredNzh;

	function requireNzh () {
		if (hasRequiredNzh) return nzh;
		hasRequiredNzh = 1;
		var nzhClass = requireSrc$1();
		requireUtils$3();
		var getNzhObjByLang = requireAutoGet();
		var langs = {
			s:requireCn_s(),
			b:requireCn_b(),
			hk_s:requireHk_s(),
			hk_b:requireHk_b()
		};
		var Nzh = function(lang){
			this.lang = lang;
			this.encode = function(){return nzhClass.CL.apply(lang,arguments)};
			this.decode = function(){return nzhClass.unCL.apply(lang,arguments)};
			this.toMoney = function(){return nzhClass.toMoney.apply(lang,arguments)};
		};
		Nzh.langs = langs;
		Nzh.cn = getNzhObjByLang(langs.s,langs.b);
		Nzh.hk = getNzhObjByLang(langs.hk_s,langs.hk_b);
		nzh = Nzh;
		return nzh;
	}

	var nzhExports = requireNzh();
	var Nzh = /*@__PURE__*/getDefaultExportFromCjs(nzhExports);

	/**
	 * @param {string} string 
	 * @returns {Array}
	 */

	/**
	 * @param {string} json 
	 * @returns 
	 */
	function evalParser(json) {
	    return Function(`return (${json})`)()
	}

	/*
	把毫秒或秒格式的时间转换为可读的字符串形式
	*/

	const dateStr = (time_) => {
	    var time = parseInt(time_);
	    if (!time) return ''
	    if (time > 15104725270) {
	        return dayjs(time).format('YYYY-MM-DD HH:mm:ss.SSS')
	    } else {
	        return dayjs(time * 1000).format('YYYY-MM-DD HH:mm:ss.SSS')
	    }
	};

	function formatTimeInString(text) {
	    return text.replace(/(\d{11,13})|(\d{10})/g, function (val) {
	        var date = parseInt(val);
	        // java中的Integer.MAX_VALUE
	        if (date == 2147483647) { return val }
	        if (val.length == 10) {
	            if (val.startsWith('19')) { return val }
	            if (val.startsWith('20')) { return val }
	            date *= 1000;
	        }
	        return dayjs(date).format('YYYY-MM-DD HH:mm:ss.SSS')
	    })
	}

	/*
	格式化json字符串或js对象为格式化好的json字符串
	*/
	const jsonFormat = (arg) => {
	    if (typeof arg == "string") {
	        arg = JSON.parse(arg);
	    }
	    return JSON.stringify(arg, null, 4)
	};

	/**
	 * @param {string} obj
	 */
	function jsonDeepParse(obj) {
	    /** @type{object} */
	    let o = obj;
	    if (typeof (obj) == 'string') {
	        try {
	            o = JSON.parse(obj);
	        } catch (e) {
	            try {
	                if (o.length < 33) {
	                    return o
	                }
	                o = evalParser(o);
	                return jsonDeepParse(o)
	            } catch (e1) {
	                return o
	            }
	        }
	    }
	    if (typeof (o) == 'string') {
	        return jsonDeepParse(o)
	    }
	    if (o instanceof Array) {
	        for (var i = 0; i < o.length; i++) {
	            o[i] = jsonDeepParse(o[i]);
	        }
	    } else {
	        for (var k in o) {
	            if (o.hasOwnProperty(k)) {
	                o[k] = jsonDeepParse(o[k]);
	            }
	        }
	    }
	    return o
	}

	const jsonStr = (obj) => {
	    let cache = [];
	    let str = JSON.stringify(obj, (key, value) => {
	        if (typeof value === 'object' && value !== null) {
	            if (cache.indexOf(value) !== -1) {
	                return
	            }
	            cache.push(value);
	        }
	        return value
	    });
	    return str
	};

	const formatSize = (size) => {
	    if (!size) return ''
	    if (size < 0) { return '0B'.padStart(8, ' ') }
	    let companys = 'B KB MB GB TB'.split(' ');
	    let cur = size;
	    while (cur >= 1024) {
	        companys.shift();
	        cur /= 1024;
	    }
	    return (cur.toFixed(2) + companys[0]).replace('.00', '').padStart(8, ' ')
	};

	const parseSecondTime = (/** @type {number} */ seconds) => {
	    if (typeof seconds == 'undefined') { return '' }
	    // @ts-ignore
	    if (seconds == '-') { return '-' }
	    return `${Math.floor(seconds / 60)}分${seconds % 60}秒`
	};

	const parseMillisecondTime = (/** @type {number} */ milliseconds) => {
	    if (typeof milliseconds == 'undefined') { return '' }
	    // @ts-ignore
	    if (milliseconds == '-') { return '-' }
	    return `${Math.floor(milliseconds / 1000 / 60)}:${Math.floor(milliseconds / 1000 % 60)}.${milliseconds % 1000}ms`
	};

	const parseDBColumnResults = (results) => {
	    let columns = results[0].columns;
	    let values = results[0].values;
	    return values.map((item) => columns.reduce((a, b, i) => (a[b] = item[i], a), {}))
	};

	var Formatter = {
	    dateStr,
	    jsonFormat,
	    jsonDeepParse,
	    jsonStr,
	    formatSize,
	    parseSecondTime,
	    parseMillisecondTime,
	    formatTimeInString,
	    parseDBColumnResults,
	};

	/**
	 * @param {object} variable
	 */
	function isPlainObject(variable) {
	    return typeof variable === "object" && variable !== null && Object.prototype.toString.call(variable) === "[object Object]"
	}

	/**
	 * @param {object} json
	 */
	function rearrangeJsonKey(json) {
	    if (Array.isArray(json)) {
	        for (let i = 0; i < json.length; i++) {
	            json[i] = rearrangeJsonKey(json[i]);
	        }
	        return json
	    }
	    if (isPlainObject(json)) {
	        let sortedObj = {};
	        let keys = Object.keys(json).sort();
	        for (const key of keys) {
	            let value = json[key];
	            sortedObj[key] = rearrangeJsonKey(value);
	        }
	        return sortedObj
	    }
	    return json
	}

	class LocalFileReader {

	    /**
	     * @typedef {Object} LocalFileInfo
	     * @property {string} name
	     * @property {Uint8Array<ArrayBuffer>} buffer
	     */

	    /**
	     * @param {'image/png'|'*'} [accept] 
	     * @returns {Promise<LocalFileInfo>}
	     */
	    static async read(accept) {
	        return new Promise((resolve) => {
	            let input = document.createElement('input');
	            input.type = 'file';
	            input.accept = accept;
	            input.onchange = (/**@type{object}*/event) => {
	                var f = event.target.files[0];
	                resolve(this.readFile(f));
	            };
	            input.oncancel = () => resolve(null);
	            setTimeout(() => {
	                input.click();
	            }, 100);
	        })
	    }

	    /**
	     * @param {File} file 
	     * @returns {Promise<LocalFileInfo>}
	     */
	    static async readFile(file) {
	        return new Promise((resolve) => {
	            if (!file) {
	                resolve(null);
	                return
	            }
	            var r = new FileReader();
	            r.onload = async (/**@type{object}*/event) => {
	                let buffer = event.target.result;
	                resolve({ name: file.name, buffer: buffer });
	            };
	            r.readAsArrayBuffer(file);
	        })
	    }

	    /**
	     * @returns {Promise<Blob>}
	     */
	    static async readCliboardImage() {
	        let list = await navigator.clipboard.read();
	        let image = null;
	        for (const item of list) {
	            let imageType = null;
	            let types = item.types;
	            for (const type of types) {
	                if (type.startsWith("image")) {
	                    imageType = type;
	                }
	            }
	            if (imageType) {
	                image = await item.getType(imageType);
	                console.log(image);
	            }
	        }

	        console.log('image', image);

	        if (!image) {
	            return null
	        }

	        return image
	    }
	}

	class NameGenerate {
	  constructor() {
	    this.nameCode = '鑫正涵琛妍芸露楠薇锦彤采初美冬婧桐莲彩洁'
	      + '呈菡怡冰雯雪茜优静萱林馨鹤梅娜璐曼彬芳颖韵曦蔚桂月梦琪蕾'
	      + '依碧枫欣杉丽祥雅欢婷舒心紫芙慧梓香玥菲璟茹昭岚玲云华阳弦'
	      + '莉明珊雨蓓旭钰柔敏家凡花媛歆沛姿妮珍琬彦倩玉柏橘昕桃栀克'
	      + '帆俊惠漫芝寒诗春淑凌珠灵可格璇函晨嘉鸿瑶帛琳文洲娅霞颜康'
	      + '卓星礼远帝裕腾震骏加强运杞良梁逸禧辰佳子栋博年振荣国钊喆'
	      + '睿泽允邦骞哲皓晖福濡佑然升树祯贤成槐锐芃驰凯韦信宇鹏盛晓'
	      + '翰海休浩诚辞轩奇潍烁勇铭平瑞仕谛翱伟安延锋寅起谷稷胤涛弘'
	      + '侠峰材爵楷尧炳乘蔓桀恒桓日坤龙锟天郁吉暄澄中斌杰祜权畅德';
	  }

	  get() {
	    let length = [3, 2, 4, 5][Math.floor(Math.random() * Math.random() * 3.1)];
	    let name = [];
	    while (length--) {
	      name.push(this.nameCode[Math.floor(Math.random() * this.nameCode.length)]);
	    }
	    return name.join('')
	  }
	}

	function toDom(template) {
	    var t = document.createElement('template');
	    t.innerHTML = template.trim();
	    return t.content.cloneNode(true).firstChild
	}

	class ViewDialogNoCode {

	    /**
	     *  @param {Object} app 
	     *  @param {{
	     *          title:string,
	     *          forms: {
	     *                  type:'input'|'br'|'date'|'checkbox'|'switch'|'select'|'textarea'|'code'|'radio',
	     *                  key?:string,
	     *                  value?:string,
	     *                  label?:string,
	     *                  checked?:boolean,
	     *                  focus?:boolean,
	     *                  items?:string[],
	     *                  width?:string,
	     *                  height?:string,
	     *                  alignEnd?:string?,
	     *                  inputType?:('number'|'text'|'password'),
	     *                  language?:('javascript'|'json'|'xml'),
	     *                  icon?:('event'|'person'|'date_range'|'add_task'|string),
	     *              }[],
	     *          minWidthRatio?:number
	     *          cancel?:string,
	     *          confirm?:string,
	     *          }} cfgs
	     */
	    static async getDialogParams(app, cfgs) {
	        return new Promise((resolve) => {
	            // https://material.io/resources/icons/
	            (async () => {
	                cfgs = Object.assign({
	                    title: '搜索参数',
	                    forms: [
	                        { type: 'br' },
	                        { type: 'input', key: 'key_input1', value: 'value2', label: 'label', focus: false, icon: 'event', width: '80%', inputType: 'number' },
	                        { type: 'br' },
	                        { type: 'input', key: 'key_input2', value: 'value2', label: 'label', focus: true, icon: 'event' },
	                        { type: 'br' },
	                        { type: 'date', key: 'key_date', value: 'value2', label: 'label-date' },
	                        { type: 'br' },
	                        { type: 'checkbox', key: 'key_checkbox', value: 'value2', label: 'label-checkbox' },
	                        { type: 'br' },
	                        { type: 'switch', key: 'key_switch', value: 'value2', label: 'label-switch' },
	                        { type: 'br' },
	                        { type: 'br' },
	                        { type: 'select', key: 'key_select', value: 'label2', label: 'label-select', items: ['label1', 'label2', 'label3', 'label4',] },
	                        { type: 'br' },
	                        { type: 'textarea', key: 'key_textarea', value: 'text text ...', label: 'label-textarea' },
	                        { type: 'br' },
	                        { type: 'code', key: 'key_code', value: 'code code ....', height: '300px', language: 'javascript' },
	                        { type: 'br' },
	                        { type: 'br' },
	                    ],
	                    confirm: '确定',
	                    cancel: '取消',
	                    minWidthRatio: null,
	                }, cfgs);

	                let formFields = [];
	                for (let i = 0; i < cfgs.forms.length; i++) {
	                    const o = cfgs.forms[i];
	                    switch (o.type) {
	                        case 'br': formFields.push(`<br data-index="${i}">`); break
	                        case 'input': formFields.push(`<input data-index="${i}" type="text" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">`); break
	                        case 'textarea': formFields.push(`<textarea data-index="${i}" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>`); break
	                        case 'radio': formFields.push(`<div data-index="${i}" class="flex items-center"><input type="radio" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300"><label class="ml-2 block text-sm text-gray-900"></label></div>`); break
	                        case 'date': formFields.push(`<input data-index="${i}" type="date" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">`); break
	                        case 'checkbox': formFields.push(`<div data-index="${i}" class="flex items-center"><input type="checkbox" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"><label class="ml-2 block text-sm text-gray-900"></label></div>`); break
	                        case 'switch': formFields.push(`<div data-index="${i}" class="flex items-center"><label class="relative inline-flex items-center cursor-pointer"><input type="checkbox" class="sr-only peer"><div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div></label></div>`); break
	                        case 'select': formFields.push(`<select data-index="${i}" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"></select>`); break
	                        case 'code': formFields.push(`<div data-index="${i}"></div>`); break
	                        default: throw new Error(JSON.stringify(o))
	                    }
	                }

	                /** @type{*} */
	                // @ts-ignore
	                let dialog = toDom(`
                    <div class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
                        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                            <div class="mt-3 text-center">
                                <h3 class="text-lg leading-6 font-medium text-gray-900">${cfgs.title}</h3>
                                <div class="mt-2 px-7 py-3">
                                    ${formFields.join('')}
                                </div>
                                <div class="items-center px-4 py-3">
                                    <button class="cancel px-4 py-2 bg-gray-500 text-white text-base font-medium rounded-md w-24 shadow-sm hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-300 mr-2" dialogAction="cancel">
                                        ${cfgs.cancel}
                                    </button>
                                    <button class="search px-4 py-2 bg-blue-500 text-white text-base font-medium rounded-md w-24 shadow-sm hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-300" dialogAction="search">
                                        ${cfgs.confirm}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `);

	                if (cfgs.minWidthRatio) dialog.style.cssText += ` --mdc-dialog-min-width: ${document.body.clientWidth * cfgs.minWidthRatio}px;`;

	                for (let i = 0; i < cfgs.forms.length; i++) {
	                    const o = cfgs.forms[i];
	                    /** @type{HTMLDivElement} */
	                    let dom = dialog.querySelector(`[data-index="${i}"]`);
	                    let radio = dom.querySelector('input[type="radio"]');
	                    let checkbox = dom.querySelector('input[type="checkbox"]');
	                    let switchDom = dom.querySelector('input[type="checkbox"].sr-only');
	                    let input = dom.querySelector('input');
	                    let label = dom.querySelector('label');
	                    let selectItem = null;
	                    if (o.key) dom.setAttribute('key', o.key);
	                    if (o.label) {
	                        dom.setAttribute('label', o.label);
	                        if (label) label.textContent = o.label;
	                    }
	                    if (o.value) dom.setAttribute('value', o.value);
	                    if (o.icon) dom.setAttribute('icon', o.icon);
	                    if (o.focus) dom.setAttribute('dialogInitialFocus', String(o.focus));
	                    if (o.width) dom.style.width = o.width;

	                    switch (o.type) {
	                        case 'br': break
	                        case 'input':
	                        case 'textarea':
	                        case 'date':
	                            if (o.inputType) input.setAttribute('type', o.inputType);
	                            if (o.value) input.value = o.value;
	                            break
	                        case 'radio':
	                            if (o.key) radio.setAttribute('key', o.key);
	                            if (o.key) radio.setAttribute('name', o.key);
	                            if (o.value) radio.setAttribute('value', o.value);
	                            if (o.checked) radio.setAttribute('checked', String(o.checked));
	                            break
	                        case 'checkbox':
	                            if (o.key) checkbox.setAttribute('key', o.key);
	                            if (o.checked) checkbox.setAttribute('checked', String(o.checked));
	                            break
	                        case 'switch':
	                            if (o.key) switchDom.setAttribute('key', o.key);
	                            if (o.checked) switchDom.setAttribute('checked', String(o.checked));
	                            break
	                        case 'select':
	                            o.items.forEach(item => {
	                                selectItem = document.createElement('option');
	                                selectItem.textContent = item;
	                                selectItem.value = item;
	                                dom.append(selectItem);
	                            });
	                            // @ts-ignore
	                            if (o.value) dom.value = o.value;
	                            break
	                        default: throw new Error(JSON.stringify(o))
	                    }
	                }

	                let radios = dialog.querySelectorAll('input[type="radio"]');
	                let checkboxs = dialog.querySelectorAll('input[type="checkbox"]:not(.sr-only)');
	                let selects = dialog.querySelectorAll('select');
	                let switchs = dialog.querySelectorAll('input[type="checkbox"].sr-only');
	                let textfields = dialog.querySelectorAll('input[type="text"]');
	                let textareas = dialog.querySelectorAll('textarea');
	                let inputs = dialog.querySelectorAll('input[type="date"]');
	                let codes = dialog.querySelectorAll('.__editor__');
	                dialog.addEventListener('click', (e) => {
	                    // @ts-ignore
	                    if (e.target.hasAttribute('dialogAction')) {
	                        let action = e.target.getAttribute('dialogAction');
	                        let obj = {};
	                        let eleHandler = o => {
	                            let key = o.getAttribute('key');
	                            let value = o.value;
	                            obj[key] = value;
	                        };
	                        let eleHandlerBool = o => {
	                            let key = o.getAttribute('key');
	                            let value = o.checked;
	                            obj[key] = value;
	                        };
	                        let eleHandlerCode = o => {
	                            let key = o.getAttribute('key');
	                            let value = o['__editor__'].getValue();
	                            obj[key] = value;
	                        };
	                        [...radios].filter(o => o.checked).forEach(eleHandler);
	                        [...checkboxs].forEach(eleHandlerBool);
	                        [...switchs].forEach(eleHandlerBool);
	                        [...textfields].forEach(eleHandler);
	                        [...textareas].forEach(eleHandler);
	                        [...inputs].forEach(eleHandler);
	                        [...selects].forEach(eleHandler);
	                        [...codes].forEach(eleHandlerCode);
	                        console.log(obj);
	                        switch (action) {
	                            case 'search':
	                                resolve(obj);
	                                break
	                            default:
	                                resolve();
	                                break
	                        }
	                        dialog.remove();
	                    }
	                });
	                // dialog.style.zIndex=4100
	                if (app?.layout?.currentContainer) {
	                    app.layout.currentContainer.element.append(dialog);
	                } else {
	                    document.body.appendChild(dialog);
	                }
	                dialog.show();
	            })();
	        })
	    }

	    /**
	     *  @param {Object} app 
	     *  @param {{
	     *          title:string,
	     *          forms: [{
	     *                  type:('input'|'br'|'date'|'checkbox'|'switch'|'select'|'textarea'|'code'|'radio'|'button'),
	     *                  key:string,
	     *                  value:string,
	     *                  label:string,
	     *                  checked:boolean,
	     *                  onclick:EventListener,
	     *                  focus:boolean,
	     *                  items:string[],
	     *                  width:string,
	     *                  height:string,
	     *                  alignEnd:string?,
	     *                  inputType:('number'|'text'|'password'),
	     *                  language:('javascript'|'json'|'xml'),
	     *                  icon:('event'|'person'|'date_range'|'add_task'|string),
	     *              }],
	     *          minWidthRatio:number?,
	     *          confirm:string?,
	     *          }} cfgs
	     */
	    // @ts-ignore
	    static async getForm(app, cfgs, cb) {
	        return new Promise((resolve) => {
	            // https://material.io/resources/icons/
	            (async () => {
	                cfgs = Object.assign({
	                    title: '搜索参数',
	                    forms: [
	                        { type: 'br' },
	                        { type: 'input', key: 'key_input1', value: 'value2', label: 'label', focus: false, icon: 'event', width: '80%', inputType: 'number' },
	                        { type: 'br' },
	                        { type: 'input', key: 'key_input2', value: 'value2', label: 'label', focus: true, icon: 'event' },
	                        { type: 'br' },
	                        { type: 'date', key: 'key_date', value: 'value2', label: 'label-date' },
	                        { type: 'br' },
	                        { type: 'checkbox', key: 'key_checkbox', value: 'value2', label: 'label-checkbox' },
	                        { type: 'br' },
	                        { type: 'switch', key: 'key_switch', value: 'value2', label: 'label-switch', checked: true },
	                        { type: 'br' },
	                        { type: 'br' },
	                        { type: 'select', key: 'key_select', value: 'label2', label: 'label-select', items: ['label1', 'label2', 'label3', 'label4',] },
	                        { type: 'br' },
	                        { type: 'textarea', key: 'key_textarea', value: 'text text ...', label: 'label-textarea' },
	                        { type: 'br' },
	                        { type: 'code', key: 'key_code', value: 'code code ....', height: '300px', language: 'javascript' },
	                        { type: 'br' },
	                        { type: 'button', label: 'label-button', onclick: () => { alert('hello'); } },
	                        { type: 'br' },
	                        { type: 'br' },
	                    ],
	                    confirm: '确定',
	                    cancel: '取消',
	                    minWidthRatio: null,
	                }, cfgs);

	                let formFields = [];
	                for (let i = 0; i < cfgs.forms.length; i++) {
	                    const o = cfgs.forms[i];
	                    switch (o.type) {
	                        case 'br': formFields.push(`<br data-index="${i}">`); break
	                        case 'input': formFields.push(`<input data-index="${i}" type="text" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">`); break
	                        case 'textarea': formFields.push(`<textarea data-index="${i}" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>`); break
	                        case 'radio': formFields.push(`<div data-index="${i}" class="flex items-center"><input type="radio" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300"><label class="ml-2 block text-sm text-gray-900"></label></div>`); break
	                        case 'date': formFields.push(`<input data-index="${i}" type="date" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">`); break
	                        case 'checkbox': formFields.push(`<div data-index="${i}" class="flex items-center"><input type="checkbox" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"><label class="ml-2 block text-sm text-gray-900"></label></div>`); break
	                        case 'switch': formFields.push(`<div data-index="${i}" class="flex items-center"><label class="relative inline-flex items-center cursor-pointer"><input type="checkbox" class="sr-only peer"><div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div></label></div>`); break
	                        case 'select': formFields.push(`<select data-index="${i}" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"></select>`); break
	                        case 'code': formFields.push(`<div data-index="${i}"></div>`); break
	                        case 'button': formFields.push(`<button data-index="${i}" class="px-4 py-2 bg-blue-500 text-white text-base font-medium rounded-md shadow-sm hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-300"></button>`); break
	                        default: throw new Error(JSON.stringify(o))
	                    }
	                }

	                /** @type{*} */
	                // @ts-ignore
	                let dialog = toDom(`
                    <div>
                        ${formFields.join('')}
                        <button class="search px-4 py-2 bg-blue-500 text-white text-base font-medium rounded-md shadow-sm hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-300">
                            ${cfgs.confirm}
                        </button>
                    </div>
                `);

	                if (cfgs.minWidthRatio) dialog.style.cssText += ` --mdc-dialog-min-width: ${document.body.clientWidth * cfgs.minWidthRatio}px;`;

	                for (let i = 0; i < cfgs.forms.length; i++) {
	                    const o = cfgs.forms[i];
	                    /** @type{HTMLElement} */
	                    let dom = dialog.querySelector(`[data-index="${i}"]`);
	                    let radio = dom.querySelector('input[type="radio"]');
	                    let checkbox = dom.querySelector('input[type="checkbox"]');
	                    let switchDom = dom.querySelector('input[type="checkbox"].sr-only');
	                    let input = dom.querySelector('input');
	                    let label = dom.querySelector('label');
	                    let selectItem = null;

	                    if (o.key) dom.setAttribute('key', o.key);
	                    if (o.label) {
	                        dom.setAttribute('label', o.label);
	                        if (label) label.textContent = o.label;
	                    }
	                    if (o.value) dom.setAttribute('value', o.value);
	                    if (o.icon) dom.setAttribute('icon', o.icon);
	                    if (o.focus) dom.setAttribute('dialogInitialFocus', String(o.focus));
	                    if (o.width) dom.style.width = o.width;

	                    switch (o.type) {
	                        case 'br': break
	                        case 'input':
	                        case 'textarea':
	                        case 'date':
	                            if (o.inputType) input.setAttribute('type', o.inputType);
	                            if (o.value) input.value = o.value;
	                            break
	                        case 'radio':
	                            if (o.key) radio.setAttribute('key', o.key);
	                            if (o.key) radio.setAttribute('name', o.key);
	                            if (o.value) radio.setAttribute('value', o.value);
	                            if (o.checked) radio.setAttribute('checked', String(o.checked));
	                            break
	                        case 'button':
	                            if (o.onclick) dom.onclick = o.onclick;
	                            break
	                        case 'checkbox':
	                            if (o.key) checkbox.setAttribute('key', o.key);
	                            if (o.checked) checkbox.setAttribute('checked', String(o.checked));
	                            break
	                        case 'switch':
	                            if (o.key) switchDom.setAttribute('key', o.key);
	                            if (o.checked) switchDom.setAttribute('checked', String(o.checked));
	                            break
	                        case 'select':
	                            o.items.forEach(item => {
	                                selectItem = document.createElement('option');
	                                selectItem.textContent = item;
	                                selectItem.value = item;
	                                dom.append(selectItem);
	                            });
	                            // @ts-ignore
	                            if (o.value) dom.value = o.value;
	                            break
	                        default: throw new Error(JSON.stringify(o))
	                    }
	                }

	                let radios = dialog.querySelectorAll('input[type="radio"]');
	                let checkboxs = dialog.querySelectorAll('input[type="checkbox"]:not(.sr-only)');
	                let selects = dialog.querySelectorAll('select');
	                let switchs = dialog.querySelectorAll('input[type="checkbox"].sr-only');
	                let textfields = dialog.querySelectorAll('input[type="text"]');
	                let textareas = dialog.querySelectorAll('textarea');
	                let inputs = dialog.querySelectorAll('input[type="date"]');
	                let codes = dialog.querySelectorAll('.__editor__');
	                let button = dialog.querySelector('button.search');
	                button.addEventListener('click', () => {
	                    let obj = {};
	                    let eleHandler = o => {
	                        let key = o.getAttribute('key');
	                        let value = o.value;
	                        obj[key] = value;
	                    };
	                    let eleHandlerBool = o => {
	                        let key = o.getAttribute('key');
	                        let value = o.checked;
	                        obj[key] = value;
	                    };
	                    let eleHandlerCode = o => {
	                        let key = o.getAttribute('key');
	                        let value = o['__editor__'].getValue();
	                        obj[key] = value;
	                    };
	                    [...radios].filter(o => o.checked).forEach(eleHandler);
	                    [...checkboxs].forEach(eleHandlerBool);
	                    [...switchs].forEach(eleHandlerBool);
	                    [...textfields].forEach(eleHandler);
	                    [...textareas].forEach(eleHandler);
	                    [...inputs].forEach(eleHandler);
	                    [...selects].forEach(eleHandler);
	                    [...codes].forEach(eleHandlerCode);
	                    console.log(obj);
	                    cb(obj);
	                });
	                resolve(dialog);
	            })();
	        })
	    }

	    static showLoadingDialog() {
	        /** @type{*} */
	        // @ts-ignore
	        let dialog = toDom(`
        <div class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
            <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <div class="container">
                        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900 mx-auto"></div>
                    </div>
                </div>
            </div>
        </div>
      `);
	        /** @type{HTMLElement} */
	        let container = dialog.querySelector('.container');
	        container.style.width = '100%';
	        container.style.height = '100%';
	        container.style.display = 'flex';
	        container.style.justifyContent = 'center';
	        container.style.alignItems = 'center';
	        container.style.overflow = 'hidden';

	        let app = window['app'];
	        if (app?.layout?.currentContainer) {
	            app.layout.currentContainer.element.append(dialog);
	        } else {
	            document.body.appendChild(dialog);
	        }

	        return () => {
	            dialog.remove();
	        }
	    }
	}

	// generated during release, do not modify

	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined') {
		// @ts-expect-error
		((window.__svelte ??= {}).v ??= new Set()).add(PUBLIC_VERSION);
	}

	enable_legacy_mode_flag();

	var browser = {};

	var canPromise;
	var hasRequiredCanPromise;

	function requireCanPromise () {
		if (hasRequiredCanPromise) return canPromise;
		hasRequiredCanPromise = 1;
		// can-promise has a crash in some versions of react native that dont have
		// standard global objects
		// https://github.com/soldair/node-qrcode/issues/157

		canPromise = function () {
		  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then
		};
		return canPromise;
	}

	var qrcode = {};

	var utils$2 = {};

	var hasRequiredUtils$2;

	function requireUtils$2 () {
		if (hasRequiredUtils$2) return utils$2;
		hasRequiredUtils$2 = 1;
		let toSJISFunction;
		const CODEWORDS_COUNT = [
		  0, // Not used
		  26, 44, 70, 100, 134, 172, 196, 242, 292, 346,
		  404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,
		  1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,
		  2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706
		];

		/**
		 * Returns the QR Code size for the specified version
		 *
		 * @param  {Number} version QR Code version
		 * @return {Number}         size of QR code
		 */
		utils$2.getSymbolSize = function getSymbolSize (version) {
		  if (!version) throw new Error('"version" cannot be null or undefined')
		  if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40')
		  return version * 4 + 17
		};

		/**
		 * Returns the total number of codewords used to store data and EC information.
		 *
		 * @param  {Number} version QR Code version
		 * @return {Number}         Data length in bits
		 */
		utils$2.getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {
		  return CODEWORDS_COUNT[version]
		};

		/**
		 * Encode data with Bose-Chaudhuri-Hocquenghem
		 *
		 * @param  {Number} data Value to encode
		 * @return {Number}      Encoded value
		 */
		utils$2.getBCHDigit = function (data) {
		  let digit = 0;

		  while (data !== 0) {
		    digit++;
		    data >>>= 1;
		  }

		  return digit
		};

		utils$2.setToSJISFunction = function setToSJISFunction (f) {
		  if (typeof f !== 'function') {
		    throw new Error('"toSJISFunc" is not a valid function.')
		  }

		  toSJISFunction = f;
		};

		utils$2.isKanjiModeEnabled = function () {
		  return typeof toSJISFunction !== 'undefined'
		};

		utils$2.toSJIS = function toSJIS (kanji) {
		  return toSJISFunction(kanji)
		};
		return utils$2;
	}

	var errorCorrectionLevel = {};

	var hasRequiredErrorCorrectionLevel;

	function requireErrorCorrectionLevel () {
		if (hasRequiredErrorCorrectionLevel) return errorCorrectionLevel;
		hasRequiredErrorCorrectionLevel = 1;
		(function (exports) {
			exports.L = { bit: 1 };
			exports.M = { bit: 0 };
			exports.Q = { bit: 3 };
			exports.H = { bit: 2 };

			function fromString (string) {
			  if (typeof string !== 'string') {
			    throw new Error('Param is not a string')
			  }

			  const lcStr = string.toLowerCase();

			  switch (lcStr) {
			    case 'l':
			    case 'low':
			      return exports.L

			    case 'm':
			    case 'medium':
			      return exports.M

			    case 'q':
			    case 'quartile':
			      return exports.Q

			    case 'h':
			    case 'high':
			      return exports.H

			    default:
			      throw new Error('Unknown EC Level: ' + string)
			  }
			}

			exports.isValid = function isValid (level) {
			  return level && typeof level.bit !== 'undefined' &&
			    level.bit >= 0 && level.bit < 4
			};

			exports.from = function from (value, defaultValue) {
			  if (exports.isValid(value)) {
			    return value
			  }

			  try {
			    return fromString(value)
			  } catch (e) {
			    return defaultValue
			  }
			}; 
		} (errorCorrectionLevel));
		return errorCorrectionLevel;
	}

	var bitBuffer;
	var hasRequiredBitBuffer;

	function requireBitBuffer () {
		if (hasRequiredBitBuffer) return bitBuffer;
		hasRequiredBitBuffer = 1;
		function BitBuffer () {
		  this.buffer = [];
		  this.length = 0;
		}

		BitBuffer.prototype = {

		  get: function (index) {
		    const bufIndex = Math.floor(index / 8);
		    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1
		  },

		  put: function (num, length) {
		    for (let i = 0; i < length; i++) {
		      this.putBit(((num >>> (length - i - 1)) & 1) === 1);
		    }
		  },

		  getLengthInBits: function () {
		    return this.length
		  },

		  putBit: function (bit) {
		    const bufIndex = Math.floor(this.length / 8);
		    if (this.buffer.length <= bufIndex) {
		      this.buffer.push(0);
		    }

		    if (bit) {
		      this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
		    }

		    this.length++;
		  }
		};

		bitBuffer = BitBuffer;
		return bitBuffer;
	}

	/**
	 * Helper class to handle QR Code symbol modules
	 *
	 * @param {Number} size Symbol size
	 */

	var bitMatrix;
	var hasRequiredBitMatrix;

	function requireBitMatrix () {
		if (hasRequiredBitMatrix) return bitMatrix;
		hasRequiredBitMatrix = 1;
		function BitMatrix (size) {
		  if (!size || size < 1) {
		    throw new Error('BitMatrix size must be defined and greater than 0')
		  }

		  this.size = size;
		  this.data = new Uint8Array(size * size);
		  this.reservedBit = new Uint8Array(size * size);
		}

		/**
		 * Set bit value at specified location
		 * If reserved flag is set, this bit will be ignored during masking process
		 *
		 * @param {Number}  row
		 * @param {Number}  col
		 * @param {Boolean} value
		 * @param {Boolean} reserved
		 */
		BitMatrix.prototype.set = function (row, col, value, reserved) {
		  const index = row * this.size + col;
		  this.data[index] = value;
		  if (reserved) this.reservedBit[index] = true;
		};

		/**
		 * Returns bit value at specified location
		 *
		 * @param  {Number}  row
		 * @param  {Number}  col
		 * @return {Boolean}
		 */
		BitMatrix.prototype.get = function (row, col) {
		  return this.data[row * this.size + col]
		};

		/**
		 * Applies xor operator at specified location
		 * (used during masking process)
		 *
		 * @param {Number}  row
		 * @param {Number}  col
		 * @param {Boolean} value
		 */
		BitMatrix.prototype.xor = function (row, col, value) {
		  this.data[row * this.size + col] ^= value;
		};

		/**
		 * Check if bit at specified location is reserved
		 *
		 * @param {Number}   row
		 * @param {Number}   col
		 * @return {Boolean}
		 */
		BitMatrix.prototype.isReserved = function (row, col) {
		  return this.reservedBit[row * this.size + col]
		};

		bitMatrix = BitMatrix;
		return bitMatrix;
	}

	var alignmentPattern = {};

	/**
	 * Alignment pattern are fixed reference pattern in defined positions
	 * in a matrix symbology, which enables the decode software to re-synchronise
	 * the coordinate mapping of the image modules in the event of moderate amounts
	 * of distortion of the image.
	 *
	 * Alignment patterns are present only in QR Code symbols of version 2 or larger
	 * and their number depends on the symbol version.
	 */

	var hasRequiredAlignmentPattern;

	function requireAlignmentPattern () {
		if (hasRequiredAlignmentPattern) return alignmentPattern;
		hasRequiredAlignmentPattern = 1;
		(function (exports) {
			const getSymbolSize = requireUtils$2().getSymbolSize;

			/**
			 * Calculate the row/column coordinates of the center module of each alignment pattern
			 * for the specified QR Code version.
			 *
			 * The alignment patterns are positioned symmetrically on either side of the diagonal
			 * running from the top left corner of the symbol to the bottom right corner.
			 *
			 * Since positions are simmetrical only half of the coordinates are returned.
			 * Each item of the array will represent in turn the x and y coordinate.
			 * @see {@link getPositions}
			 *
			 * @param  {Number} version QR Code version
			 * @return {Array}          Array of coordinate
			 */
			exports.getRowColCoords = function getRowColCoords (version) {
			  if (version === 1) return []

			  const posCount = Math.floor(version / 7) + 2;
			  const size = getSymbolSize(version);
			  const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
			  const positions = [size - 7]; // Last coord is always (size - 7)

			  for (let i = 1; i < posCount - 1; i++) {
			    positions[i] = positions[i - 1] - intervals;
			  }

			  positions.push(6); // First coord is always 6

			  return positions.reverse()
			};

			/**
			 * Returns an array containing the positions of each alignment pattern.
			 * Each array's element represent the center point of the pattern as (x, y) coordinates
			 *
			 * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}
			 * and filtering out the items that overlaps with finder pattern
			 *
			 * @example
			 * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.
			 * The alignment patterns, therefore, are to be centered on (row, column)
			 * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).
			 * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns
			 * and are not therefore used for alignment patterns.
			 *
			 * let pos = getPositions(7)
			 * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]
			 *
			 * @param  {Number} version QR Code version
			 * @return {Array}          Array of coordinates
			 */
			exports.getPositions = function getPositions (version) {
			  const coords = [];
			  const pos = exports.getRowColCoords(version);
			  const posLength = pos.length;

			  for (let i = 0; i < posLength; i++) {
			    for (let j = 0; j < posLength; j++) {
			      // Skip if position is occupied by finder patterns
			      if ((i === 0 && j === 0) || // top-left
			          (i === 0 && j === posLength - 1) || // bottom-left
			          (i === posLength - 1 && j === 0)) { // top-right
			        continue
			      }

			      coords.push([pos[i], pos[j]]);
			    }
			  }

			  return coords
			}; 
		} (alignmentPattern));
		return alignmentPattern;
	}

	var finderPattern = {};

	var hasRequiredFinderPattern;

	function requireFinderPattern () {
		if (hasRequiredFinderPattern) return finderPattern;
		hasRequiredFinderPattern = 1;
		const getSymbolSize = requireUtils$2().getSymbolSize;
		const FINDER_PATTERN_SIZE = 7;

		/**
		 * Returns an array containing the positions of each finder pattern.
		 * Each array's element represent the top-left point of the pattern as (x, y) coordinates
		 *
		 * @param  {Number} version QR Code version
		 * @return {Array}          Array of coordinates
		 */
		finderPattern.getPositions = function getPositions (version) {
		  const size = getSymbolSize(version);

		  return [
		    // top-left
		    [0, 0],
		    // top-right
		    [size - FINDER_PATTERN_SIZE, 0],
		    // bottom-left
		    [0, size - FINDER_PATTERN_SIZE]
		  ]
		};
		return finderPattern;
	}

	var maskPattern = {};

	/**
	 * Data mask pattern reference
	 * @type {Object}
	 */

	var hasRequiredMaskPattern;

	function requireMaskPattern () {
		if (hasRequiredMaskPattern) return maskPattern;
		hasRequiredMaskPattern = 1;
		(function (exports) {
			exports.Patterns = {
			  PATTERN000: 0,
			  PATTERN001: 1,
			  PATTERN010: 2,
			  PATTERN011: 3,
			  PATTERN100: 4,
			  PATTERN101: 5,
			  PATTERN110: 6,
			  PATTERN111: 7
			};

			/**
			 * Weighted penalty scores for the undesirable features
			 * @type {Object}
			 */
			const PenaltyScores = {
			  N1: 3,
			  N2: 3,
			  N3: 40,
			  N4: 10
			};

			/**
			 * Check if mask pattern value is valid
			 *
			 * @param  {Number}  mask    Mask pattern
			 * @return {Boolean}         true if valid, false otherwise
			 */
			exports.isValid = function isValid (mask) {
			  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7
			};

			/**
			 * Returns mask pattern from a value.
			 * If value is not valid, returns undefined
			 *
			 * @param  {Number|String} value        Mask pattern value
			 * @return {Number}                     Valid mask pattern or undefined
			 */
			exports.from = function from (value) {
			  return exports.isValid(value) ? parseInt(value, 10) : undefined
			};

			/**
			* Find adjacent modules in row/column with the same color
			* and assign a penalty value.
			*
			* Points: N1 + i
			* i is the amount by which the number of adjacent modules of the same color exceeds 5
			*/
			exports.getPenaltyN1 = function getPenaltyN1 (data) {
			  const size = data.size;
			  let points = 0;
			  let sameCountCol = 0;
			  let sameCountRow = 0;
			  let lastCol = null;
			  let lastRow = null;

			  for (let row = 0; row < size; row++) {
			    sameCountCol = sameCountRow = 0;
			    lastCol = lastRow = null;

			    for (let col = 0; col < size; col++) {
			      let module = data.get(row, col);
			      if (module === lastCol) {
			        sameCountCol++;
			      } else {
			        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
			        lastCol = module;
			        sameCountCol = 1;
			      }

			      module = data.get(col, row);
			      if (module === lastRow) {
			        sameCountRow++;
			      } else {
			        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
			        lastRow = module;
			        sameCountRow = 1;
			      }
			    }

			    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
			    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
			  }

			  return points
			};

			/**
			 * Find 2x2 blocks with the same color and assign a penalty value
			 *
			 * Points: N2 * (m - 1) * (n - 1)
			 */
			exports.getPenaltyN2 = function getPenaltyN2 (data) {
			  const size = data.size;
			  let points = 0;

			  for (let row = 0; row < size - 1; row++) {
			    for (let col = 0; col < size - 1; col++) {
			      const last = data.get(row, col) +
			        data.get(row, col + 1) +
			        data.get(row + 1, col) +
			        data.get(row + 1, col + 1);

			      if (last === 4 || last === 0) points++;
			    }
			  }

			  return points * PenaltyScores.N2
			};

			/**
			 * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,
			 * preceded or followed by light area 4 modules wide
			 *
			 * Points: N3 * number of pattern found
			 */
			exports.getPenaltyN3 = function getPenaltyN3 (data) {
			  const size = data.size;
			  let points = 0;
			  let bitsCol = 0;
			  let bitsRow = 0;

			  for (let row = 0; row < size; row++) {
			    bitsCol = bitsRow = 0;
			    for (let col = 0; col < size; col++) {
			      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col);
			      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;

			      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row);
			      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;
			    }
			  }

			  return points * PenaltyScores.N3
			};

			/**
			 * Calculate proportion of dark modules in entire symbol
			 *
			 * Points: N4 * k
			 *
			 * k is the rating of the deviation of the proportion of dark modules
			 * in the symbol from 50% in steps of 5%
			 */
			exports.getPenaltyN4 = function getPenaltyN4 (data) {
			  let darkCount = 0;
			  const modulesCount = data.data.length;

			  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];

			  const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10);

			  return k * PenaltyScores.N4
			};

			/**
			 * Return mask value at given position
			 *
			 * @param  {Number} maskPattern Pattern reference value
			 * @param  {Number} i           Row
			 * @param  {Number} j           Column
			 * @return {Boolean}            Mask value
			 */
			function getMaskAt (maskPattern, i, j) {
			  switch (maskPattern) {
			    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0
			    case exports.Patterns.PATTERN001: return i % 2 === 0
			    case exports.Patterns.PATTERN010: return j % 3 === 0
			    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0
			    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0
			    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0
			    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0
			    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0

			    default: throw new Error('bad maskPattern:' + maskPattern)
			  }
			}

			/**
			 * Apply a mask pattern to a BitMatrix
			 *
			 * @param  {Number}    pattern Pattern reference number
			 * @param  {BitMatrix} data    BitMatrix data
			 */
			exports.applyMask = function applyMask (pattern, data) {
			  const size = data.size;

			  for (let col = 0; col < size; col++) {
			    for (let row = 0; row < size; row++) {
			      if (data.isReserved(row, col)) continue
			      data.xor(row, col, getMaskAt(pattern, row, col));
			    }
			  }
			};

			/**
			 * Returns the best mask pattern for data
			 *
			 * @param  {BitMatrix} data
			 * @return {Number} Mask pattern reference number
			 */
			exports.getBestMask = function getBestMask (data, setupFormatFunc) {
			  const numPatterns = Object.keys(exports.Patterns).length;
			  let bestPattern = 0;
			  let lowerPenalty = Infinity;

			  for (let p = 0; p < numPatterns; p++) {
			    setupFormatFunc(p);
			    exports.applyMask(p, data);

			    // Calculate penalty
			    const penalty =
			      exports.getPenaltyN1(data) +
			      exports.getPenaltyN2(data) +
			      exports.getPenaltyN3(data) +
			      exports.getPenaltyN4(data);

			    // Undo previously applied mask
			    exports.applyMask(p, data);

			    if (penalty < lowerPenalty) {
			      lowerPenalty = penalty;
			      bestPattern = p;
			    }
			  }

			  return bestPattern
			}; 
		} (maskPattern));
		return maskPattern;
	}

	var errorCorrectionCode = {};

	var hasRequiredErrorCorrectionCode;

	function requireErrorCorrectionCode () {
		if (hasRequiredErrorCorrectionCode) return errorCorrectionCode;
		hasRequiredErrorCorrectionCode = 1;
		const ECLevel = requireErrorCorrectionLevel();

		const EC_BLOCKS_TABLE = [
		// L  M  Q  H
		  1, 1, 1, 1,
		  1, 1, 1, 1,
		  1, 1, 2, 2,
		  1, 2, 2, 4,
		  1, 2, 4, 4,
		  2, 4, 4, 4,
		  2, 4, 6, 5,
		  2, 4, 6, 6,
		  2, 5, 8, 8,
		  4, 5, 8, 8,
		  4, 5, 8, 11,
		  4, 8, 10, 11,
		  4, 9, 12, 16,
		  4, 9, 16, 16,
		  6, 10, 12, 18,
		  6, 10, 17, 16,
		  6, 11, 16, 19,
		  6, 13, 18, 21,
		  7, 14, 21, 25,
		  8, 16, 20, 25,
		  8, 17, 23, 25,
		  9, 17, 23, 34,
		  9, 18, 25, 30,
		  10, 20, 27, 32,
		  12, 21, 29, 35,
		  12, 23, 34, 37,
		  12, 25, 34, 40,
		  13, 26, 35, 42,
		  14, 28, 38, 45,
		  15, 29, 40, 48,
		  16, 31, 43, 51,
		  17, 33, 45, 54,
		  18, 35, 48, 57,
		  19, 37, 51, 60,
		  19, 38, 53, 63,
		  20, 40, 56, 66,
		  21, 43, 59, 70,
		  22, 45, 62, 74,
		  24, 47, 65, 77,
		  25, 49, 68, 81
		];

		const EC_CODEWORDS_TABLE = [
		// L  M  Q  H
		  7, 10, 13, 17,
		  10, 16, 22, 28,
		  15, 26, 36, 44,
		  20, 36, 52, 64,
		  26, 48, 72, 88,
		  36, 64, 96, 112,
		  40, 72, 108, 130,
		  48, 88, 132, 156,
		  60, 110, 160, 192,
		  72, 130, 192, 224,
		  80, 150, 224, 264,
		  96, 176, 260, 308,
		  104, 198, 288, 352,
		  120, 216, 320, 384,
		  132, 240, 360, 432,
		  144, 280, 408, 480,
		  168, 308, 448, 532,
		  180, 338, 504, 588,
		  196, 364, 546, 650,
		  224, 416, 600, 700,
		  224, 442, 644, 750,
		  252, 476, 690, 816,
		  270, 504, 750, 900,
		  300, 560, 810, 960,
		  312, 588, 870, 1050,
		  336, 644, 952, 1110,
		  360, 700, 1020, 1200,
		  390, 728, 1050, 1260,
		  420, 784, 1140, 1350,
		  450, 812, 1200, 1440,
		  480, 868, 1290, 1530,
		  510, 924, 1350, 1620,
		  540, 980, 1440, 1710,
		  570, 1036, 1530, 1800,
		  570, 1064, 1590, 1890,
		  600, 1120, 1680, 1980,
		  630, 1204, 1770, 2100,
		  660, 1260, 1860, 2220,
		  720, 1316, 1950, 2310,
		  750, 1372, 2040, 2430
		];

		/**
		 * Returns the number of error correction block that the QR Code should contain
		 * for the specified version and error correction level.
		 *
		 * @param  {Number} version              QR Code version
		 * @param  {Number} errorCorrectionLevel Error correction level
		 * @return {Number}                      Number of error correction blocks
		 */
		errorCorrectionCode.getBlocksCount = function getBlocksCount (version, errorCorrectionLevel) {
		  switch (errorCorrectionLevel) {
		    case ECLevel.L:
		      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]
		    case ECLevel.M:
		      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]
		    case ECLevel.Q:
		      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]
		    case ECLevel.H:
		      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]
		    default:
		      return undefined
		  }
		};

		/**
		 * Returns the number of error correction codewords to use for the specified
		 * version and error correction level.
		 *
		 * @param  {Number} version              QR Code version
		 * @param  {Number} errorCorrectionLevel Error correction level
		 * @return {Number}                      Number of error correction codewords
		 */
		errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount (version, errorCorrectionLevel) {
		  switch (errorCorrectionLevel) {
		    case ECLevel.L:
		      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]
		    case ECLevel.M:
		      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]
		    case ECLevel.Q:
		      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]
		    case ECLevel.H:
		      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]
		    default:
		      return undefined
		  }
		};
		return errorCorrectionCode;
	}

	var polynomial = {};

	var galoisField = {};

	var hasRequiredGaloisField;

	function requireGaloisField () {
		if (hasRequiredGaloisField) return galoisField;
		hasRequiredGaloisField = 1;
		const EXP_TABLE = new Uint8Array(512);
		const LOG_TABLE = new Uint8Array(256)
		/**
		 * Precompute the log and anti-log tables for faster computation later
		 *
		 * For each possible value in the galois field 2^8, we will pre-compute
		 * the logarithm and anti-logarithm (exponential) of this value
		 *
		 * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}
		 */
		;(function initTables () {
		  let x = 1;
		  for (let i = 0; i < 255; i++) {
		    EXP_TABLE[i] = x;
		    LOG_TABLE[x] = i;

		    x <<= 1; // multiply by 2

		    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.
		    // This means that when a number is 256 or larger, it should be XORed with 0x11D.
		    if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)
		      x ^= 0x11D;
		    }
		  }

		  // Optimization: double the size of the anti-log table so that we don't need to mod 255 to
		  // stay inside the bounds (because we will mainly use this table for the multiplication of
		  // two GF numbers, no more).
		  // @see {@link mul}
		  for (let i = 255; i < 512; i++) {
		    EXP_TABLE[i] = EXP_TABLE[i - 255];
		  }
		}());

		/**
		 * Returns log value of n inside Galois Field
		 *
		 * @param  {Number} n
		 * @return {Number}
		 */
		galoisField.log = function log (n) {
		  if (n < 1) throw new Error('log(' + n + ')')
		  return LOG_TABLE[n]
		};

		/**
		 * Returns anti-log value of n inside Galois Field
		 *
		 * @param  {Number} n
		 * @return {Number}
		 */
		galoisField.exp = function exp (n) {
		  return EXP_TABLE[n]
		};

		/**
		 * Multiplies two number inside Galois Field
		 *
		 * @param  {Number} x
		 * @param  {Number} y
		 * @return {Number}
		 */
		galoisField.mul = function mul (x, y) {
		  if (x === 0 || y === 0) return 0

		  // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized
		  // @see {@link initTables}
		  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]
		};
		return galoisField;
	}

	var hasRequiredPolynomial;

	function requirePolynomial () {
		if (hasRequiredPolynomial) return polynomial;
		hasRequiredPolynomial = 1;
		(function (exports) {
			const GF = requireGaloisField();

			/**
			 * Multiplies two polynomials inside Galois Field
			 *
			 * @param  {Uint8Array} p1 Polynomial
			 * @param  {Uint8Array} p2 Polynomial
			 * @return {Uint8Array}    Product of p1 and p2
			 */
			exports.mul = function mul (p1, p2) {
			  const coeff = new Uint8Array(p1.length + p2.length - 1);

			  for (let i = 0; i < p1.length; i++) {
			    for (let j = 0; j < p2.length; j++) {
			      coeff[i + j] ^= GF.mul(p1[i], p2[j]);
			    }
			  }

			  return coeff
			};

			/**
			 * Calculate the remainder of polynomials division
			 *
			 * @param  {Uint8Array} divident Polynomial
			 * @param  {Uint8Array} divisor  Polynomial
			 * @return {Uint8Array}          Remainder
			 */
			exports.mod = function mod (divident, divisor) {
			  let result = new Uint8Array(divident);

			  while ((result.length - divisor.length) >= 0) {
			    const coeff = result[0];

			    for (let i = 0; i < divisor.length; i++) {
			      result[i] ^= GF.mul(divisor[i], coeff);
			    }

			    // remove all zeros from buffer head
			    let offset = 0;
			    while (offset < result.length && result[offset] === 0) offset++;
			    result = result.slice(offset);
			  }

			  return result
			};

			/**
			 * Generate an irreducible generator polynomial of specified degree
			 * (used by Reed-Solomon encoder)
			 *
			 * @param  {Number} degree Degree of the generator polynomial
			 * @return {Uint8Array}    Buffer containing polynomial coefficients
			 */
			exports.generateECPolynomial = function generateECPolynomial (degree) {
			  let poly = new Uint8Array([1]);
			  for (let i = 0; i < degree; i++) {
			    poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
			  }

			  return poly
			}; 
		} (polynomial));
		return polynomial;
	}

	var reedSolomonEncoder;
	var hasRequiredReedSolomonEncoder;

	function requireReedSolomonEncoder () {
		if (hasRequiredReedSolomonEncoder) return reedSolomonEncoder;
		hasRequiredReedSolomonEncoder = 1;
		const Polynomial = requirePolynomial();

		function ReedSolomonEncoder (degree) {
		  this.genPoly = undefined;
		  this.degree = degree;

		  if (this.degree) this.initialize(this.degree);
		}

		/**
		 * Initialize the encoder.
		 * The input param should correspond to the number of error correction codewords.
		 *
		 * @param  {Number} degree
		 */
		ReedSolomonEncoder.prototype.initialize = function initialize (degree) {
		  // create an irreducible generator polynomial
		  this.degree = degree;
		  this.genPoly = Polynomial.generateECPolynomial(this.degree);
		};

		/**
		 * Encodes a chunk of data
		 *
		 * @param  {Uint8Array} data Buffer containing input data
		 * @return {Uint8Array}      Buffer containing encoded data
		 */
		ReedSolomonEncoder.prototype.encode = function encode (data) {
		  if (!this.genPoly) {
		    throw new Error('Encoder not initialized')
		  }

		  // Calculate EC for this data block
		  // extends data size to data+genPoly size
		  const paddedData = new Uint8Array(data.length + this.degree);
		  paddedData.set(data);

		  // The error correction codewords are the remainder after dividing the data codewords
		  // by a generator polynomial
		  const remainder = Polynomial.mod(paddedData, this.genPoly);

		  // return EC data blocks (last n byte, where n is the degree of genPoly)
		  // If coefficients number in remainder are less than genPoly degree,
		  // pad with 0s to the left to reach the needed number of coefficients
		  const start = this.degree - remainder.length;
		  if (start > 0) {
		    const buff = new Uint8Array(this.degree);
		    buff.set(remainder, start);

		    return buff
		  }

		  return remainder
		};

		reedSolomonEncoder = ReedSolomonEncoder;
		return reedSolomonEncoder;
	}

	var version = {};

	var mode = {};

	var versionCheck = {};

	/**
	 * Check if QR Code version is valid
	 *
	 * @param  {Number}  version QR Code version
	 * @return {Boolean}         true if valid version, false otherwise
	 */

	var hasRequiredVersionCheck;

	function requireVersionCheck () {
		if (hasRequiredVersionCheck) return versionCheck;
		hasRequiredVersionCheck = 1;
		versionCheck.isValid = function isValid (version) {
		  return !isNaN(version) && version >= 1 && version <= 40
		};
		return versionCheck;
	}

	var regex$1 = {};

	var hasRequiredRegex;

	function requireRegex () {
		if (hasRequiredRegex) return regex$1;
		hasRequiredRegex = 1;
		const numeric = '[0-9]+';
		const alphanumeric = '[A-Z $%*+\\-./:]+';
		let kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +
		  '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +
		  '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +
		  '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';
		kanji = kanji.replace(/u/g, '\\u');

		const byte = '(?:(?![A-Z0-9 $%*+\\-./:]|' + kanji + ')(?:.|[\r\n]))+';

		regex$1.KANJI = new RegExp(kanji, 'g');
		regex$1.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\-./:]+', 'g');
		regex$1.BYTE = new RegExp(byte, 'g');
		regex$1.NUMERIC = new RegExp(numeric, 'g');
		regex$1.ALPHANUMERIC = new RegExp(alphanumeric, 'g');

		const TEST_KANJI = new RegExp('^' + kanji + '$');
		const TEST_NUMERIC = new RegExp('^' + numeric + '$');
		const TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\-./:]+$');

		regex$1.testKanji = function testKanji (str) {
		  return TEST_KANJI.test(str)
		};

		regex$1.testNumeric = function testNumeric (str) {
		  return TEST_NUMERIC.test(str)
		};

		regex$1.testAlphanumeric = function testAlphanumeric (str) {
		  return TEST_ALPHANUMERIC.test(str)
		};
		return regex$1;
	}

	var hasRequiredMode;

	function requireMode () {
		if (hasRequiredMode) return mode;
		hasRequiredMode = 1;
		(function (exports) {
			const VersionCheck = requireVersionCheck();
			const Regex = requireRegex();

			/**
			 * Numeric mode encodes data from the decimal digit set (0 - 9)
			 * (byte values 30HEX to 39HEX).
			 * Normally, 3 data characters are represented by 10 bits.
			 *
			 * @type {Object}
			 */
			exports.NUMERIC = {
			  id: 'Numeric',
			  bit: 1 << 0,
			  ccBits: [10, 12, 14]
			};

			/**
			 * Alphanumeric mode encodes data from a set of 45 characters,
			 * i.e. 10 numeric digits (0 - 9),
			 *      26 alphabetic characters (A - Z),
			 *   and 9 symbols (SP, $, %, *, +, -, ., /, :).
			 * Normally, two input characters are represented by 11 bits.
			 *
			 * @type {Object}
			 */
			exports.ALPHANUMERIC = {
			  id: 'Alphanumeric',
			  bit: 1 << 1,
			  ccBits: [9, 11, 13]
			};

			/**
			 * In byte mode, data is encoded at 8 bits per character.
			 *
			 * @type {Object}
			 */
			exports.BYTE = {
			  id: 'Byte',
			  bit: 1 << 2,
			  ccBits: [8, 16, 16]
			};

			/**
			 * The Kanji mode efficiently encodes Kanji characters in accordance with
			 * the Shift JIS system based on JIS X 0208.
			 * The Shift JIS values are shifted from the JIS X 0208 values.
			 * JIS X 0208 gives details of the shift coded representation.
			 * Each two-byte character value is compacted to a 13-bit binary codeword.
			 *
			 * @type {Object}
			 */
			exports.KANJI = {
			  id: 'Kanji',
			  bit: 1 << 3,
			  ccBits: [8, 10, 12]
			};

			/**
			 * Mixed mode will contain a sequences of data in a combination of any of
			 * the modes described above
			 *
			 * @type {Object}
			 */
			exports.MIXED = {
			  bit: -1
			};

			/**
			 * Returns the number of bits needed to store the data length
			 * according to QR Code specifications.
			 *
			 * @param  {Mode}   mode    Data mode
			 * @param  {Number} version QR Code version
			 * @return {Number}         Number of bits
			 */
			exports.getCharCountIndicator = function getCharCountIndicator (mode, version) {
			  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)

			  if (!VersionCheck.isValid(version)) {
			    throw new Error('Invalid version: ' + version)
			  }

			  if (version >= 1 && version < 10) return mode.ccBits[0]
			  else if (version < 27) return mode.ccBits[1]
			  return mode.ccBits[2]
			};

			/**
			 * Returns the most efficient mode to store the specified data
			 *
			 * @param  {String} dataStr Input data string
			 * @return {Mode}           Best mode
			 */
			exports.getBestModeForData = function getBestModeForData (dataStr) {
			  if (Regex.testNumeric(dataStr)) return exports.NUMERIC
			  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC
			  else if (Regex.testKanji(dataStr)) return exports.KANJI
			  else return exports.BYTE
			};

			/**
			 * Return mode name as string
			 *
			 * @param {Mode} mode Mode object
			 * @returns {String}  Mode name
			 */
			exports.toString = function toString (mode) {
			  if (mode && mode.id) return mode.id
			  throw new Error('Invalid mode')
			};

			/**
			 * Check if input param is a valid mode object
			 *
			 * @param   {Mode}    mode Mode object
			 * @returns {Boolean} True if valid mode, false otherwise
			 */
			exports.isValid = function isValid (mode) {
			  return mode && mode.bit && mode.ccBits
			};

			/**
			 * Get mode object from its name
			 *
			 * @param   {String} string Mode name
			 * @returns {Mode}          Mode object
			 */
			function fromString (string) {
			  if (typeof string !== 'string') {
			    throw new Error('Param is not a string')
			  }

			  const lcStr = string.toLowerCase();

			  switch (lcStr) {
			    case 'numeric':
			      return exports.NUMERIC
			    case 'alphanumeric':
			      return exports.ALPHANUMERIC
			    case 'kanji':
			      return exports.KANJI
			    case 'byte':
			      return exports.BYTE
			    default:
			      throw new Error('Unknown mode: ' + string)
			  }
			}

			/**
			 * Returns mode from a value.
			 * If value is not a valid mode, returns defaultValue
			 *
			 * @param  {Mode|String} value        Encoding mode
			 * @param  {Mode}        defaultValue Fallback value
			 * @return {Mode}                     Encoding mode
			 */
			exports.from = function from (value, defaultValue) {
			  if (exports.isValid(value)) {
			    return value
			  }

			  try {
			    return fromString(value)
			  } catch (e) {
			    return defaultValue
			  }
			}; 
		} (mode));
		return mode;
	}

	var hasRequiredVersion;

	function requireVersion () {
		if (hasRequiredVersion) return version;
		hasRequiredVersion = 1;
		(function (exports) {
			const Utils = requireUtils$2();
			const ECCode = requireErrorCorrectionCode();
			const ECLevel = requireErrorCorrectionLevel();
			const Mode = requireMode();
			const VersionCheck = requireVersionCheck();

			// Generator polynomial used to encode version information
			const G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
			const G18_BCH = Utils.getBCHDigit(G18);

			function getBestVersionForDataLength (mode, length, errorCorrectionLevel) {
			  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
			    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
			      return currentVersion
			    }
			  }

			  return undefined
			}

			function getReservedBitsCount (mode, version) {
			  // Character count indicator + mode indicator bits
			  return Mode.getCharCountIndicator(mode, version) + 4
			}

			function getTotalBitsFromDataArray (segments, version) {
			  let totalBits = 0;

			  segments.forEach(function (data) {
			    const reservedBits = getReservedBitsCount(data.mode, version);
			    totalBits += reservedBits + data.getBitsLength();
			  });

			  return totalBits
			}

			function getBestVersionForMixedData (segments, errorCorrectionLevel) {
			  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
			    const length = getTotalBitsFromDataArray(segments, currentVersion);
			    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
			      return currentVersion
			    }
			  }

			  return undefined
			}

			/**
			 * Returns version number from a value.
			 * If value is not a valid version, returns defaultValue
			 *
			 * @param  {Number|String} value        QR Code version
			 * @param  {Number}        defaultValue Fallback value
			 * @return {Number}                     QR Code version number
			 */
			exports.from = function from (value, defaultValue) {
			  if (VersionCheck.isValid(value)) {
			    return parseInt(value, 10)
			  }

			  return defaultValue
			};

			/**
			 * Returns how much data can be stored with the specified QR code version
			 * and error correction level
			 *
			 * @param  {Number} version              QR Code version (1-40)
			 * @param  {Number} errorCorrectionLevel Error correction level
			 * @param  {Mode}   mode                 Data mode
			 * @return {Number}                      Quantity of storable data
			 */
			exports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {
			  if (!VersionCheck.isValid(version)) {
			    throw new Error('Invalid QR Code version')
			  }

			  // Use Byte mode as default
			  if (typeof mode === 'undefined') mode = Mode.BYTE;

			  // Total codewords for this QR code version (Data + Error correction)
			  const totalCodewords = Utils.getSymbolTotalCodewords(version);

			  // Total number of error correction codewords
			  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);

			  // Total number of data codewords
			  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;

			  if (mode === Mode.MIXED) return dataTotalCodewordsBits

			  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);

			  // Return max number of storable codewords
			  switch (mode) {
			    case Mode.NUMERIC:
			      return Math.floor((usableBits / 10) * 3)

			    case Mode.ALPHANUMERIC:
			      return Math.floor((usableBits / 11) * 2)

			    case Mode.KANJI:
			      return Math.floor(usableBits / 13)

			    case Mode.BYTE:
			    default:
			      return Math.floor(usableBits / 8)
			  }
			};

			/**
			 * Returns the minimum version needed to contain the amount of data
			 *
			 * @param  {Segment} data                    Segment of data
			 * @param  {Number} [errorCorrectionLevel=H] Error correction level
			 * @param  {Mode} mode                       Data mode
			 * @return {Number}                          QR Code version
			 */
			exports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {
			  let seg;

			  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);

			  if (Array.isArray(data)) {
			    if (data.length > 1) {
			      return getBestVersionForMixedData(data, ecl)
			    }

			    if (data.length === 0) {
			      return 1
			    }

			    seg = data[0];
			  } else {
			    seg = data;
			  }

			  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)
			};

			/**
			 * Returns version information with relative error correction bits
			 *
			 * The version information is included in QR Code symbols of version 7 or larger.
			 * It consists of an 18-bit sequence containing 6 data bits,
			 * with 12 error correction bits calculated using the (18, 6) Golay code.
			 *
			 * @param  {Number} version QR Code version
			 * @return {Number}         Encoded version info bits
			 */
			exports.getEncodedBits = function getEncodedBits (version) {
			  if (!VersionCheck.isValid(version) || version < 7) {
			    throw new Error('Invalid QR Code version')
			  }

			  let d = version << 12;

			  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
			    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH));
			  }

			  return (version << 12) | d
			}; 
		} (version));
		return version;
	}

	var formatInfo = {};

	var hasRequiredFormatInfo;

	function requireFormatInfo () {
		if (hasRequiredFormatInfo) return formatInfo;
		hasRequiredFormatInfo = 1;
		const Utils = requireUtils$2();

		const G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
		const G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);
		const G15_BCH = Utils.getBCHDigit(G15);

		/**
		 * Returns format information with relative error correction bits
		 *
		 * The format information is a 15-bit sequence containing 5 data bits,
		 * with 10 error correction bits calculated using the (15, 5) BCH code.
		 *
		 * @param  {Number} errorCorrectionLevel Error correction level
		 * @param  {Number} mask                 Mask pattern
		 * @return {Number}                      Encoded format information bits
		 */
		formatInfo.getEncodedBits = function getEncodedBits (errorCorrectionLevel, mask) {
		  const data = ((errorCorrectionLevel.bit << 3) | mask);
		  let d = data << 10;

		  while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
		    d ^= (G15 << (Utils.getBCHDigit(d) - G15_BCH));
		  }

		  // xor final data with mask pattern in order to ensure that
		  // no combination of Error Correction Level and data mask pattern
		  // will result in an all-zero data string
		  return ((data << 10) | d) ^ G15_MASK
		};
		return formatInfo;
	}

	var segments = {};

	var numericData;
	var hasRequiredNumericData;

	function requireNumericData () {
		if (hasRequiredNumericData) return numericData;
		hasRequiredNumericData = 1;
		const Mode = requireMode();

		function NumericData (data) {
		  this.mode = Mode.NUMERIC;
		  this.data = data.toString();
		}

		NumericData.getBitsLength = function getBitsLength (length) {
		  return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)
		};

		NumericData.prototype.getLength = function getLength () {
		  return this.data.length
		};

		NumericData.prototype.getBitsLength = function getBitsLength () {
		  return NumericData.getBitsLength(this.data.length)
		};

		NumericData.prototype.write = function write (bitBuffer) {
		  let i, group, value;

		  // The input data string is divided into groups of three digits,
		  // and each group is converted to its 10-bit binary equivalent.
		  for (i = 0; i + 3 <= this.data.length; i += 3) {
		    group = this.data.substr(i, 3);
		    value = parseInt(group, 10);

		    bitBuffer.put(value, 10);
		  }

		  // If the number of input digits is not an exact multiple of three,
		  // the final one or two digits are converted to 4 or 7 bits respectively.
		  const remainingNum = this.data.length - i;
		  if (remainingNum > 0) {
		    group = this.data.substr(i);
		    value = parseInt(group, 10);

		    bitBuffer.put(value, remainingNum * 3 + 1);
		  }
		};

		numericData = NumericData;
		return numericData;
	}

	var alphanumericData;
	var hasRequiredAlphanumericData;

	function requireAlphanumericData () {
		if (hasRequiredAlphanumericData) return alphanumericData;
		hasRequiredAlphanumericData = 1;
		const Mode = requireMode();

		/**
		 * Array of characters available in alphanumeric mode
		 *
		 * As per QR Code specification, to each character
		 * is assigned a value from 0 to 44 which in this case coincides
		 * with the array index
		 *
		 * @type {Array}
		 */
		const ALPHA_NUM_CHARS = [
		  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
		  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
		  ' ', '$', '%', '*', '+', '-', '.', '/', ':'
		];

		function AlphanumericData (data) {
		  this.mode = Mode.ALPHANUMERIC;
		  this.data = data;
		}

		AlphanumericData.getBitsLength = function getBitsLength (length) {
		  return 11 * Math.floor(length / 2) + 6 * (length % 2)
		};

		AlphanumericData.prototype.getLength = function getLength () {
		  return this.data.length
		};

		AlphanumericData.prototype.getBitsLength = function getBitsLength () {
		  return AlphanumericData.getBitsLength(this.data.length)
		};

		AlphanumericData.prototype.write = function write (bitBuffer) {
		  let i;

		  // Input data characters are divided into groups of two characters
		  // and encoded as 11-bit binary codes.
		  for (i = 0; i + 2 <= this.data.length; i += 2) {
		    // The character value of the first character is multiplied by 45
		    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;

		    // The character value of the second digit is added to the product
		    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);

		    // The sum is then stored as 11-bit binary number
		    bitBuffer.put(value, 11);
		  }

		  // If the number of input data characters is not a multiple of two,
		  // the character value of the final character is encoded as a 6-bit binary number.
		  if (this.data.length % 2) {
		    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
		  }
		};

		alphanumericData = AlphanumericData;
		return alphanumericData;
	}

	var byteData;
	var hasRequiredByteData;

	function requireByteData () {
		if (hasRequiredByteData) return byteData;
		hasRequiredByteData = 1;
		const Mode = requireMode();

		function ByteData (data) {
		  this.mode = Mode.BYTE;
		  if (typeof (data) === 'string') {
		    this.data = new TextEncoder().encode(data);
		  } else {
		    this.data = new Uint8Array(data);
		  }
		}

		ByteData.getBitsLength = function getBitsLength (length) {
		  return length * 8
		};

		ByteData.prototype.getLength = function getLength () {
		  return this.data.length
		};

		ByteData.prototype.getBitsLength = function getBitsLength () {
		  return ByteData.getBitsLength(this.data.length)
		};

		ByteData.prototype.write = function (bitBuffer) {
		  for (let i = 0, l = this.data.length; i < l; i++) {
		    bitBuffer.put(this.data[i], 8);
		  }
		};

		byteData = ByteData;
		return byteData;
	}

	var kanjiData;
	var hasRequiredKanjiData;

	function requireKanjiData () {
		if (hasRequiredKanjiData) return kanjiData;
		hasRequiredKanjiData = 1;
		const Mode = requireMode();
		const Utils = requireUtils$2();

		function KanjiData (data) {
		  this.mode = Mode.KANJI;
		  this.data = data;
		}

		KanjiData.getBitsLength = function getBitsLength (length) {
		  return length * 13
		};

		KanjiData.prototype.getLength = function getLength () {
		  return this.data.length
		};

		KanjiData.prototype.getBitsLength = function getBitsLength () {
		  return KanjiData.getBitsLength(this.data.length)
		};

		KanjiData.prototype.write = function (bitBuffer) {
		  let i;

		  // In the Shift JIS system, Kanji characters are represented by a two byte combination.
		  // These byte values are shifted from the JIS X 0208 values.
		  // JIS X 0208 gives details of the shift coded representation.
		  for (i = 0; i < this.data.length; i++) {
		    let value = Utils.toSJIS(this.data[i]);

		    // For characters with Shift JIS values from 0x8140 to 0x9FFC:
		    if (value >= 0x8140 && value <= 0x9FFC) {
		      // Subtract 0x8140 from Shift JIS value
		      value -= 0x8140;

		    // For characters with Shift JIS values from 0xE040 to 0xEBBF
		    } else if (value >= 0xE040 && value <= 0xEBBF) {
		      // Subtract 0xC140 from Shift JIS value
		      value -= 0xC140;
		    } else {
		      throw new Error(
		        'Invalid SJIS character: ' + this.data[i] + '\n' +
		        'Make sure your charset is UTF-8')
		    }

		    // Multiply most significant byte of result by 0xC0
		    // and add least significant byte to product
		    value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff);

		    // Convert result to a 13-bit binary string
		    bitBuffer.put(value, 13);
		  }
		};

		kanjiData = KanjiData;
		return kanjiData;
	}

	var dijkstra = {exports: {}};

	var hasRequiredDijkstra;

	function requireDijkstra () {
		if (hasRequiredDijkstra) return dijkstra.exports;
		hasRequiredDijkstra = 1;
		(function (module) {

			/******************************************************************************
			 * Created 2008-08-19.
			 *
			 * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
			 *
			 * Copyright (C) 2008
			 *   Wyatt Baldwin <self@wyattbaldwin.com>
			 *   All rights reserved
			 *
			 * Licensed under the MIT license.
			 *
			 *   http://www.opensource.org/licenses/mit-license.php
			 *
			 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
			 * THE SOFTWARE.
			 *****************************************************************************/
			var dijkstra = {
			  single_source_shortest_paths: function(graph, s, d) {
			    // Predecessor map for each node that has been encountered.
			    // node ID => predecessor node ID
			    var predecessors = {};

			    // Costs of shortest paths from s to all nodes encountered.
			    // node ID => cost
			    var costs = {};
			    costs[s] = 0;

			    // Costs of shortest paths from s to all nodes encountered; differs from
			    // `costs` in that it provides easy access to the node that currently has
			    // the known shortest path from s.
			    // XXX: Do we actually need both `costs` and `open`?
			    var open = dijkstra.PriorityQueue.make();
			    open.push(s, 0);

			    var closest,
			        u, v,
			        cost_of_s_to_u,
			        adjacent_nodes,
			        cost_of_e,
			        cost_of_s_to_u_plus_cost_of_e,
			        cost_of_s_to_v,
			        first_visit;
			    while (!open.empty()) {
			      // In the nodes remaining in graph that have a known cost from s,
			      // find the node, u, that currently has the shortest path from s.
			      closest = open.pop();
			      u = closest.value;
			      cost_of_s_to_u = closest.cost;

			      // Get nodes adjacent to u...
			      adjacent_nodes = graph[u] || {};

			      // ...and explore the edges that connect u to those nodes, updating
			      // the cost of the shortest paths to any or all of those nodes as
			      // necessary. v is the node across the current edge from u.
			      for (v in adjacent_nodes) {
			        if (adjacent_nodes.hasOwnProperty(v)) {
			          // Get the cost of the edge running from u to v.
			          cost_of_e = adjacent_nodes[v];

			          // Cost of s to u plus the cost of u to v across e--this is *a*
			          // cost from s to v that may or may not be less than the current
			          // known cost to v.
			          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;

			          // If we haven't visited v yet OR if the current known cost from s to
			          // v is greater than the new cost we just found (cost of s to u plus
			          // cost of u to v across e), update v's cost in the cost list and
			          // update v's predecessor in the predecessor list (it's now u).
			          cost_of_s_to_v = costs[v];
			          first_visit = (typeof costs[v] === 'undefined');
			          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
			            costs[v] = cost_of_s_to_u_plus_cost_of_e;
			            open.push(v, cost_of_s_to_u_plus_cost_of_e);
			            predecessors[v] = u;
			          }
			        }
			      }
			    }

			    if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {
			      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
			      throw new Error(msg);
			    }

			    return predecessors;
			  },

			  extract_shortest_path_from_predecessor_list: function(predecessors, d) {
			    var nodes = [];
			    var u = d;
			    while (u) {
			      nodes.push(u);
			      predecessors[u];
			      u = predecessors[u];
			    }
			    nodes.reverse();
			    return nodes;
			  },

			  find_path: function(graph, s, d) {
			    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
			    return dijkstra.extract_shortest_path_from_predecessor_list(
			      predecessors, d);
			  },

			  /**
			   * A very naive priority queue implementation.
			   */
			  PriorityQueue: {
			    make: function (opts) {
			      var T = dijkstra.PriorityQueue,
			          t = {},
			          key;
			      opts = opts || {};
			      for (key in T) {
			        if (T.hasOwnProperty(key)) {
			          t[key] = T[key];
			        }
			      }
			      t.queue = [];
			      t.sorter = opts.sorter || T.default_sorter;
			      return t;
			    },

			    default_sorter: function (a, b) {
			      return a.cost - b.cost;
			    },

			    /**
			     * Add a new item to the queue and ensure the highest priority element
			     * is at the front of the queue.
			     */
			    push: function (value, cost) {
			      var item = {value: value, cost: cost};
			      this.queue.push(item);
			      this.queue.sort(this.sorter);
			    },

			    /**
			     * Return the highest priority element in the queue.
			     */
			    pop: function () {
			      return this.queue.shift();
			    },

			    empty: function () {
			      return this.queue.length === 0;
			    }
			  }
			};


			// node.js module exports
			{
			  module.exports = dijkstra;
			} 
		} (dijkstra));
		return dijkstra.exports;
	}

	var hasRequiredSegments;

	function requireSegments () {
		if (hasRequiredSegments) return segments;
		hasRequiredSegments = 1;
		(function (exports) {
			const Mode = requireMode();
			const NumericData = requireNumericData();
			const AlphanumericData = requireAlphanumericData();
			const ByteData = requireByteData();
			const KanjiData = requireKanjiData();
			const Regex = requireRegex();
			const Utils = requireUtils$2();
			const dijkstra = requireDijkstra();

			/**
			 * Returns UTF8 byte length
			 *
			 * @param  {String} str Input string
			 * @return {Number}     Number of byte
			 */
			function getStringByteLength (str) {
			  return unescape(encodeURIComponent(str)).length
			}

			/**
			 * Get a list of segments of the specified mode
			 * from a string
			 *
			 * @param  {Mode}   mode Segment mode
			 * @param  {String} str  String to process
			 * @return {Array}       Array of object with segments data
			 */
			function getSegments (regex, mode, str) {
			  const segments = [];
			  let result;

			  while ((result = regex.exec(str)) !== null) {
			    segments.push({
			      data: result[0],
			      index: result.index,
			      mode: mode,
			      length: result[0].length
			    });
			  }

			  return segments
			}

			/**
			 * Extracts a series of segments with the appropriate
			 * modes from a string
			 *
			 * @param  {String} dataStr Input string
			 * @return {Array}          Array of object with segments data
			 */
			function getSegmentsFromString (dataStr) {
			  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
			  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
			  let byteSegs;
			  let kanjiSegs;

			  if (Utils.isKanjiModeEnabled()) {
			    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
			    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
			  } else {
			    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
			    kanjiSegs = [];
			  }

			  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);

			  return segs
			    .sort(function (s1, s2) {
			      return s1.index - s2.index
			    })
			    .map(function (obj) {
			      return {
			        data: obj.data,
			        mode: obj.mode,
			        length: obj.length
			      }
			    })
			}

			/**
			 * Returns how many bits are needed to encode a string of
			 * specified length with the specified mode
			 *
			 * @param  {Number} length String length
			 * @param  {Mode} mode     Segment mode
			 * @return {Number}        Bit length
			 */
			function getSegmentBitsLength (length, mode) {
			  switch (mode) {
			    case Mode.NUMERIC:
			      return NumericData.getBitsLength(length)
			    case Mode.ALPHANUMERIC:
			      return AlphanumericData.getBitsLength(length)
			    case Mode.KANJI:
			      return KanjiData.getBitsLength(length)
			    case Mode.BYTE:
			      return ByteData.getBitsLength(length)
			  }
			}

			/**
			 * Merges adjacent segments which have the same mode
			 *
			 * @param  {Array} segs Array of object with segments data
			 * @return {Array}      Array of object with segments data
			 */
			function mergeSegments (segs) {
			  return segs.reduce(function (acc, curr) {
			    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
			    if (prevSeg && prevSeg.mode === curr.mode) {
			      acc[acc.length - 1].data += curr.data;
			      return acc
			    }

			    acc.push(curr);
			    return acc
			  }, [])
			}

			/**
			 * Generates a list of all possible nodes combination which
			 * will be used to build a segments graph.
			 *
			 * Nodes are divided by groups. Each group will contain a list of all the modes
			 * in which is possible to encode the given text.
			 *
			 * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.
			 * The group for '12345' will contain then 3 objects, one for each
			 * possible encoding mode.
			 *
			 * Each node represents a possible segment.
			 *
			 * @param  {Array} segs Array of object with segments data
			 * @return {Array}      Array of object with segments data
			 */
			function buildNodes (segs) {
			  const nodes = [];
			  for (let i = 0; i < segs.length; i++) {
			    const seg = segs[i];

			    switch (seg.mode) {
			      case Mode.NUMERIC:
			        nodes.push([seg,
			          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
			          { data: seg.data, mode: Mode.BYTE, length: seg.length }
			        ]);
			        break
			      case Mode.ALPHANUMERIC:
			        nodes.push([seg,
			          { data: seg.data, mode: Mode.BYTE, length: seg.length }
			        ]);
			        break
			      case Mode.KANJI:
			        nodes.push([seg,
			          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
			        ]);
			        break
			      case Mode.BYTE:
			        nodes.push([
			          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
			        ]);
			    }
			  }

			  return nodes
			}

			/**
			 * Builds a graph from a list of nodes.
			 * All segments in each node group will be connected with all the segments of
			 * the next group and so on.
			 *
			 * At each connection will be assigned a weight depending on the
			 * segment's byte length.
			 *
			 * @param  {Array} nodes    Array of object with segments data
			 * @param  {Number} version QR Code version
			 * @return {Object}         Graph of all possible segments
			 */
			function buildGraph (nodes, version) {
			  const table = {};
			  const graph = { start: {} };
			  let prevNodeIds = ['start'];

			  for (let i = 0; i < nodes.length; i++) {
			    const nodeGroup = nodes[i];
			    const currentNodeIds = [];

			    for (let j = 0; j < nodeGroup.length; j++) {
			      const node = nodeGroup[j];
			      const key = '' + i + j;

			      currentNodeIds.push(key);
			      table[key] = { node: node, lastCount: 0 };
			      graph[key] = {};

			      for (let n = 0; n < prevNodeIds.length; n++) {
			        const prevNodeId = prevNodeIds[n];

			        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
			          graph[prevNodeId][key] =
			            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -
			            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);

			          table[prevNodeId].lastCount += node.length;
			        } else {
			          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;

			          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +
			            4 + Mode.getCharCountIndicator(node.mode, version); // switch cost
			        }
			      }
			    }

			    prevNodeIds = currentNodeIds;
			  }

			  for (let n = 0; n < prevNodeIds.length; n++) {
			    graph[prevNodeIds[n]].end = 0;
			  }

			  return { map: graph, table: table }
			}

			/**
			 * Builds a segment from a specified data and mode.
			 * If a mode is not specified, the more suitable will be used.
			 *
			 * @param  {String} data             Input data
			 * @param  {Mode | String} modesHint Data mode
			 * @return {Segment}                 Segment
			 */
			function buildSingleSegment (data, modesHint) {
			  let mode;
			  const bestMode = Mode.getBestModeForData(data);

			  mode = Mode.from(modesHint, bestMode);

			  // Make sure data can be encoded
			  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
			    throw new Error('"' + data + '"' +
			      ' cannot be encoded with mode ' + Mode.toString(mode) +
			      '.\n Suggested mode is: ' + Mode.toString(bestMode))
			  }

			  // Use Mode.BYTE if Kanji support is disabled
			  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
			    mode = Mode.BYTE;
			  }

			  switch (mode) {
			    case Mode.NUMERIC:
			      return new NumericData(data)

			    case Mode.ALPHANUMERIC:
			      return new AlphanumericData(data)

			    case Mode.KANJI:
			      return new KanjiData(data)

			    case Mode.BYTE:
			      return new ByteData(data)
			  }
			}

			/**
			 * Builds a list of segments from an array.
			 * Array can contain Strings or Objects with segment's info.
			 *
			 * For each item which is a string, will be generated a segment with the given
			 * string and the more appropriate encoding mode.
			 *
			 * For each item which is an object, will be generated a segment with the given
			 * data and mode.
			 * Objects must contain at least the property "data".
			 * If property "mode" is not present, the more suitable mode will be used.
			 *
			 * @param  {Array} array Array of objects with segments data
			 * @return {Array}       Array of Segments
			 */
			exports.fromArray = function fromArray (array) {
			  return array.reduce(function (acc, seg) {
			    if (typeof seg === 'string') {
			      acc.push(buildSingleSegment(seg, null));
			    } else if (seg.data) {
			      acc.push(buildSingleSegment(seg.data, seg.mode));
			    }

			    return acc
			  }, [])
			};

			/**
			 * Builds an optimized sequence of segments from a string,
			 * which will produce the shortest possible bitstream.
			 *
			 * @param  {String} data    Input string
			 * @param  {Number} version QR Code version
			 * @return {Array}          Array of segments
			 */
			exports.fromString = function fromString (data, version) {
			  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());

			  const nodes = buildNodes(segs);
			  const graph = buildGraph(nodes, version);
			  const path = dijkstra.find_path(graph.map, 'start', 'end');

			  const optimizedSegs = [];
			  for (let i = 1; i < path.length - 1; i++) {
			    optimizedSegs.push(graph.table[path[i]].node);
			  }

			  return exports.fromArray(mergeSegments(optimizedSegs))
			};

			/**
			 * Splits a string in various segments with the modes which
			 * best represent their content.
			 * The produced segments are far from being optimized.
			 * The output of this function is only used to estimate a QR Code version
			 * which may contain the data.
			 *
			 * @param  {string} data Input string
			 * @return {Array}       Array of segments
			 */
			exports.rawSplit = function rawSplit (data) {
			  return exports.fromArray(
			    getSegmentsFromString(data, Utils.isKanjiModeEnabled())
			  )
			}; 
		} (segments));
		return segments;
	}

	var hasRequiredQrcode;

	function requireQrcode () {
		if (hasRequiredQrcode) return qrcode;
		hasRequiredQrcode = 1;
		const Utils = requireUtils$2();
		const ECLevel = requireErrorCorrectionLevel();
		const BitBuffer = requireBitBuffer();
		const BitMatrix = requireBitMatrix();
		const AlignmentPattern = requireAlignmentPattern();
		const FinderPattern = requireFinderPattern();
		const MaskPattern = requireMaskPattern();
		const ECCode = requireErrorCorrectionCode();
		const ReedSolomonEncoder = requireReedSolomonEncoder();
		const Version = requireVersion();
		const FormatInfo = requireFormatInfo();
		const Mode = requireMode();
		const Segments = requireSegments();

		/**
		 * QRCode for JavaScript
		 *
		 * modified by Ryan Day for nodejs support
		 * Copyright (c) 2011 Ryan Day
		 *
		 * Licensed under the MIT license:
		 *   http://www.opensource.org/licenses/mit-license.php
		 *
		//---------------------------------------------------------------------
		// QRCode for JavaScript
		//
		// Copyright (c) 2009 Kazuhiko Arase
		//
		// URL: http://www.d-project.com/
		//
		// Licensed under the MIT license:
		//   http://www.opensource.org/licenses/mit-license.php
		//
		// The word "QR Code" is registered trademark of
		// DENSO WAVE INCORPORATED
		//   http://www.denso-wave.com/qrcode/faqpatent-e.html
		//
		//---------------------------------------------------------------------
		*/

		/**
		 * Add finder patterns bits to matrix
		 *
		 * @param  {BitMatrix} matrix  Modules matrix
		 * @param  {Number}    version QR Code version
		 */
		function setupFinderPattern (matrix, version) {
		  const size = matrix.size;
		  const pos = FinderPattern.getPositions(version);

		  for (let i = 0; i < pos.length; i++) {
		    const row = pos[i][0];
		    const col = pos[i][1];

		    for (let r = -1; r <= 7; r++) {
		      if (row + r <= -1 || size <= row + r) continue

		      for (let c = -1; c <= 7; c++) {
		        if (col + c <= -1 || size <= col + c) continue

		        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||
		          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||
		          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {
		          matrix.set(row + r, col + c, true, true);
		        } else {
		          matrix.set(row + r, col + c, false, true);
		        }
		      }
		    }
		  }
		}

		/**
		 * Add timing pattern bits to matrix
		 *
		 * Note: this function must be called before {@link setupAlignmentPattern}
		 *
		 * @param  {BitMatrix} matrix Modules matrix
		 */
		function setupTimingPattern (matrix) {
		  const size = matrix.size;

		  for (let r = 8; r < size - 8; r++) {
		    const value = r % 2 === 0;
		    matrix.set(r, 6, value, true);
		    matrix.set(6, r, value, true);
		  }
		}

		/**
		 * Add alignment patterns bits to matrix
		 *
		 * Note: this function must be called after {@link setupTimingPattern}
		 *
		 * @param  {BitMatrix} matrix  Modules matrix
		 * @param  {Number}    version QR Code version
		 */
		function setupAlignmentPattern (matrix, version) {
		  const pos = AlignmentPattern.getPositions(version);

		  for (let i = 0; i < pos.length; i++) {
		    const row = pos[i][0];
		    const col = pos[i][1];

		    for (let r = -2; r <= 2; r++) {
		      for (let c = -2; c <= 2; c++) {
		        if (r === -2 || r === 2 || c === -2 || c === 2 ||
		          (r === 0 && c === 0)) {
		          matrix.set(row + r, col + c, true, true);
		        } else {
		          matrix.set(row + r, col + c, false, true);
		        }
		      }
		    }
		  }
		}

		/**
		 * Add version info bits to matrix
		 *
		 * @param  {BitMatrix} matrix  Modules matrix
		 * @param  {Number}    version QR Code version
		 */
		function setupVersionInfo (matrix, version) {
		  const size = matrix.size;
		  const bits = Version.getEncodedBits(version);
		  let row, col, mod;

		  for (let i = 0; i < 18; i++) {
		    row = Math.floor(i / 3);
		    col = i % 3 + size - 8 - 3;
		    mod = ((bits >> i) & 1) === 1;

		    matrix.set(row, col, mod, true);
		    matrix.set(col, row, mod, true);
		  }
		}

		/**
		 * Add format info bits to matrix
		 *
		 * @param  {BitMatrix} matrix               Modules matrix
		 * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level
		 * @param  {Number}    maskPattern          Mask pattern reference value
		 */
		function setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {
		  const size = matrix.size;
		  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
		  let i, mod;

		  for (i = 0; i < 15; i++) {
		    mod = ((bits >> i) & 1) === 1;

		    // vertical
		    if (i < 6) {
		      matrix.set(i, 8, mod, true);
		    } else if (i < 8) {
		      matrix.set(i + 1, 8, mod, true);
		    } else {
		      matrix.set(size - 15 + i, 8, mod, true);
		    }

		    // horizontal
		    if (i < 8) {
		      matrix.set(8, size - i - 1, mod, true);
		    } else if (i < 9) {
		      matrix.set(8, 15 - i - 1 + 1, mod, true);
		    } else {
		      matrix.set(8, 15 - i - 1, mod, true);
		    }
		  }

		  // fixed module
		  matrix.set(size - 8, 8, 1, true);
		}

		/**
		 * Add encoded data bits to matrix
		 *
		 * @param  {BitMatrix}  matrix Modules matrix
		 * @param  {Uint8Array} data   Data codewords
		 */
		function setupData (matrix, data) {
		  const size = matrix.size;
		  let inc = -1;
		  let row = size - 1;
		  let bitIndex = 7;
		  let byteIndex = 0;

		  for (let col = size - 1; col > 0; col -= 2) {
		    if (col === 6) col--;

		    while (true) {
		      for (let c = 0; c < 2; c++) {
		        if (!matrix.isReserved(row, col - c)) {
		          let dark = false;

		          if (byteIndex < data.length) {
		            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);
		          }

		          matrix.set(row, col - c, dark);
		          bitIndex--;

		          if (bitIndex === -1) {
		            byteIndex++;
		            bitIndex = 7;
		          }
		        }
		      }

		      row += inc;

		      if (row < 0 || size <= row) {
		        row -= inc;
		        inc = -inc;
		        break
		      }
		    }
		  }
		}

		/**
		 * Create encoded codewords from data input
		 *
		 * @param  {Number}   version              QR Code version
		 * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level
		 * @param  {ByteData} data                 Data input
		 * @return {Uint8Array}                    Buffer containing encoded codewords
		 */
		function createData (version, errorCorrectionLevel, segments) {
		  // Prepare data buffer
		  const buffer = new BitBuffer();

		  segments.forEach(function (data) {
		    // prefix data with mode indicator (4 bits)
		    buffer.put(data.mode.bit, 4);

		    // Prefix data with character count indicator.
		    // The character count indicator is a string of bits that represents the
		    // number of characters that are being encoded.
		    // The character count indicator must be placed after the mode indicator
		    // and must be a certain number of bits long, depending on the QR version
		    // and data mode
		    // @see {@link Mode.getCharCountIndicator}.
		    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));

		    // add binary data sequence to buffer
		    data.write(buffer);
		  });

		  // Calculate required number of bits
		  const totalCodewords = Utils.getSymbolTotalCodewords(version);
		  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
		  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;

		  // Add a terminator.
		  // If the bit string is shorter than the total number of required bits,
		  // a terminator of up to four 0s must be added to the right side of the string.
		  // If the bit string is more than four bits shorter than the required number of bits,
		  // add four 0s to the end.
		  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
		    buffer.put(0, 4);
		  }

		  // If the bit string is fewer than four bits shorter, add only the number of 0s that
		  // are needed to reach the required number of bits.

		  // After adding the terminator, if the number of bits in the string is not a multiple of 8,
		  // pad the string on the right with 0s to make the string's length a multiple of 8.
		  while (buffer.getLengthInBits() % 8 !== 0) {
		    buffer.putBit(0);
		  }

		  // Add pad bytes if the string is still shorter than the total number of required bits.
		  // Extend the buffer to fill the data capacity of the symbol corresponding to
		  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)
		  // and 00010001 (0x11) alternately.
		  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
		  for (let i = 0; i < remainingByte; i++) {
		    buffer.put(i % 2 ? 0x11 : 0xEC, 8);
		  }

		  return createCodewords(buffer, version, errorCorrectionLevel)
		}

		/**
		 * Encode input data with Reed-Solomon and return codewords with
		 * relative error correction bits
		 *
		 * @param  {BitBuffer} bitBuffer            Data to encode
		 * @param  {Number}    version              QR Code version
		 * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level
		 * @return {Uint8Array}                     Buffer containing encoded codewords
		 */
		function createCodewords (bitBuffer, version, errorCorrectionLevel) {
		  // Total codewords for this QR code version (Data + Error correction)
		  const totalCodewords = Utils.getSymbolTotalCodewords(version);

		  // Total number of error correction codewords
		  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);

		  // Total number of data codewords
		  const dataTotalCodewords = totalCodewords - ecTotalCodewords;

		  // Total number of blocks
		  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);

		  // Calculate how many blocks each group should contain
		  const blocksInGroup2 = totalCodewords % ecTotalBlocks;
		  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;

		  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);

		  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
		  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;

		  // Number of EC codewords is the same for both groups
		  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;

		  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount
		  const rs = new ReedSolomonEncoder(ecCount);

		  let offset = 0;
		  const dcData = new Array(ecTotalBlocks);
		  const ecData = new Array(ecTotalBlocks);
		  let maxDataSize = 0;
		  const buffer = new Uint8Array(bitBuffer.buffer);

		  // Divide the buffer into the required number of blocks
		  for (let b = 0; b < ecTotalBlocks; b++) {
		    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;

		    // extract a block of data from buffer
		    dcData[b] = buffer.slice(offset, offset + dataSize);

		    // Calculate EC codewords for this data block
		    ecData[b] = rs.encode(dcData[b]);

		    offset += dataSize;
		    maxDataSize = Math.max(maxDataSize, dataSize);
		  }

		  // Create final data
		  // Interleave the data and error correction codewords from each block
		  const data = new Uint8Array(totalCodewords);
		  let index = 0;
		  let i, r;

		  // Add data codewords
		  for (i = 0; i < maxDataSize; i++) {
		    for (r = 0; r < ecTotalBlocks; r++) {
		      if (i < dcData[r].length) {
		        data[index++] = dcData[r][i];
		      }
		    }
		  }

		  // Apped EC codewords
		  for (i = 0; i < ecCount; i++) {
		    for (r = 0; r < ecTotalBlocks; r++) {
		      data[index++] = ecData[r][i];
		    }
		  }

		  return data
		}

		/**
		 * Build QR Code symbol
		 *
		 * @param  {String} data                 Input string
		 * @param  {Number} version              QR Code version
		 * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level
		 * @param  {MaskPattern} maskPattern     Mask pattern
		 * @return {Object}                      Object containing symbol data
		 */
		function createSymbol (data, version, errorCorrectionLevel, maskPattern) {
		  let segments;

		  if (Array.isArray(data)) {
		    segments = Segments.fromArray(data);
		  } else if (typeof data === 'string') {
		    let estimatedVersion = version;

		    if (!estimatedVersion) {
		      const rawSegments = Segments.rawSplit(data);

		      // Estimate best version that can contain raw splitted segments
		      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
		    }

		    // Build optimized segments
		    // If estimated version is undefined, try with the highest version
		    segments = Segments.fromString(data, estimatedVersion || 40);
		  } else {
		    throw new Error('Invalid data')
		  }

		  // Get the min version that can contain data
		  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);

		  // If no version is found, data cannot be stored
		  if (!bestVersion) {
		    throw new Error('The amount of data is too big to be stored in a QR Code')
		  }

		  // If not specified, use min version as default
		  if (!version) {
		    version = bestVersion;

		  // Check if the specified version can contain the data
		  } else if (version < bestVersion) {
		    throw new Error('\n' +
		      'The chosen QR Code version cannot contain this amount of data.\n' +
		      'Minimum version required to store current data is: ' + bestVersion + '.\n'
		    )
		  }

		  const dataBits = createData(version, errorCorrectionLevel, segments);

		  // Allocate matrix buffer
		  const moduleCount = Utils.getSymbolSize(version);
		  const modules = new BitMatrix(moduleCount);

		  // Add function modules
		  setupFinderPattern(modules, version);
		  setupTimingPattern(modules);
		  setupAlignmentPattern(modules, version);

		  // Add temporary dummy bits for format info just to set them as reserved.
		  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}
		  // since the masking operation must be performed only on the encoding region.
		  // These blocks will be replaced with correct values later in code.
		  setupFormatInfo(modules, errorCorrectionLevel, 0);

		  if (version >= 7) {
		    setupVersionInfo(modules, version);
		  }

		  // Add data codewords
		  setupData(modules, dataBits);

		  if (isNaN(maskPattern)) {
		    // Find best mask pattern
		    maskPattern = MaskPattern.getBestMask(modules,
		      setupFormatInfo.bind(null, modules, errorCorrectionLevel));
		  }

		  // Apply mask pattern
		  MaskPattern.applyMask(maskPattern, modules);

		  // Replace format info bits with correct values
		  setupFormatInfo(modules, errorCorrectionLevel, maskPattern);

		  return {
		    modules: modules,
		    version: version,
		    errorCorrectionLevel: errorCorrectionLevel,
		    maskPattern: maskPattern,
		    segments: segments
		  }
		}

		/**
		 * QR Code
		 *
		 * @param {String | Array} data                 Input data
		 * @param {Object} options                      Optional configurations
		 * @param {Number} options.version              QR Code version
		 * @param {String} options.errorCorrectionLevel Error correction level
		 * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis
		 */
		qrcode.create = function create (data, options) {
		  if (typeof data === 'undefined' || data === '') {
		    throw new Error('No input text')
		  }

		  let errorCorrectionLevel = ECLevel.M;
		  let version;
		  let mask;

		  if (typeof options !== 'undefined') {
		    // Use higher error correction level as default
		    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
		    version = Version.from(options.version);
		    mask = MaskPattern.from(options.maskPattern);

		    if (options.toSJISFunc) {
		      Utils.setToSJISFunction(options.toSJISFunc);
		    }
		  }

		  return createSymbol(data, version, errorCorrectionLevel, mask)
		};
		return qrcode;
	}

	var canvas = {};

	var utils$1 = {};

	var hasRequiredUtils$1;

	function requireUtils$1 () {
		if (hasRequiredUtils$1) return utils$1;
		hasRequiredUtils$1 = 1;
		(function (exports) {
			function hex2rgba (hex) {
			  if (typeof hex === 'number') {
			    hex = hex.toString();
			  }

			  if (typeof hex !== 'string') {
			    throw new Error('Color should be defined as hex string')
			  }

			  let hexCode = hex.slice().replace('#', '').split('');
			  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
			    throw new Error('Invalid hex color: ' + hex)
			  }

			  // Convert from short to long form (fff -> ffffff)
			  if (hexCode.length === 3 || hexCode.length === 4) {
			    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {
			      return [c, c]
			    }));
			  }

			  // Add default alpha value
			  if (hexCode.length === 6) hexCode.push('F', 'F');

			  const hexValue = parseInt(hexCode.join(''), 16);

			  return {
			    r: (hexValue >> 24) & 255,
			    g: (hexValue >> 16) & 255,
			    b: (hexValue >> 8) & 255,
			    a: hexValue & 255,
			    hex: '#' + hexCode.slice(0, 6).join('')
			  }
			}

			exports.getOptions = function getOptions (options) {
			  if (!options) options = {};
			  if (!options.color) options.color = {};

			  const margin = typeof options.margin === 'undefined' ||
			    options.margin === null ||
			    options.margin < 0
			    ? 4
			    : options.margin;

			  const width = options.width && options.width >= 21 ? options.width : undefined;
			  const scale = options.scale || 4;

			  return {
			    width: width,
			    scale: width ? 4 : scale,
			    margin: margin,
			    color: {
			      dark: hex2rgba(options.color.dark || '#000000ff'),
			      light: hex2rgba(options.color.light || '#ffffffff')
			    },
			    type: options.type,
			    rendererOpts: options.rendererOpts || {}
			  }
			};

			exports.getScale = function getScale (qrSize, opts) {
			  return opts.width && opts.width >= qrSize + opts.margin * 2
			    ? opts.width / (qrSize + opts.margin * 2)
			    : opts.scale
			};

			exports.getImageWidth = function getImageWidth (qrSize, opts) {
			  const scale = exports.getScale(qrSize, opts);
			  return Math.floor((qrSize + opts.margin * 2) * scale)
			};

			exports.qrToImageData = function qrToImageData (imgData, qr, opts) {
			  const size = qr.modules.size;
			  const data = qr.modules.data;
			  const scale = exports.getScale(size, opts);
			  const symbolSize = Math.floor((size + opts.margin * 2) * scale);
			  const scaledMargin = opts.margin * scale;
			  const palette = [opts.color.light, opts.color.dark];

			  for (let i = 0; i < symbolSize; i++) {
			    for (let j = 0; j < symbolSize; j++) {
			      let posDst = (i * symbolSize + j) * 4;
			      let pxColor = opts.color.light;

			      if (i >= scaledMargin && j >= scaledMargin &&
			        i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
			        const iSrc = Math.floor((i - scaledMargin) / scale);
			        const jSrc = Math.floor((j - scaledMargin) / scale);
			        pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
			      }

			      imgData[posDst++] = pxColor.r;
			      imgData[posDst++] = pxColor.g;
			      imgData[posDst++] = pxColor.b;
			      imgData[posDst] = pxColor.a;
			    }
			  }
			}; 
		} (utils$1));
		return utils$1;
	}

	var hasRequiredCanvas;

	function requireCanvas () {
		if (hasRequiredCanvas) return canvas;
		hasRequiredCanvas = 1;
		(function (exports) {
			const Utils = requireUtils$1();

			function clearCanvas (ctx, canvas, size) {
			  ctx.clearRect(0, 0, canvas.width, canvas.height);

			  if (!canvas.style) canvas.style = {};
			  canvas.height = size;
			  canvas.width = size;
			  canvas.style.height = size + 'px';
			  canvas.style.width = size + 'px';
			}

			function getCanvasElement () {
			  try {
			    return document.createElement('canvas')
			  } catch (e) {
			    throw new Error('You need to specify a canvas element')
			  }
			}

			exports.render = function render (qrData, canvas, options) {
			  let opts = options;
			  let canvasEl = canvas;

			  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
			    opts = canvas;
			    canvas = undefined;
			  }

			  if (!canvas) {
			    canvasEl = getCanvasElement();
			  }

			  opts = Utils.getOptions(opts);
			  const size = Utils.getImageWidth(qrData.modules.size, opts);

			  const ctx = canvasEl.getContext('2d');
			  const image = ctx.createImageData(size, size);
			  Utils.qrToImageData(image.data, qrData, opts);

			  clearCanvas(ctx, canvasEl, size);
			  ctx.putImageData(image, 0, 0);

			  return canvasEl
			};

			exports.renderToDataURL = function renderToDataURL (qrData, canvas, options) {
			  let opts = options;

			  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
			    opts = canvas;
			    canvas = undefined;
			  }

			  if (!opts) opts = {};

			  const canvasEl = exports.render(qrData, canvas, opts);

			  const type = opts.type || 'image/png';
			  const rendererOpts = opts.rendererOpts || {};

			  return canvasEl.toDataURL(type, rendererOpts.quality)
			}; 
		} (canvas));
		return canvas;
	}

	var svgTag = {};

	var hasRequiredSvgTag;

	function requireSvgTag () {
		if (hasRequiredSvgTag) return svgTag;
		hasRequiredSvgTag = 1;
		const Utils = requireUtils$1();

		function getColorAttrib (color, attrib) {
		  const alpha = color.a / 255;
		  const str = attrib + '="' + color.hex + '"';

		  return alpha < 1
		    ? str + ' ' + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"'
		    : str
		}

		function svgCmd (cmd, x, y) {
		  let str = cmd + x;
		  if (typeof y !== 'undefined') str += ' ' + y;

		  return str
		}

		function qrToPath (data, size, margin) {
		  let path = '';
		  let moveBy = 0;
		  let newRow = false;
		  let lineLength = 0;

		  for (let i = 0; i < data.length; i++) {
		    const col = Math.floor(i % size);
		    const row = Math.floor(i / size);

		    if (!col && !newRow) newRow = true;

		    if (data[i]) {
		      lineLength++;

		      if (!(i > 0 && col > 0 && data[i - 1])) {
		        path += newRow
		          ? svgCmd('M', col + margin, 0.5 + row + margin)
		          : svgCmd('m', moveBy, 0);

		        moveBy = 0;
		        newRow = false;
		      }

		      if (!(col + 1 < size && data[i + 1])) {
		        path += svgCmd('h', lineLength);
		        lineLength = 0;
		      }
		    } else {
		      moveBy++;
		    }
		  }

		  return path
		}

		svgTag.render = function render (qrData, options, cb) {
		  const opts = Utils.getOptions(options);
		  const size = qrData.modules.size;
		  const data = qrData.modules.data;
		  const qrcodesize = size + opts.margin * 2;

		  const bg = !opts.color.light.a
		    ? ''
		    : '<path ' + getColorAttrib(opts.color.light, 'fill') +
		      ' d="M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z"/>';

		  const path =
		    '<path ' + getColorAttrib(opts.color.dark, 'stroke') +
		    ' d="' + qrToPath(data, size, opts.margin) + '"/>';

		  const viewBox = 'viewBox="' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '"';

		  const width = !opts.width ? '' : 'width="' + opts.width + '" height="' + opts.width + '" ';

		  const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + '</svg>\n';

		  if (typeof cb === 'function') {
		    cb(null, svgTag);
		  }

		  return svgTag
		};
		return svgTag;
	}

	var hasRequiredBrowser;

	function requireBrowser () {
		if (hasRequiredBrowser) return browser;
		hasRequiredBrowser = 1;
		const canPromise = requireCanPromise();

		const QRCode = requireQrcode();
		const CanvasRenderer = requireCanvas();
		const SvgRenderer = requireSvgTag();

		function renderCanvas (renderFunc, canvas, text, opts, cb) {
		  const args = [].slice.call(arguments, 1);
		  const argsNum = args.length;
		  const isLastArgCb = typeof args[argsNum - 1] === 'function';

		  if (!isLastArgCb && !canPromise()) {
		    throw new Error('Callback required as last argument')
		  }

		  if (isLastArgCb) {
		    if (argsNum < 2) {
		      throw new Error('Too few arguments provided')
		    }

		    if (argsNum === 2) {
		      cb = text;
		      text = canvas;
		      canvas = opts = undefined;
		    } else if (argsNum === 3) {
		      if (canvas.getContext && typeof cb === 'undefined') {
		        cb = opts;
		        opts = undefined;
		      } else {
		        cb = opts;
		        opts = text;
		        text = canvas;
		        canvas = undefined;
		      }
		    }
		  } else {
		    if (argsNum < 1) {
		      throw new Error('Too few arguments provided')
		    }

		    if (argsNum === 1) {
		      text = canvas;
		      canvas = opts = undefined;
		    } else if (argsNum === 2 && !canvas.getContext) {
		      opts = text;
		      text = canvas;
		      canvas = undefined;
		    }

		    return new Promise(function (resolve, reject) {
		      try {
		        const data = QRCode.create(text, opts);
		        resolve(renderFunc(data, canvas, opts));
		      } catch (e) {
		        reject(e);
		      }
		    })
		  }

		  try {
		    const data = QRCode.create(text, opts);
		    cb(null, renderFunc(data, canvas, opts));
		  } catch (e) {
		    cb(e);
		  }
		}

		browser.create = QRCode.create;
		browser.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
		browser.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);

		// only svg for now.
		browser.toString = renderCanvas.bind(null, function (data, _, opts) {
		  return SvgRenderer.render(data, opts)
		});
		return browser;
	}

	var browserExports = requireBrowser();
	var QRCode = /*@__PURE__*/getDefaultExportFromCjs(browserExports);

	function injectStyle(css) {
	    if (css && typeof (window) != 'undefined') {
	        let style = document.createElement('style');
	        style.setAttribute('media', 'screen');
	        style.innerHTML = css;
	        document.head.appendChild(style);
	    }
	}

	injectStyle(".container.svelte-ewizuu {background-color: rgba(0, 0, 0, 0.3);position: fixed;left: 0px;top: 0px;right: 0px;z-index: 10000;bottom: 0px;display: flex;justify-content: center;align-items: center;animation: fadein 300ms ease-in 1;transition: opacity ease-in-out 0.3s;opacity: 1;}img.svelte-ewizuu {max-width: 100%;max-height: 100%;box-shadow: 5px 10px 85px 2px rgba(0, 0, 0, 0.664);border-radius: 0.5em;}");

	var root$1 = from_html(`<div class="container svelte-ewizuu" style=""><img alt="qrcode" class="svelte-ewizuu"/></div>`);

	function DialogQRCode($$anchor, $$props) {
		push($$props, false);

		let message = prop($$props, 'message', 8, null);

		/** @type{HTMLImageElement} */
		let img = mutable_source();

		/** @type{HTMLDivElement} */
		let container = mutable_source();

		onMount(async () => {
			mutate(container, get(container).onclick = async () => {
				mutate(container, get(container).style.opacity = '0');

				const sleep = (timeout) => new Promise((resolve) => setTimeout(resolve, timeout));

				await sleep(300);
				get(container).remove();
			});

			let url = await QRCode.toDataURL(message(), { color: { dark: "#00F", light: "#DDF" } });

			mutate(img, get(img).src = url);
		});

		init();

		var div = root$1();
		var img_1 = child(div);

		bind_this(img_1, ($$value) => set(img, $$value), () => get(img));
		bind_this(div, ($$value) => set(container, $$value), () => get(container));
		append($$anchor, div);
		pop();
	}

	/**
	 * 
	 * @param {string} message 
	 * @param {string} key 
	 * @returns 
	 */

	/**
	 * @param {string} text 
	 * @returns 
	 */
	function base64decode(text) {
	    const _tidyB64 = (/** @type {string} */ s) => s.replace(/[^A-Za-z0-9\+\/]/g, '');
	    const _unURI = (/** @type {string} */ a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));
	    text = _unURI(text);
	    const binaryString = atob(text);
	    const len = binaryString.length;
	    const bytes = new Uint8Array(len);
	    for (let i = 0; i < len; i++) {
	        bytes[i] = binaryString.charCodeAt(i);
	    }
	    return bytes
	}

	/**
	 * @param {Uint8Array<ArrayBuffer>} buffer 
	 * @returns 
	 */
	function base64encode(buffer, urlsafe = false) {
	    const CHUNK_SZ = 0x8000;
	    const chars = [];
	    for (let i = 0; i < buffer.length; i += CHUNK_SZ) {
	        const chunk = buffer.subarray(i, i + CHUNK_SZ);
	        chars.push(String.fromCharCode.apply(null, chunk));
	    }
	    let b64 = btoa(chars.join(''));
	    if (urlsafe) {
	        b64 = b64.replace(/=/g, '').replace(/[+\/]/g, (m0) => m0 == '+' ? '-' : '_');
	    }
	    return b64
	}

	/**
	 * @param {string} text hex string
	 * @returns 
	 */
	function hexDecode(text) {
	    return new Uint8Array(text.match(/[\da-f]{2}/gi).map((h) => parseInt(h, 16)))
	}

	/**
	 * @param {Uint8Array<ArrayBuffer>} buffer 
	 * @returns 
	 */
	function hexEncode(buffer) {
	    const hashArray = Array.from(new Uint8Array(buffer));
	    return hashArray.map(byte => byte.toString(16).padStart(2, "0")).join("")
	}

	/**
	 * @param {Uint8Array<ArrayBuffer>} buffer 
	 * @returns 
	 */
	function textDecode(buffer) {
	    return new TextDecoder().decode(buffer)
	}

	/**
	 * @param {string} text 
	 * @returns 
	 */
	function textEncode(text) {
	    return new TextEncoder().encode(text)
	}

	var cryptoJs$1 = {exports: {}};

	function commonjsRequire(path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var core$1 = {exports: {}};

	var empty = {};

	var empty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: empty
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(empty$1);

	var core = core$1.exports;

	var hasRequiredCore;

	function requireCore () {
		if (hasRequiredCore) return core$1.exports;
		hasRequiredCore = 1;
		(function (module, exports) {
	(function (root, factory) {
				{
					// CommonJS
					module.exports = factory();
				}
			}(core, function () {

				/*globals window, global, require*/

				/**
				 * CryptoJS core components.
				 */
				var CryptoJS = CryptoJS || (function (Math, undefined$1) {

				    var crypto;

				    // Native crypto from window (Browser)
				    if (typeof window !== 'undefined' && window.crypto) {
				        crypto = window.crypto;
				    }

				    // Native crypto in web worker (Browser)
				    if (typeof self !== 'undefined' && self.crypto) {
				        crypto = self.crypto;
				    }

				    // Native crypto from worker
				    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
				        crypto = globalThis.crypto;
				    }

				    // Native (experimental IE 11) crypto from window (Browser)
				    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
				        crypto = window.msCrypto;
				    }

				    // Native crypto from global (NodeJS)
				    if (!crypto && typeof commonjsGlobal !== 'undefined' && commonjsGlobal.crypto) {
				        crypto = commonjsGlobal.crypto;
				    }

				    // Native crypto import via require (NodeJS)
				    if (!crypto && typeof commonjsRequire === 'function') {
				        try {
				            crypto = require$$0;
				        } catch (err) {}
				    }

				    /*
				     * Cryptographically secure pseudorandom number generator
				     *
				     * As Math.random() is cryptographically not safe to use
				     */
				    var cryptoSecureRandomInt = function () {
				        if (crypto) {
				            // Use getRandomValues method (Browser)
				            if (typeof crypto.getRandomValues === 'function') {
				                try {
				                    return crypto.getRandomValues(new Uint32Array(1))[0];
				                } catch (err) {}
				            }

				            // Use randomBytes method (NodeJS)
				            if (typeof crypto.randomBytes === 'function') {
				                try {
				                    return crypto.randomBytes(4).readInt32LE();
				                } catch (err) {}
				            }
				        }

				        throw new Error('Native crypto module could not be used to get secure random number.');
				    };

				    /*
				     * Local polyfill of Object.create

				     */
				    var create = Object.create || (function () {
				        function F() {}

				        return function (obj) {
				            var subtype;

				            F.prototype = obj;

				            subtype = new F();

				            F.prototype = null;

				            return subtype;
				        };
				    }());

				    /**
				     * CryptoJS namespace.
				     */
				    var C = {};

				    /**
				     * Library namespace.
				     */
				    var C_lib = C.lib = {};

				    /**
				     * Base object for prototypal inheritance.
				     */
				    var Base = C_lib.Base = (function () {


				        return {
				            /**
				             * Creates a new object that inherits from this object.
				             *
				             * @param {Object} overrides Properties to copy into the new object.
				             *
				             * @return {Object} The new object.
				             *
				             * @static
				             *
				             * @example
				             *
				             *     var MyType = CryptoJS.lib.Base.extend({
				             *         field: 'value',
				             *
				             *         method: function () {
				             *         }
				             *     });
				             */
				            extend: function (overrides) {
				                // Spawn
				                var subtype = create(this);

				                // Augment
				                if (overrides) {
				                    subtype.mixIn(overrides);
				                }

				                // Create default initializer
				                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
				                    subtype.init = function () {
				                        subtype.$super.init.apply(this, arguments);
				                    };
				                }

				                // Initializer's prototype is the subtype object
				                subtype.init.prototype = subtype;

				                // Reference supertype
				                subtype.$super = this;

				                return subtype;
				            },

				            /**
				             * Extends this object and runs the init method.
				             * Arguments to create() will be passed to init().
				             *
				             * @return {Object} The new object.
				             *
				             * @static
				             *
				             * @example
				             *
				             *     var instance = MyType.create();
				             */
				            create: function () {
				                var instance = this.extend();
				                instance.init.apply(instance, arguments);

				                return instance;
				            },

				            /**
				             * Initializes a newly created object.
				             * Override this method to add some logic when your objects are created.
				             *
				             * @example
				             *
				             *     var MyType = CryptoJS.lib.Base.extend({
				             *         init: function () {
				             *             // ...
				             *         }
				             *     });
				             */
				            init: function () {
				            },

				            /**
				             * Copies properties into this object.
				             *
				             * @param {Object} properties The properties to mix in.
				             *
				             * @example
				             *
				             *     MyType.mixIn({
				             *         field: 'value'
				             *     });
				             */
				            mixIn: function (properties) {
				                for (var propertyName in properties) {
				                    if (properties.hasOwnProperty(propertyName)) {
				                        this[propertyName] = properties[propertyName];
				                    }
				                }

				                // IE won't copy toString using the loop above
				                if (properties.hasOwnProperty('toString')) {
				                    this.toString = properties.toString;
				                }
				            },

				            /**
				             * Creates a copy of this object.
				             *
				             * @return {Object} The clone.
				             *
				             * @example
				             *
				             *     var clone = instance.clone();
				             */
				            clone: function () {
				                return this.init.prototype.extend(this);
				            }
				        };
				    }());

				    /**
				     * An array of 32-bit words.
				     *
				     * @property {Array} words The array of 32-bit words.
				     * @property {number} sigBytes The number of significant bytes in this word array.
				     */
				    var WordArray = C_lib.WordArray = Base.extend({
				        /**
				         * Initializes a newly created word array.
				         *
				         * @param {Array} words (Optional) An array of 32-bit words.
				         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.lib.WordArray.create();
				         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
				         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
				         */
				        init: function (words, sigBytes) {
				            words = this.words = words || [];

				            if (sigBytes != undefined$1) {
				                this.sigBytes = sigBytes;
				            } else {
				                this.sigBytes = words.length * 4;
				            }
				        },

				        /**
				         * Converts this word array to a string.
				         *
				         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
				         *
				         * @return {string} The stringified word array.
				         *
				         * @example
				         *
				         *     var string = wordArray + '';
				         *     var string = wordArray.toString();
				         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
				         */
				        toString: function (encoder) {
				            return (encoder || Hex).stringify(this);
				        },

				        /**
				         * Concatenates a word array to this word array.
				         *
				         * @param {WordArray} wordArray The word array to append.
				         *
				         * @return {WordArray} This word array.
				         *
				         * @example
				         *
				         *     wordArray1.concat(wordArray2);
				         */
				        concat: function (wordArray) {
				            // Shortcuts
				            var thisWords = this.words;
				            var thatWords = wordArray.words;
				            var thisSigBytes = this.sigBytes;
				            var thatSigBytes = wordArray.sigBytes;

				            // Clamp excess bits
				            this.clamp();

				            // Concat
				            if (thisSigBytes % 4) {
				                // Copy one byte at a time
				                for (var i = 0; i < thatSigBytes; i++) {
				                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
				                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
				                }
				            } else {
				                // Copy one word at a time
				                for (var j = 0; j < thatSigBytes; j += 4) {
				                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
				                }
				            }
				            this.sigBytes += thatSigBytes;

				            // Chainable
				            return this;
				        },

				        /**
				         * Removes insignificant bits.
				         *
				         * @example
				         *
				         *     wordArray.clamp();
				         */
				        clamp: function () {
				            // Shortcuts
				            var words = this.words;
				            var sigBytes = this.sigBytes;

				            // Clamp
				            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
				            words.length = Math.ceil(sigBytes / 4);
				        },

				        /**
				         * Creates a copy of this word array.
				         *
				         * @return {WordArray} The clone.
				         *
				         * @example
				         *
				         *     var clone = wordArray.clone();
				         */
				        clone: function () {
				            var clone = Base.clone.call(this);
				            clone.words = this.words.slice(0);

				            return clone;
				        },

				        /**
				         * Creates a word array filled with random bytes.
				         *
				         * @param {number} nBytes The number of random bytes to generate.
				         *
				         * @return {WordArray} The random word array.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.lib.WordArray.random(16);
				         */
				        random: function (nBytes) {
				            var words = [];

				            for (var i = 0; i < nBytes; i += 4) {
				                words.push(cryptoSecureRandomInt());
				            }

				            return new WordArray.init(words, nBytes);
				        }
				    });

				    /**
				     * Encoder namespace.
				     */
				    var C_enc = C.enc = {};

				    /**
				     * Hex encoding strategy.
				     */
				    var Hex = C_enc.Hex = {
				        /**
				         * Converts a word array to a hex string.
				         *
				         * @param {WordArray} wordArray The word array.
				         *
				         * @return {string} The hex string.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
				         */
				        stringify: function (wordArray) {
				            // Shortcuts
				            var words = wordArray.words;
				            var sigBytes = wordArray.sigBytes;

				            // Convert
				            var hexChars = [];
				            for (var i = 0; i < sigBytes; i++) {
				                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
				                hexChars.push((bite >>> 4).toString(16));
				                hexChars.push((bite & 0x0f).toString(16));
				            }

				            return hexChars.join('');
				        },

				        /**
				         * Converts a hex string to a word array.
				         *
				         * @param {string} hexStr The hex string.
				         *
				         * @return {WordArray} The word array.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
				         */
				        parse: function (hexStr) {
				            // Shortcut
				            var hexStrLength = hexStr.length;

				            // Convert
				            var words = [];
				            for (var i = 0; i < hexStrLength; i += 2) {
				                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
				            }

				            return new WordArray.init(words, hexStrLength / 2);
				        }
				    };

				    /**
				     * Latin1 encoding strategy.
				     */
				    var Latin1 = C_enc.Latin1 = {
				        /**
				         * Converts a word array to a Latin1 string.
				         *
				         * @param {WordArray} wordArray The word array.
				         *
				         * @return {string} The Latin1 string.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
				         */
				        stringify: function (wordArray) {
				            // Shortcuts
				            var words = wordArray.words;
				            var sigBytes = wordArray.sigBytes;

				            // Convert
				            var latin1Chars = [];
				            for (var i = 0; i < sigBytes; i++) {
				                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
				                latin1Chars.push(String.fromCharCode(bite));
				            }

				            return latin1Chars.join('');
				        },

				        /**
				         * Converts a Latin1 string to a word array.
				         *
				         * @param {string} latin1Str The Latin1 string.
				         *
				         * @return {WordArray} The word array.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
				         */
				        parse: function (latin1Str) {
				            // Shortcut
				            var latin1StrLength = latin1Str.length;

				            // Convert
				            var words = [];
				            for (var i = 0; i < latin1StrLength; i++) {
				                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
				            }

				            return new WordArray.init(words, latin1StrLength);
				        }
				    };

				    /**
				     * UTF-8 encoding strategy.
				     */
				    var Utf8 = C_enc.Utf8 = {
				        /**
				         * Converts a word array to a UTF-8 string.
				         *
				         * @param {WordArray} wordArray The word array.
				         *
				         * @return {string} The UTF-8 string.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
				         */
				        stringify: function (wordArray) {
				            try {
				                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
				            } catch (e) {
				                throw new Error('Malformed UTF-8 data');
				            }
				        },

				        /**
				         * Converts a UTF-8 string to a word array.
				         *
				         * @param {string} utf8Str The UTF-8 string.
				         *
				         * @return {WordArray} The word array.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
				         */
				        parse: function (utf8Str) {
				            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
				        }
				    };

				    /**
				     * Abstract buffered block algorithm template.
				     *
				     * The property blockSize must be implemented in a concrete subtype.
				     *
				     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
				     */
				    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
				        /**
				         * Resets this block algorithm's data buffer to its initial state.
				         *
				         * @example
				         *
				         *     bufferedBlockAlgorithm.reset();
				         */
				        reset: function () {
				            // Initial values
				            this._data = new WordArray.init();
				            this._nDataBytes = 0;
				        },

				        /**
				         * Adds new data to this block algorithm's buffer.
				         *
				         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
				         *
				         * @example
				         *
				         *     bufferedBlockAlgorithm._append('data');
				         *     bufferedBlockAlgorithm._append(wordArray);
				         */
				        _append: function (data) {
				            // Convert string to WordArray, else assume WordArray already
				            if (typeof data == 'string') {
				                data = Utf8.parse(data);
				            }

				            // Append
				            this._data.concat(data);
				            this._nDataBytes += data.sigBytes;
				        },

				        /**
				         * Processes available data blocks.
				         *
				         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
				         *
				         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
				         *
				         * @return {WordArray} The processed data.
				         *
				         * @example
				         *
				         *     var processedData = bufferedBlockAlgorithm._process();
				         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
				         */
				        _process: function (doFlush) {
				            var processedWords;

				            // Shortcuts
				            var data = this._data;
				            var dataWords = data.words;
				            var dataSigBytes = data.sigBytes;
				            var blockSize = this.blockSize;
				            var blockSizeBytes = blockSize * 4;

				            // Count blocks ready
				            var nBlocksReady = dataSigBytes / blockSizeBytes;
				            if (doFlush) {
				                // Round up to include partial blocks
				                nBlocksReady = Math.ceil(nBlocksReady);
				            } else {
				                // Round down to include only full blocks,
				                // less the number of blocks that must remain in the buffer
				                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
				            }

				            // Count words ready
				            var nWordsReady = nBlocksReady * blockSize;

				            // Count bytes ready
				            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

				            // Process blocks
				            if (nWordsReady) {
				                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
				                    // Perform concrete-algorithm logic
				                    this._doProcessBlock(dataWords, offset);
				                }

				                // Remove processed words
				                processedWords = dataWords.splice(0, nWordsReady);
				                data.sigBytes -= nBytesReady;
				            }

				            // Return processed words
				            return new WordArray.init(processedWords, nBytesReady);
				        },

				        /**
				         * Creates a copy of this object.
				         *
				         * @return {Object} The clone.
				         *
				         * @example
				         *
				         *     var clone = bufferedBlockAlgorithm.clone();
				         */
				        clone: function () {
				            var clone = Base.clone.call(this);
				            clone._data = this._data.clone();

				            return clone;
				        },

				        _minBufferSize: 0
				    });

				    /**
				     * Abstract hasher template.
				     *
				     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
				     */
				    C_lib.Hasher = BufferedBlockAlgorithm.extend({
				        /**
				         * Configuration options.
				         */
				        cfg: Base.extend(),

				        /**
				         * Initializes a newly created hasher.
				         *
				         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
				         *
				         * @example
				         *
				         *     var hasher = CryptoJS.algo.SHA256.create();
				         */
				        init: function (cfg) {
				            // Apply config defaults
				            this.cfg = this.cfg.extend(cfg);

				            // Set initial values
				            this.reset();
				        },

				        /**
				         * Resets this hasher to its initial state.
				         *
				         * @example
				         *
				         *     hasher.reset();
				         */
				        reset: function () {
				            // Reset data buffer
				            BufferedBlockAlgorithm.reset.call(this);

				            // Perform concrete-hasher logic
				            this._doReset();
				        },

				        /**
				         * Updates this hasher with a message.
				         *
				         * @param {WordArray|string} messageUpdate The message to append.
				         *
				         * @return {Hasher} This hasher.
				         *
				         * @example
				         *
				         *     hasher.update('message');
				         *     hasher.update(wordArray);
				         */
				        update: function (messageUpdate) {
				            // Append
				            this._append(messageUpdate);

				            // Update the hash
				            this._process();

				            // Chainable
				            return this;
				        },

				        /**
				         * Finalizes the hash computation.
				         * Note that the finalize operation is effectively a destructive, read-once operation.
				         *
				         * @param {WordArray|string} messageUpdate (Optional) A final message update.
				         *
				         * @return {WordArray} The hash.
				         *
				         * @example
				         *
				         *     var hash = hasher.finalize();
				         *     var hash = hasher.finalize('message');
				         *     var hash = hasher.finalize(wordArray);
				         */
				        finalize: function (messageUpdate) {
				            // Final message update
				            if (messageUpdate) {
				                this._append(messageUpdate);
				            }

				            // Perform concrete-hasher logic
				            var hash = this._doFinalize();

				            return hash;
				        },

				        blockSize: 512/32,

				        /**
				         * Creates a shortcut function to a hasher's object interface.
				         *
				         * @param {Hasher} hasher The hasher to create a helper for.
				         *
				         * @return {Function} The shortcut function.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
				         */
				        _createHelper: function (hasher) {
				            return function (message, cfg) {
				                return new hasher.init(cfg).finalize(message);
				            };
				        },

				        /**
				         * Creates a shortcut function to the HMAC's object interface.
				         *
				         * @param {Hasher} hasher The hasher to use in this HMAC helper.
				         *
				         * @return {Function} The shortcut function.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
				         */
				        _createHmacHelper: function (hasher) {
				            return function (message, key) {
				                return new C_algo.HMAC.init(hasher, key).finalize(message);
				            };
				        }
				    });

				    /**
				     * Algorithm namespace.
				     */
				    var C_algo = C.algo = {};

				    return C;
				}(Math));


				return CryptoJS;

			})); 
		} (core$1));
		return core$1.exports;
	}

	var x64Core$1 = {exports: {}};

	var x64Core = x64Core$1.exports;

	var hasRequiredX64Core;

	function requireX64Core () {
		if (hasRequiredX64Core) return x64Core$1.exports;
		hasRequiredX64Core = 1;
		(function (module, exports) {
	(function (root, factory) {
				{
					// CommonJS
					module.exports = factory(requireCore());
				}
			}(x64Core, function (CryptoJS) {

				(function (undefined$1) {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var Base = C_lib.Base;
				    var X32WordArray = C_lib.WordArray;

				    /**
				     * x64 namespace.
				     */
				    var C_x64 = C.x64 = {};

				    /**
				     * A 64-bit word.
				     */
				    C_x64.Word = Base.extend({
				        /**
				         * Initializes a newly created 64-bit word.
				         *
				         * @param {number} high The high 32 bits.
				         * @param {number} low The low 32 bits.
				         *
				         * @example
				         *
				         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
				         */
				        init: function (high, low) {
				            this.high = high;
				            this.low = low;
				        }

				        /**
				         * Bitwise NOTs this word.
				         *
				         * @return {X64Word} A new x64-Word object after negating.
				         *
				         * @example
				         *
				         *     var negated = x64Word.not();
				         */
				        // not: function () {
				            // var high = ~this.high;
				            // var low = ~this.low;

				            // return X64Word.create(high, low);
				        // },

				        /**
				         * Bitwise ANDs this word with the passed word.
				         *
				         * @param {X64Word} word The x64-Word to AND with this word.
				         *
				         * @return {X64Word} A new x64-Word object after ANDing.
				         *
				         * @example
				         *
				         *     var anded = x64Word.and(anotherX64Word);
				         */
				        // and: function (word) {
				            // var high = this.high & word.high;
				            // var low = this.low & word.low;

				            // return X64Word.create(high, low);
				        // },

				        /**
				         * Bitwise ORs this word with the passed word.
				         *
				         * @param {X64Word} word The x64-Word to OR with this word.
				         *
				         * @return {X64Word} A new x64-Word object after ORing.
				         *
				         * @example
				         *
				         *     var ored = x64Word.or(anotherX64Word);
				         */
				        // or: function (word) {
				            // var high = this.high | word.high;
				            // var low = this.low | word.low;

				            // return X64Word.create(high, low);
				        // },

				        /**
				         * Bitwise XORs this word with the passed word.
				         *
				         * @param {X64Word} word The x64-Word to XOR with this word.
				         *
				         * @return {X64Word} A new x64-Word object after XORing.
				         *
				         * @example
				         *
				         *     var xored = x64Word.xor(anotherX64Word);
				         */
				        // xor: function (word) {
				            // var high = this.high ^ word.high;
				            // var low = this.low ^ word.low;

				            // return X64Word.create(high, low);
				        // },

				        /**
				         * Shifts this word n bits to the left.
				         *
				         * @param {number} n The number of bits to shift.
				         *
				         * @return {X64Word} A new x64-Word object after shifting.
				         *
				         * @example
				         *
				         *     var shifted = x64Word.shiftL(25);
				         */
				        // shiftL: function (n) {
				            // if (n < 32) {
				                // var high = (this.high << n) | (this.low >>> (32 - n));
				                // var low = this.low << n;
				            // } else {
				                // var high = this.low << (n - 32);
				                // var low = 0;
				            // }

				            // return X64Word.create(high, low);
				        // },

				        /**
				         * Shifts this word n bits to the right.
				         *
				         * @param {number} n The number of bits to shift.
				         *
				         * @return {X64Word} A new x64-Word object after shifting.
				         *
				         * @example
				         *
				         *     var shifted = x64Word.shiftR(7);
				         */
				        // shiftR: function (n) {
				            // if (n < 32) {
				                // var low = (this.low >>> n) | (this.high << (32 - n));
				                // var high = this.high >>> n;
				            // } else {
				                // var low = this.high >>> (n - 32);
				                // var high = 0;
				            // }

				            // return X64Word.create(high, low);
				        // },

				        /**
				         * Rotates this word n bits to the left.
				         *
				         * @param {number} n The number of bits to rotate.
				         *
				         * @return {X64Word} A new x64-Word object after rotating.
				         *
				         * @example
				         *
				         *     var rotated = x64Word.rotL(25);
				         */
				        // rotL: function (n) {
				            // return this.shiftL(n).or(this.shiftR(64 - n));
				        // },

				        /**
				         * Rotates this word n bits to the right.
				         *
				         * @param {number} n The number of bits to rotate.
				         *
				         * @return {X64Word} A new x64-Word object after rotating.
				         *
				         * @example
				         *
				         *     var rotated = x64Word.rotR(7);
				         */
				        // rotR: function (n) {
				            // return this.shiftR(n).or(this.shiftL(64 - n));
				        // },

				        /**
				         * Adds this word with the passed word.
				         *
				         * @param {X64Word} word The x64-Word to add with this word.
				         *
				         * @return {X64Word} A new x64-Word object after adding.
				         *
				         * @example
				         *
				         *     var added = x64Word.add(anotherX64Word);
				         */
				        // add: function (word) {
				            // var low = (this.low + word.low) | 0;
				            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
				            // var high = (this.high + word.high + carry) | 0;

				            // return X64Word.create(high, low);
				        // }
				    });

				    /**
				     * An array of 64-bit words.
				     *
				     * @property {Array} words The array of CryptoJS.x64.Word objects.
				     * @property {number} sigBytes The number of significant bytes in this word array.
				     */
				    C_x64.WordArray = Base.extend({
				        /**
				         * Initializes a newly created word array.
				         *
				         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
				         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.x64.WordArray.create();
				         *
				         *     var wordArray = CryptoJS.x64.WordArray.create([
				         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
				         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
				         *     ]);
				         *
				         *     var wordArray = CryptoJS.x64.WordArray.create([
				         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
				         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
				         *     ], 10);
				         */
				        init: function (words, sigBytes) {
				            words = this.words = words || [];

				            if (sigBytes != undefined$1) {
				                this.sigBytes = sigBytes;
				            } else {
				                this.sigBytes = words.length * 8;
				            }
				        },

				        /**
				         * Converts this 64-bit word array to a 32-bit word array.
				         *
				         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
				         *
				         * @example
				         *
				         *     var x32WordArray = x64WordArray.toX32();
				         */
				        toX32: function () {
				            // Shortcuts
				            var x64Words = this.words;
				            var x64WordsLength = x64Words.length;

				            // Convert
				            var x32Words = [];
				            for (var i = 0; i < x64WordsLength; i++) {
				                var x64Word = x64Words[i];
				                x32Words.push(x64Word.high);
				                x32Words.push(x64Word.low);
				            }

				            return X32WordArray.create(x32Words, this.sigBytes);
				        },

				        /**
				         * Creates a copy of this word array.
				         *
				         * @return {X64WordArray} The clone.
				         *
				         * @example
				         *
				         *     var clone = x64WordArray.clone();
				         */
				        clone: function () {
				            var clone = Base.clone.call(this);

				            // Clone "words" array
				            var words = clone.words = this.words.slice(0);

				            // Clone each X64Word object
				            var wordsLength = words.length;
				            for (var i = 0; i < wordsLength; i++) {
				                words[i] = words[i].clone();
				            }

				            return clone;
				        }
				    });
				}());


				return CryptoJS;

			})); 
		} (x64Core$1));
		return x64Core$1.exports;
	}

	var libTypedarrays$1 = {exports: {}};

	var libTypedarrays = libTypedarrays$1.exports;

	var hasRequiredLibTypedarrays;

	function requireLibTypedarrays () {
		if (hasRequiredLibTypedarrays) return libTypedarrays$1.exports;
		hasRequiredLibTypedarrays = 1;
		(function (module, exports) {
	(function (root, factory) {
				{
					// CommonJS
					module.exports = factory(requireCore());
				}
			}(libTypedarrays, function (CryptoJS) {

				(function () {
				    // Check if typed arrays are supported
				    if (typeof ArrayBuffer != 'function') {
				        return;
				    }

				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;

				    // Reference original init
				    var superInit = WordArray.init;

				    // Augment WordArray.init to handle typed arrays
				    var subInit = WordArray.init = function (typedArray) {
				        // Convert buffers to uint8
				        if (typedArray instanceof ArrayBuffer) {
				            typedArray = new Uint8Array(typedArray);
				        }

				        // Convert other array views to uint8
				        if (
				            typedArray instanceof Int8Array ||
				            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
				            typedArray instanceof Int16Array ||
				            typedArray instanceof Uint16Array ||
				            typedArray instanceof Int32Array ||
				            typedArray instanceof Uint32Array ||
				            typedArray instanceof Float32Array ||
				            typedArray instanceof Float64Array
				        ) {
				            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
				        }

				        // Handle Uint8Array
				        if (typedArray instanceof Uint8Array) {
				            // Shortcut
				            var typedArrayByteLength = typedArray.byteLength;

				            // Extract bytes
				            var words = [];
				            for (var i = 0; i < typedArrayByteLength; i++) {
				                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
				            }

				            // Initialize this word array
				            superInit.call(this, words, typedArrayByteLength);
				        } else {
				            // Else call normal init
				            superInit.apply(this, arguments);
				        }
				    };

				    subInit.prototype = WordArray;
				}());


				return CryptoJS.lib.WordArray;

			})); 
		} (libTypedarrays$1));
		return libTypedarrays$1.exports;
	}

	var encUtf16$1 = {exports: {}};

	var encUtf16 = encUtf16$1.exports;

	var hasRequiredEncUtf16;

	function requireEncUtf16 () {
		if (hasRequiredEncUtf16) return encUtf16$1.exports;
		hasRequiredEncUtf16 = 1;
		(function (module, exports) {
	(function (root, factory) {
				{
					// CommonJS
					module.exports = factory(requireCore());
				}
			}(encUtf16, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;
				    var C_enc = C.enc;

				    /**
				     * UTF-16 BE encoding strategy.
				     */
				    C_enc.Utf16 = C_enc.Utf16BE = {
				        /**
				         * Converts a word array to a UTF-16 BE string.
				         *
				         * @param {WordArray} wordArray The word array.
				         *
				         * @return {string} The UTF-16 BE string.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
				         */
				        stringify: function (wordArray) {
				            // Shortcuts
				            var words = wordArray.words;
				            var sigBytes = wordArray.sigBytes;

				            // Convert
				            var utf16Chars = [];
				            for (var i = 0; i < sigBytes; i += 2) {
				                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
				                utf16Chars.push(String.fromCharCode(codePoint));
				            }

				            return utf16Chars.join('');
				        },

				        /**
				         * Converts a UTF-16 BE string to a word array.
				         *
				         * @param {string} utf16Str The UTF-16 BE string.
				         *
				         * @return {WordArray} The word array.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
				         */
				        parse: function (utf16Str) {
				            // Shortcut
				            var utf16StrLength = utf16Str.length;

				            // Convert
				            var words = [];
				            for (var i = 0; i < utf16StrLength; i++) {
				                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
				            }

				            return WordArray.create(words, utf16StrLength * 2);
				        }
				    };

				    /**
				     * UTF-16 LE encoding strategy.
				     */
				    C_enc.Utf16LE = {
				        /**
				         * Converts a word array to a UTF-16 LE string.
				         *
				         * @param {WordArray} wordArray The word array.
				         *
				         * @return {string} The UTF-16 LE string.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
				         */
				        stringify: function (wordArray) {
				            // Shortcuts
				            var words = wordArray.words;
				            var sigBytes = wordArray.sigBytes;

				            // Convert
				            var utf16Chars = [];
				            for (var i = 0; i < sigBytes; i += 2) {
				                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
				                utf16Chars.push(String.fromCharCode(codePoint));
				            }

				            return utf16Chars.join('');
				        },

				        /**
				         * Converts a UTF-16 LE string to a word array.
				         *
				         * @param {string} utf16Str The UTF-16 LE string.
				         *
				         * @return {WordArray} The word array.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
				         */
				        parse: function (utf16Str) {
				            // Shortcut
				            var utf16StrLength = utf16Str.length;

				            // Convert
				            var words = [];
				            for (var i = 0; i < utf16StrLength; i++) {
				                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
				            }

				            return WordArray.create(words, utf16StrLength * 2);
				        }
				    };

				    function swapEndian(word) {
				        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
				    }
				}());


				return CryptoJS.enc.Utf16;

			})); 
		} (encUtf16$1));
		return encUtf16$1.exports;
	}

	var encBase64$1 = {exports: {}};

	var encBase64 = encBase64$1.exports;

	var hasRequiredEncBase64;

	function requireEncBase64 () {
		if (hasRequiredEncBase64) return encBase64$1.exports;
		hasRequiredEncBase64 = 1;
		(function (module, exports) {
	(function (root, factory) {
				{
					// CommonJS
					module.exports = factory(requireCore());
				}
			}(encBase64, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;
				    var C_enc = C.enc;

				    /**
				     * Base64 encoding strategy.
				     */
				    C_enc.Base64 = {
				        /**
				         * Converts a word array to a Base64 string.
				         *
				         * @param {WordArray} wordArray The word array.
				         *
				         * @return {string} The Base64 string.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
				         */
				        stringify: function (wordArray) {
				            // Shortcuts
				            var words = wordArray.words;
				            var sigBytes = wordArray.sigBytes;
				            var map = this._map;

				            // Clamp excess bits
				            wordArray.clamp();

				            // Convert
				            var base64Chars = [];
				            for (var i = 0; i < sigBytes; i += 3) {
				                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
				                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
				                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

				                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

				                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
				                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
				                }
				            }

				            // Add padding
				            var paddingChar = map.charAt(64);
				            if (paddingChar) {
				                while (base64Chars.length % 4) {
				                    base64Chars.push(paddingChar);
				                }
				            }

				            return base64Chars.join('');
				        },

				        /**
				         * Converts a Base64 string to a word array.
				         *
				         * @param {string} base64Str The Base64 string.
				         *
				         * @return {WordArray} The word array.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
				         */
				        parse: function (base64Str) {
				            // Shortcuts
				            var base64StrLength = base64Str.length;
				            var map = this._map;
				            var reverseMap = this._reverseMap;

				            if (!reverseMap) {
				                    reverseMap = this._reverseMap = [];
				                    for (var j = 0; j < map.length; j++) {
				                        reverseMap[map.charCodeAt(j)] = j;
				                    }
				            }

				            // Ignore padding
				            var paddingChar = map.charAt(64);
				            if (paddingChar) {
				                var paddingIndex = base64Str.indexOf(paddingChar);
				                if (paddingIndex !== -1) {
				                    base64StrLength = paddingIndex;
				                }
				            }

				            // Convert
				            return parseLoop(base64Str, base64StrLength, reverseMap);

				        },

				        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
				    };

				    function parseLoop(base64Str, base64StrLength, reverseMap) {
				      var words = [];
				      var nBytes = 0;
				      for (var i = 0; i < base64StrLength; i++) {
				          if (i % 4) {
				              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
				              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
				              var bitsCombined = bits1 | bits2;
				              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
				              nBytes++;
				          }
				      }
				      return WordArray.create(words, nBytes);
				    }
				}());


				return CryptoJS.enc.Base64;

			})); 
		} (encBase64$1));
		return encBase64$1.exports;
	}

	var encBase64url$1 = {exports: {}};

	var encBase64url = encBase64url$1.exports;

	var hasRequiredEncBase64url;

	function requireEncBase64url () {
		if (hasRequiredEncBase64url) return encBase64url$1.exports;
		hasRequiredEncBase64url = 1;
		(function (module, exports) {
	(function (root, factory) {
				{
					// CommonJS
					module.exports = factory(requireCore());
				}
			}(encBase64url, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;
				    var C_enc = C.enc;

				    /**
				     * Base64url encoding strategy.
				     */
				    C_enc.Base64url = {
				        /**
				         * Converts a word array to a Base64url string.
				         *
				         * @param {WordArray} wordArray The word array.
				         *
				         * @param {boolean} urlSafe Whether to use url safe
				         *
				         * @return {string} The Base64url string.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
				         */
				        stringify: function (wordArray, urlSafe) {
				            if (urlSafe === undefined) {
				                urlSafe = true;
				            }
				            // Shortcuts
				            var words = wordArray.words;
				            var sigBytes = wordArray.sigBytes;
				            var map = urlSafe ? this._safe_map : this._map;

				            // Clamp excess bits
				            wordArray.clamp();

				            // Convert
				            var base64Chars = [];
				            for (var i = 0; i < sigBytes; i += 3) {
				                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
				                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
				                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

				                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

				                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
				                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
				                }
				            }

				            // Add padding
				            var paddingChar = map.charAt(64);
				            if (paddingChar) {
				                while (base64Chars.length % 4) {
				                    base64Chars.push(paddingChar);
				                }
				            }

				            return base64Chars.join('');
				        },

				        /**
				         * Converts a Base64url string to a word array.
				         *
				         * @param {string} base64Str The Base64url string.
				         *
				         * @param {boolean} urlSafe Whether to use url safe
				         *
				         * @return {WordArray} The word array.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
				         */
				        parse: function (base64Str, urlSafe) {
				            if (urlSafe === undefined) {
				                urlSafe = true;
				            }

				            // Shortcuts
				            var base64StrLength = base64Str.length;
				            var map = urlSafe ? this._safe_map : this._map;
				            var reverseMap = this._reverseMap;

				            if (!reverseMap) {
				                reverseMap = this._reverseMap = [];
				                for (var j = 0; j < map.length; j++) {
				                    reverseMap[map.charCodeAt(j)] = j;
				                }
				            }

				            // Ignore padding
				            var paddingChar = map.charAt(64);
				            if (paddingChar) {
				                var paddingIndex = base64Str.indexOf(paddingChar);
				                if (paddingIndex !== -1) {
				                    base64StrLength = paddingIndex;
				                }
				            }

				            // Convert
				            return parseLoop(base64Str, base64StrLength, reverseMap);

				        },

				        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
				        _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
				    };

				    function parseLoop(base64Str, base64StrLength, reverseMap) {
				        var words = [];
				        var nBytes = 0;
				        for (var i = 0; i < base64StrLength; i++) {
				            if (i % 4) {
				                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
				                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
				                var bitsCombined = bits1 | bits2;
				                words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
				                nBytes++;
				            }
				        }
				        return WordArray.create(words, nBytes);
				    }
				}());


				return CryptoJS.enc.Base64url;

			})); 
		} (encBase64url$1));
		return encBase64url$1.exports;
	}

	var md5$1 = {exports: {}};

	var md5 = md5$1.exports;

	var hasRequiredMd5;

	function requireMd5 () {
		if (hasRequiredMd5) return md5$1.exports;
		hasRequiredMd5 = 1;
		(function (module, exports) {
	(function (root, factory) {
				{
					// CommonJS
					module.exports = factory(requireCore());
				}
			}(md5, function (CryptoJS) {

				(function (Math) {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;
				    var Hasher = C_lib.Hasher;
				    var C_algo = C.algo;

				    // Constants table
				    var T = [];

				    // Compute constants
				    (function () {
				        for (var i = 0; i < 64; i++) {
				            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
				        }
				    }());

				    /**
				     * MD5 hash algorithm.
				     */
				    var MD5 = C_algo.MD5 = Hasher.extend({
				        _doReset: function () {
				            this._hash = new WordArray.init([
				                0x67452301, 0xefcdab89,
				                0x98badcfe, 0x10325476
				            ]);
				        },

				        _doProcessBlock: function (M, offset) {
				            // Swap endian
				            for (var i = 0; i < 16; i++) {
				                // Shortcuts
				                var offset_i = offset + i;
				                var M_offset_i = M[offset_i];

				                M[offset_i] = (
				                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
				                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
				                );
				            }

				            // Shortcuts
				            var H = this._hash.words;

				            var M_offset_0  = M[offset + 0];
				            var M_offset_1  = M[offset + 1];
				            var M_offset_2  = M[offset + 2];
				            var M_offset_3  = M[offset + 3];
				            var M_offset_4  = M[offset + 4];
				            var M_offset_5  = M[offset + 5];
				            var M_offset_6  = M[offset + 6];
				            var M_offset_7  = M[offset + 7];
				            var M_offset_8  = M[offset + 8];
				            var M_offset_9  = M[offset + 9];
				            var M_offset_10 = M[offset + 10];
				            var M_offset_11 = M[offset + 11];
				            var M_offset_12 = M[offset + 12];
				            var M_offset_13 = M[offset + 13];
				            var M_offset_14 = M[offset + 14];
				            var M_offset_15 = M[offset + 15];

				            // Working variables
				            var a = H[0];
				            var b = H[1];
				            var c = H[2];
				            var d = H[3];

				            // Computation
				            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
				            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
				            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
				            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
				            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
				            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
				            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
				            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
				            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
				            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
				            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
				            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
				            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
				            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
				            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
				            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

				            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
				            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
				            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
				            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
				            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
				            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
				            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
				            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
				            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
				            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
				            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
				            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
				            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
				            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
				            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
				            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

				            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
				            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
				            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
				            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
				            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
				            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
				            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
				            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
				            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
				            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
				            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
				            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
				            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
				            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
				            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
				            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

				            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
				            d = II(d, a, b, c, M_offset_7,  10, T[49]);
				            c = II(c, d, a, b, M_offset_14, 15, T[50]);
				            b = II(b, c, d, a, M_offset_5,  21, T[51]);
				            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
				            d = II(d, a, b, c, M_offset_3,  10, T[53]);
				            c = II(c, d, a, b, M_offset_10, 15, T[54]);
				            b = II(b, c, d, a, M_offset_1,  21, T[55]);
				            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
				            d = II(d, a, b, c, M_offset_15, 10, T[57]);
				            c = II(c, d, a, b, M_offset_6,  15, T[58]);
				            b = II(b, c, d, a, M_offset_13, 21, T[59]);
				            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
				            d = II(d, a, b, c, M_offset_11, 10, T[61]);
				            c = II(c, d, a, b, M_offset_2,  15, T[62]);
				            b = II(b, c, d, a, M_offset_9,  21, T[63]);

				            // Intermediate hash value
				            H[0] = (H[0] + a) | 0;
				            H[1] = (H[1] + b) | 0;
				            H[2] = (H[2] + c) | 0;
				            H[3] = (H[3] + d) | 0;
				        },

				        _doFinalize: function () {
				            // Shortcuts
				            var data = this._data;
				            var dataWords = data.words;

				            var nBitsTotal = this._nDataBytes * 8;
				            var nBitsLeft = data.sigBytes * 8;

				            // Add padding
				            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

				            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
				            var nBitsTotalL = nBitsTotal;
				            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
				                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
				                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
				            );
				            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
				                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
				                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
				            );

				            data.sigBytes = (dataWords.length + 1) * 4;

				            // Hash final blocks
				            this._process();

				            // Shortcuts
				            var hash = this._hash;
				            var H = hash.words;

				            // Swap endian
				            for (var i = 0; i < 4; i++) {
				                // Shortcut
				                var H_i = H[i];

				                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
				                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
				            }

				            // Return final computed hash
				            return hash;
				        },

				        clone: function () {
				            var clone = Hasher.clone.call(this);
				            clone._hash = this._hash.clone();

				            return clone;
				        }
				    });

				    function FF(a, b, c, d, x, s, t) {
				        var n = a + ((b & c) | (~b & d)) + x + t;
				        return ((n << s) | (n >>> (32 - s))) + b;
				    }

				    function GG(a, b, c, d, x, s, t) {
				        var n = a + ((b & d) | (c & ~d)) + x + t;
				        return ((n << s) | (n >>> (32 - s))) + b;
				    }

				    function HH(a, b, c, d, x, s, t) {
				        var n = a + (b ^ c ^ d) + x + t;
				        return ((n << s) | (n >>> (32 - s))) + b;
				    }

				    function II(a, b, c, d, x, s, t) {
				        var n = a + (c ^ (b | ~d)) + x + t;
				        return ((n << s) | (n >>> (32 - s))) + b;
				    }

				    /**
				     * Shortcut function to the hasher's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     *
				     * @return {WordArray} The hash.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hash = CryptoJS.MD5('message');
				     *     var hash = CryptoJS.MD5(wordArray);
				     */
				    C.MD5 = Hasher._createHelper(MD5);

				    /**
				     * Shortcut function to the HMAC's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     * @param {WordArray|string} key The secret key.
				     *
				     * @return {WordArray} The HMAC.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hmac = CryptoJS.HmacMD5(message, key);
				     */
				    C.HmacMD5 = Hasher._createHmacHelper(MD5);
				}(Math));


				return CryptoJS.MD5;

			})); 
		} (md5$1));
		return md5$1.exports;
	}

	var sha1$1 = {exports: {}};

	var sha1 = sha1$1.exports;

	var hasRequiredSha1;

	function requireSha1 () {
		if (hasRequiredSha1) return sha1$1.exports;
		hasRequiredSha1 = 1;
		(function (module, exports) {
	(function (root, factory) {
				{
					// CommonJS
					module.exports = factory(requireCore());
				}
			}(sha1, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;
				    var Hasher = C_lib.Hasher;
				    var C_algo = C.algo;

				    // Reusable object
				    var W = [];

				    /**
				     * SHA-1 hash algorithm.
				     */
				    var SHA1 = C_algo.SHA1 = Hasher.extend({
				        _doReset: function () {
				            this._hash = new WordArray.init([
				                0x67452301, 0xefcdab89,
				                0x98badcfe, 0x10325476,
				                0xc3d2e1f0
				            ]);
				        },

				        _doProcessBlock: function (M, offset) {
				            // Shortcut
				            var H = this._hash.words;

				            // Working variables
				            var a = H[0];
				            var b = H[1];
				            var c = H[2];
				            var d = H[3];
				            var e = H[4];

				            // Computation
				            for (var i = 0; i < 80; i++) {
				                if (i < 16) {
				                    W[i] = M[offset + i] | 0;
				                } else {
				                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
				                    W[i] = (n << 1) | (n >>> 31);
				                }

				                var t = ((a << 5) | (a >>> 27)) + e + W[i];
				                if (i < 20) {
				                    t += ((b & c) | (~b & d)) + 0x5a827999;
				                } else if (i < 40) {
				                    t += (b ^ c ^ d) + 0x6ed9eba1;
				                } else if (i < 60) {
				                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
				                } else /* if (i < 80) */ {
				                    t += (b ^ c ^ d) - 0x359d3e2a;
				                }

				                e = d;
				                d = c;
				                c = (b << 30) | (b >>> 2);
				                b = a;
				                a = t;
				            }

				            // Intermediate hash value
				            H[0] = (H[0] + a) | 0;
				            H[1] = (H[1] + b) | 0;
				            H[2] = (H[2] + c) | 0;
				            H[3] = (H[3] + d) | 0;
				            H[4] = (H[4] + e) | 0;
				        },

				        _doFinalize: function () {
				            // Shortcuts
				            var data = this._data;
				            var dataWords = data.words;

				            var nBitsTotal = this._nDataBytes * 8;
				            var nBitsLeft = data.sigBytes * 8;

				            // Add padding
				            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
				            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
				            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
				            data.sigBytes = dataWords.length * 4;

				            // Hash final blocks
				            this._process();

				            // Return final computed hash
				            return this._hash;
				        },

				        clone: function () {
				            var clone = Hasher.clone.call(this);
				            clone._hash = this._hash.clone();

				            return clone;
				        }
				    });

				    /**
				     * Shortcut function to the hasher's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     *
				     * @return {WordArray} The hash.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hash = CryptoJS.SHA1('message');
				     *     var hash = CryptoJS.SHA1(wordArray);
				     */
				    C.SHA1 = Hasher._createHelper(SHA1);

				    /**
				     * Shortcut function to the HMAC's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     * @param {WordArray|string} key The secret key.
				     *
				     * @return {WordArray} The HMAC.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hmac = CryptoJS.HmacSHA1(message, key);
				     */
				    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
				}());


				return CryptoJS.SHA1;

			})); 
		} (sha1$1));
		return sha1$1.exports;
	}

	var sha256$1 = {exports: {}};

	var sha256 = sha256$1.exports;

	var hasRequiredSha256;

	function requireSha256 () {
		if (hasRequiredSha256) return sha256$1.exports;
		hasRequiredSha256 = 1;
		(function (module, exports) {
	(function (root, factory) {
				{
					// CommonJS
					module.exports = factory(requireCore());
				}
			}(sha256, function (CryptoJS) {

				(function (Math) {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;
				    var Hasher = C_lib.Hasher;
				    var C_algo = C.algo;

				    // Initialization and round constants tables
				    var H = [];
				    var K = [];

				    // Compute constants
				    (function () {
				        function isPrime(n) {
				            var sqrtN = Math.sqrt(n);
				            for (var factor = 2; factor <= sqrtN; factor++) {
				                if (!(n % factor)) {
				                    return false;
				                }
				            }

				            return true;
				        }

				        function getFractionalBits(n) {
				            return ((n - (n | 0)) * 0x100000000) | 0;
				        }

				        var n = 2;
				        var nPrime = 0;
				        while (nPrime < 64) {
				            if (isPrime(n)) {
				                if (nPrime < 8) {
				                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
				                }
				                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

				                nPrime++;
				            }

				            n++;
				        }
				    }());

				    // Reusable object
				    var W = [];

				    /**
				     * SHA-256 hash algorithm.
				     */
				    var SHA256 = C_algo.SHA256 = Hasher.extend({
				        _doReset: function () {
				            this._hash = new WordArray.init(H.slice(0));
				        },

				        _doProcessBlock: function (M, offset) {
				            // Shortcut
				            var H = this._hash.words;

				            // Working variables
				            var a = H[0];
				            var b = H[1];
				            var c = H[2];
				            var d = H[3];
				            var e = H[4];
				            var f = H[5];
				            var g = H[6];
				            var h = H[7];

				            // Computation
				            for (var i = 0; i < 64; i++) {
				                if (i < 16) {
				                    W[i] = M[offset + i] | 0;
				                } else {
				                    var gamma0x = W[i - 15];
				                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
				                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
				                                   (gamma0x >>> 3);

				                    var gamma1x = W[i - 2];
				                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
				                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
				                                   (gamma1x >>> 10);

				                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
				                }

				                var ch  = (e & f) ^ (~e & g);
				                var maj = (a & b) ^ (a & c) ^ (b & c);

				                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
				                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

				                var t1 = h + sigma1 + ch + K[i] + W[i];
				                var t2 = sigma0 + maj;

				                h = g;
				                g = f;
				                f = e;
				                e = (d + t1) | 0;
				                d = c;
				                c = b;
				                b = a;
				                a = (t1 + t2) | 0;
				            }

				            // Intermediate hash value
				            H[0] = (H[0] + a) | 0;
				            H[1] = (H[1] + b) | 0;
				            H[2] = (H[2] + c) | 0;
				            H[3] = (H[3] + d) | 0;
				            H[4] = (H[4] + e) | 0;
				            H[5] = (H[5] + f) | 0;
				            H[6] = (H[6] + g) | 0;
				            H[7] = (H[7] + h) | 0;
				        },

				        _doFinalize: function () {
				            // Shortcuts
				            var data = this._data;
				            var dataWords = data.words;

				            var nBitsTotal = this._nDataBytes * 8;
				            var nBitsLeft = data.sigBytes * 8;

				            // Add padding
				            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
				            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
				            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
				            data.sigBytes = dataWords.length * 4;

				            // Hash final blocks
				            this._process();

				            // Return final computed hash
				            return this._hash;
				        },

				        clone: function () {
				            var clone = Hasher.clone.call(this);
				            clone._hash = this._hash.clone();

				            return clone;
				        }
				    });

				    /**
				     * Shortcut function to the hasher's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     *
				     * @return {WordArray} The hash.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hash = CryptoJS.SHA256('message');
				     *     var hash = CryptoJS.SHA256(wordArray);
				     */
				    C.SHA256 = Hasher._createHelper(SHA256);

				    /**
				     * Shortcut function to the HMAC's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     * @param {WordArray|string} key The secret key.
				     *
				     * @return {WordArray} The HMAC.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hmac = CryptoJS.HmacSHA256(message, key);
				     */
				    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
				}(Math));


				return CryptoJS.SHA256;

			})); 
		} (sha256$1));
		return sha256$1.exports;
	}

	var sha224$1 = {exports: {}};

	var sha224 = sha224$1.exports;

	var hasRequiredSha224;

	function requireSha224 () {
		if (hasRequiredSha224) return sha224$1.exports;
		hasRequiredSha224 = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireSha256());
				}
			}(sha224, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;
				    var C_algo = C.algo;
				    var SHA256 = C_algo.SHA256;

				    /**
				     * SHA-224 hash algorithm.
				     */
				    var SHA224 = C_algo.SHA224 = SHA256.extend({
				        _doReset: function () {
				            this._hash = new WordArray.init([
				                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
				                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
				            ]);
				        },

				        _doFinalize: function () {
				            var hash = SHA256._doFinalize.call(this);

				            hash.sigBytes -= 4;

				            return hash;
				        }
				    });

				    /**
				     * Shortcut function to the hasher's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     *
				     * @return {WordArray} The hash.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hash = CryptoJS.SHA224('message');
				     *     var hash = CryptoJS.SHA224(wordArray);
				     */
				    C.SHA224 = SHA256._createHelper(SHA224);

				    /**
				     * Shortcut function to the HMAC's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     * @param {WordArray|string} key The secret key.
				     *
				     * @return {WordArray} The HMAC.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hmac = CryptoJS.HmacSHA224(message, key);
				     */
				    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
				}());


				return CryptoJS.SHA224;

			})); 
		} (sha224$1));
		return sha224$1.exports;
	}

	var sha512$1 = {exports: {}};

	var sha512 = sha512$1.exports;

	var hasRequiredSha512;

	function requireSha512 () {
		if (hasRequiredSha512) return sha512$1.exports;
		hasRequiredSha512 = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireX64Core());
				}
			}(sha512, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var Hasher = C_lib.Hasher;
				    var C_x64 = C.x64;
				    var X64Word = C_x64.Word;
				    var X64WordArray = C_x64.WordArray;
				    var C_algo = C.algo;

				    function X64Word_create() {
				        return X64Word.create.apply(X64Word, arguments);
				    }

				    // Constants
				    var K = [
				        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
				        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
				        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
				        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
				        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
				        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
				        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
				        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
				        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
				        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
				        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
				        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
				        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
				        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
				        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
				        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
				        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
				        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
				        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
				        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
				        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
				        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
				        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
				        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
				        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
				        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
				        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
				        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
				        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
				        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
				        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
				        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
				        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
				        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
				        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
				        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
				        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
				        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
				        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
				        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
				    ];

				    // Reusable objects
				    var W = [];
				    (function () {
				        for (var i = 0; i < 80; i++) {
				            W[i] = X64Word_create();
				        }
				    }());

				    /**
				     * SHA-512 hash algorithm.
				     */
				    var SHA512 = C_algo.SHA512 = Hasher.extend({
				        _doReset: function () {
				            this._hash = new X64WordArray.init([
				                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
				                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
				                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
				                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
				            ]);
				        },

				        _doProcessBlock: function (M, offset) {
				            // Shortcuts
				            var H = this._hash.words;

				            var H0 = H[0];
				            var H1 = H[1];
				            var H2 = H[2];
				            var H3 = H[3];
				            var H4 = H[4];
				            var H5 = H[5];
				            var H6 = H[6];
				            var H7 = H[7];

				            var H0h = H0.high;
				            var H0l = H0.low;
				            var H1h = H1.high;
				            var H1l = H1.low;
				            var H2h = H2.high;
				            var H2l = H2.low;
				            var H3h = H3.high;
				            var H3l = H3.low;
				            var H4h = H4.high;
				            var H4l = H4.low;
				            var H5h = H5.high;
				            var H5l = H5.low;
				            var H6h = H6.high;
				            var H6l = H6.low;
				            var H7h = H7.high;
				            var H7l = H7.low;

				            // Working variables
				            var ah = H0h;
				            var al = H0l;
				            var bh = H1h;
				            var bl = H1l;
				            var ch = H2h;
				            var cl = H2l;
				            var dh = H3h;
				            var dl = H3l;
				            var eh = H4h;
				            var el = H4l;
				            var fh = H5h;
				            var fl = H5l;
				            var gh = H6h;
				            var gl = H6l;
				            var hh = H7h;
				            var hl = H7l;

				            // Rounds
				            for (var i = 0; i < 80; i++) {
				                var Wil;
				                var Wih;

				                // Shortcut
				                var Wi = W[i];

				                // Extend message
				                if (i < 16) {
				                    Wih = Wi.high = M[offset + i * 2]     | 0;
				                    Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
				                } else {
				                    // Gamma0
				                    var gamma0x  = W[i - 15];
				                    var gamma0xh = gamma0x.high;
				                    var gamma0xl = gamma0x.low;
				                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
				                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

				                    // Gamma1
				                    var gamma1x  = W[i - 2];
				                    var gamma1xh = gamma1x.high;
				                    var gamma1xl = gamma1x.low;
				                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
				                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

				                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
				                    var Wi7  = W[i - 7];
				                    var Wi7h = Wi7.high;
				                    var Wi7l = Wi7.low;

				                    var Wi16  = W[i - 16];
				                    var Wi16h = Wi16.high;
				                    var Wi16l = Wi16.low;

				                    Wil = gamma0l + Wi7l;
				                    Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
				                    Wil = Wil + gamma1l;
				                    Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
				                    Wil = Wil + Wi16l;
				                    Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

				                    Wi.high = Wih;
				                    Wi.low  = Wil;
				                }

				                var chh  = (eh & fh) ^ (~eh & gh);
				                var chl  = (el & fl) ^ (~el & gl);
				                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
				                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

				                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
				                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
				                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
				                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

				                // t1 = h + sigma1 + ch + K[i] + W[i]
				                var Ki  = K[i];
				                var Kih = Ki.high;
				                var Kil = Ki.low;

				                var t1l = hl + sigma1l;
				                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
				                var t1l = t1l + chl;
				                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
				                var t1l = t1l + Kil;
				                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
				                var t1l = t1l + Wil;
				                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

				                // t2 = sigma0 + maj
				                var t2l = sigma0l + majl;
				                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

				                // Update working variables
				                hh = gh;
				                hl = gl;
				                gh = fh;
				                gl = fl;
				                fh = eh;
				                fl = el;
				                el = (dl + t1l) | 0;
				                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
				                dh = ch;
				                dl = cl;
				                ch = bh;
				                cl = bl;
				                bh = ah;
				                bl = al;
				                al = (t1l + t2l) | 0;
				                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
				            }

				            // Intermediate hash value
				            H0l = H0.low  = (H0l + al);
				            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
				            H1l = H1.low  = (H1l + bl);
				            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
				            H2l = H2.low  = (H2l + cl);
				            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
				            H3l = H3.low  = (H3l + dl);
				            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
				            H4l = H4.low  = (H4l + el);
				            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
				            H5l = H5.low  = (H5l + fl);
				            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
				            H6l = H6.low  = (H6l + gl);
				            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
				            H7l = H7.low  = (H7l + hl);
				            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
				        },

				        _doFinalize: function () {
				            // Shortcuts
				            var data = this._data;
				            var dataWords = data.words;

				            var nBitsTotal = this._nDataBytes * 8;
				            var nBitsLeft = data.sigBytes * 8;

				            // Add padding
				            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
				            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
				            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
				            data.sigBytes = dataWords.length * 4;

				            // Hash final blocks
				            this._process();

				            // Convert hash to 32-bit word array before returning
				            var hash = this._hash.toX32();

				            // Return final computed hash
				            return hash;
				        },

				        clone: function () {
				            var clone = Hasher.clone.call(this);
				            clone._hash = this._hash.clone();

				            return clone;
				        },

				        blockSize: 1024/32
				    });

				    /**
				     * Shortcut function to the hasher's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     *
				     * @return {WordArray} The hash.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hash = CryptoJS.SHA512('message');
				     *     var hash = CryptoJS.SHA512(wordArray);
				     */
				    C.SHA512 = Hasher._createHelper(SHA512);

				    /**
				     * Shortcut function to the HMAC's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     * @param {WordArray|string} key The secret key.
				     *
				     * @return {WordArray} The HMAC.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hmac = CryptoJS.HmacSHA512(message, key);
				     */
				    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
				}());


				return CryptoJS.SHA512;

			})); 
		} (sha512$1));
		return sha512$1.exports;
	}

	var sha384$1 = {exports: {}};

	var sha384 = sha384$1.exports;

	var hasRequiredSha384;

	function requireSha384 () {
		if (hasRequiredSha384) return sha384$1.exports;
		hasRequiredSha384 = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireX64Core(), requireSha512());
				}
			}(sha384, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_x64 = C.x64;
				    var X64Word = C_x64.Word;
				    var X64WordArray = C_x64.WordArray;
				    var C_algo = C.algo;
				    var SHA512 = C_algo.SHA512;

				    /**
				     * SHA-384 hash algorithm.
				     */
				    var SHA384 = C_algo.SHA384 = SHA512.extend({
				        _doReset: function () {
				            this._hash = new X64WordArray.init([
				                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
				                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
				                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
				                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
				            ]);
				        },

				        _doFinalize: function () {
				            var hash = SHA512._doFinalize.call(this);

				            hash.sigBytes -= 16;

				            return hash;
				        }
				    });

				    /**
				     * Shortcut function to the hasher's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     *
				     * @return {WordArray} The hash.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hash = CryptoJS.SHA384('message');
				     *     var hash = CryptoJS.SHA384(wordArray);
				     */
				    C.SHA384 = SHA512._createHelper(SHA384);

				    /**
				     * Shortcut function to the HMAC's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     * @param {WordArray|string} key The secret key.
				     *
				     * @return {WordArray} The HMAC.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hmac = CryptoJS.HmacSHA384(message, key);
				     */
				    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
				}());


				return CryptoJS.SHA384;

			})); 
		} (sha384$1));
		return sha384$1.exports;
	}

	var sha3$1 = {exports: {}};

	var sha3 = sha3$1.exports;

	var hasRequiredSha3;

	function requireSha3 () {
		if (hasRequiredSha3) return sha3$1.exports;
		hasRequiredSha3 = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireX64Core());
				}
			}(sha3, function (CryptoJS) {

				(function (Math) {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;
				    var Hasher = C_lib.Hasher;
				    var C_x64 = C.x64;
				    var X64Word = C_x64.Word;
				    var C_algo = C.algo;

				    // Constants tables
				    var RHO_OFFSETS = [];
				    var PI_INDEXES  = [];
				    var ROUND_CONSTANTS = [];

				    // Compute Constants
				    (function () {
				        // Compute rho offset constants
				        var x = 1, y = 0;
				        for (var t = 0; t < 24; t++) {
				            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

				            var newX = y % 5;
				            var newY = (2 * x + 3 * y) % 5;
				            x = newX;
				            y = newY;
				        }

				        // Compute pi index constants
				        for (var x = 0; x < 5; x++) {
				            for (var y = 0; y < 5; y++) {
				                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
				            }
				        }

				        // Compute round constants
				        var LFSR = 0x01;
				        for (var i = 0; i < 24; i++) {
				            var roundConstantMsw = 0;
				            var roundConstantLsw = 0;

				            for (var j = 0; j < 7; j++) {
				                if (LFSR & 0x01) {
				                    var bitPosition = (1 << j) - 1;
				                    if (bitPosition < 32) {
				                        roundConstantLsw ^= 1 << bitPosition;
				                    } else /* if (bitPosition >= 32) */ {
				                        roundConstantMsw ^= 1 << (bitPosition - 32);
				                    }
				                }

				                // Compute next LFSR
				                if (LFSR & 0x80) {
				                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
				                    LFSR = (LFSR << 1) ^ 0x71;
				                } else {
				                    LFSR <<= 1;
				                }
				            }

				            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
				        }
				    }());

				    // Reusable objects for temporary values
				    var T = [];
				    (function () {
				        for (var i = 0; i < 25; i++) {
				            T[i] = X64Word.create();
				        }
				    }());

				    /**
				     * SHA-3 hash algorithm.
				     */
				    var SHA3 = C_algo.SHA3 = Hasher.extend({
				        /**
				         * Configuration options.
				         *
				         * @property {number} outputLength
				         *   The desired number of bits in the output hash.
				         *   Only values permitted are: 224, 256, 384, 512.
				         *   Default: 512
				         */
				        cfg: Hasher.cfg.extend({
				            outputLength: 512
				        }),

				        _doReset: function () {
				            var state = this._state = [];
				            for (var i = 0; i < 25; i++) {
				                state[i] = new X64Word.init();
				            }

				            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
				        },

				        _doProcessBlock: function (M, offset) {
				            // Shortcuts
				            var state = this._state;
				            var nBlockSizeLanes = this.blockSize / 2;

				            // Absorb
				            for (var i = 0; i < nBlockSizeLanes; i++) {
				                // Shortcuts
				                var M2i  = M[offset + 2 * i];
				                var M2i1 = M[offset + 2 * i + 1];

				                // Swap endian
				                M2i = (
				                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
				                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
				                );
				                M2i1 = (
				                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
				                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
				                );

				                // Absorb message into state
				                var lane = state[i];
				                lane.high ^= M2i1;
				                lane.low  ^= M2i;
				            }

				            // Rounds
				            for (var round = 0; round < 24; round++) {
				                // Theta
				                for (var x = 0; x < 5; x++) {
				                    // Mix column lanes
				                    var tMsw = 0, tLsw = 0;
				                    for (var y = 0; y < 5; y++) {
				                        var lane = state[x + 5 * y];
				                        tMsw ^= lane.high;
				                        tLsw ^= lane.low;
				                    }

				                    // Temporary values
				                    var Tx = T[x];
				                    Tx.high = tMsw;
				                    Tx.low  = tLsw;
				                }
				                for (var x = 0; x < 5; x++) {
				                    // Shortcuts
				                    var Tx4 = T[(x + 4) % 5];
				                    var Tx1 = T[(x + 1) % 5];
				                    var Tx1Msw = Tx1.high;
				                    var Tx1Lsw = Tx1.low;

				                    // Mix surrounding columns
				                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
				                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
				                    for (var y = 0; y < 5; y++) {
				                        var lane = state[x + 5 * y];
				                        lane.high ^= tMsw;
				                        lane.low  ^= tLsw;
				                    }
				                }

				                // Rho Pi
				                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
				                    var tMsw;
				                    var tLsw;

				                    // Shortcuts
				                    var lane = state[laneIndex];
				                    var laneMsw = lane.high;
				                    var laneLsw = lane.low;
				                    var rhoOffset = RHO_OFFSETS[laneIndex];

				                    // Rotate lanes
				                    if (rhoOffset < 32) {
				                        tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
				                        tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
				                    } else /* if (rhoOffset >= 32) */ {
				                        tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
				                        tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
				                    }

				                    // Transpose lanes
				                    var TPiLane = T[PI_INDEXES[laneIndex]];
				                    TPiLane.high = tMsw;
				                    TPiLane.low  = tLsw;
				                }

				                // Rho pi at x = y = 0
				                var T0 = T[0];
				                var state0 = state[0];
				                T0.high = state0.high;
				                T0.low  = state0.low;

				                // Chi
				                for (var x = 0; x < 5; x++) {
				                    for (var y = 0; y < 5; y++) {
				                        // Shortcuts
				                        var laneIndex = x + 5 * y;
				                        var lane = state[laneIndex];
				                        var TLane = T[laneIndex];
				                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
				                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

				                        // Mix rows
				                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
				                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
				                    }
				                }

				                // Iota
				                var lane = state[0];
				                var roundConstant = ROUND_CONSTANTS[round];
				                lane.high ^= roundConstant.high;
				                lane.low  ^= roundConstant.low;
				            }
				        },

				        _doFinalize: function () {
				            // Shortcuts
				            var data = this._data;
				            var dataWords = data.words;
				            this._nDataBytes * 8;
				            var nBitsLeft = data.sigBytes * 8;
				            var blockSizeBits = this.blockSize * 32;

				            // Add padding
				            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
				            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
				            data.sigBytes = dataWords.length * 4;

				            // Hash final blocks
				            this._process();

				            // Shortcuts
				            var state = this._state;
				            var outputLengthBytes = this.cfg.outputLength / 8;
				            var outputLengthLanes = outputLengthBytes / 8;

				            // Squeeze
				            var hashWords = [];
				            for (var i = 0; i < outputLengthLanes; i++) {
				                // Shortcuts
				                var lane = state[i];
				                var laneMsw = lane.high;
				                var laneLsw = lane.low;

				                // Swap endian
				                laneMsw = (
				                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
				                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
				                );
				                laneLsw = (
				                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
				                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
				                );

				                // Squeeze state to retrieve hash
				                hashWords.push(laneLsw);
				                hashWords.push(laneMsw);
				            }

				            // Return final computed hash
				            return new WordArray.init(hashWords, outputLengthBytes);
				        },

				        clone: function () {
				            var clone = Hasher.clone.call(this);

				            var state = clone._state = this._state.slice(0);
				            for (var i = 0; i < 25; i++) {
				                state[i] = state[i].clone();
				            }

				            return clone;
				        }
				    });

				    /**
				     * Shortcut function to the hasher's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     *
				     * @return {WordArray} The hash.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hash = CryptoJS.SHA3('message');
				     *     var hash = CryptoJS.SHA3(wordArray);
				     */
				    C.SHA3 = Hasher._createHelper(SHA3);

				    /**
				     * Shortcut function to the HMAC's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     * @param {WordArray|string} key The secret key.
				     *
				     * @return {WordArray} The HMAC.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hmac = CryptoJS.HmacSHA3(message, key);
				     */
				    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
				}(Math));


				return CryptoJS.SHA3;

			})); 
		} (sha3$1));
		return sha3$1.exports;
	}

	var ripemd160$1 = {exports: {}};

	var ripemd160 = ripemd160$1.exports;

	var hasRequiredRipemd160;

	function requireRipemd160 () {
		if (hasRequiredRipemd160) return ripemd160$1.exports;
		hasRequiredRipemd160 = 1;
		(function (module, exports) {
	(function (root, factory) {
				{
					// CommonJS
					module.exports = factory(requireCore());
				}
			}(ripemd160, function (CryptoJS) {

				/** @preserve
				(c) 2012 by Cédric Mesnil. All rights reserved.

				Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

				    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
				    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

				THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
				*/

				(function (Math) {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;
				    var Hasher = C_lib.Hasher;
				    var C_algo = C.algo;

				    // Constants table
				    var _zl = WordArray.create([
				        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
				        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
				        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
				        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
				        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
				    var _zr = WordArray.create([
				        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
				        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
				        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
				        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
				        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
				    var _sl = WordArray.create([
				         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
				        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
				        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
				          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
				        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
				    var _sr = WordArray.create([
				        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
				        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
				        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
				        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
				        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

				    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
				    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

				    /**
				     * RIPEMD160 hash algorithm.
				     */
				    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
				        _doReset: function () {
				            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
				        },

				        _doProcessBlock: function (M, offset) {

				            // Swap endian
				            for (var i = 0; i < 16; i++) {
				                // Shortcuts
				                var offset_i = offset + i;
				                var M_offset_i = M[offset_i];

				                // Swap
				                M[offset_i] = (
				                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
				                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
				                );
				            }
				            // Shortcut
				            var H  = this._hash.words;
				            var hl = _hl.words;
				            var hr = _hr.words;
				            var zl = _zl.words;
				            var zr = _zr.words;
				            var sl = _sl.words;
				            var sr = _sr.words;

				            // Working variables
				            var al, bl, cl, dl, el;
				            var ar, br, cr, dr, er;

				            ar = al = H[0];
				            br = bl = H[1];
				            cr = cl = H[2];
				            dr = dl = H[3];
				            er = el = H[4];
				            // Computation
				            var t;
				            for (var i = 0; i < 80; i += 1) {
				                t = (al +  M[offset+zl[i]])|0;
				                if (i<16){
					            t +=  f1(bl,cl,dl) + hl[0];
				                } else if (i<32) {
					            t +=  f2(bl,cl,dl) + hl[1];
				                } else if (i<48) {
					            t +=  f3(bl,cl,dl) + hl[2];
				                } else if (i<64) {
					            t +=  f4(bl,cl,dl) + hl[3];
				                } else {// if (i<80) {
					            t +=  f5(bl,cl,dl) + hl[4];
				                }
				                t = t|0;
				                t =  rotl(t,sl[i]);
				                t = (t+el)|0;
				                al = el;
				                el = dl;
				                dl = rotl(cl, 10);
				                cl = bl;
				                bl = t;

				                t = (ar + M[offset+zr[i]])|0;
				                if (i<16){
					            t +=  f5(br,cr,dr) + hr[0];
				                } else if (i<32) {
					            t +=  f4(br,cr,dr) + hr[1];
				                } else if (i<48) {
					            t +=  f3(br,cr,dr) + hr[2];
				                } else if (i<64) {
					            t +=  f2(br,cr,dr) + hr[3];
				                } else {// if (i<80) {
					            t +=  f1(br,cr,dr) + hr[4];
				                }
				                t = t|0;
				                t =  rotl(t,sr[i]) ;
				                t = (t+er)|0;
				                ar = er;
				                er = dr;
				                dr = rotl(cr, 10);
				                cr = br;
				                br = t;
				            }
				            // Intermediate hash value
				            t    = (H[1] + cl + dr)|0;
				            H[1] = (H[2] + dl + er)|0;
				            H[2] = (H[3] + el + ar)|0;
				            H[3] = (H[4] + al + br)|0;
				            H[4] = (H[0] + bl + cr)|0;
				            H[0] =  t;
				        },

				        _doFinalize: function () {
				            // Shortcuts
				            var data = this._data;
				            var dataWords = data.words;

				            var nBitsTotal = this._nDataBytes * 8;
				            var nBitsLeft = data.sigBytes * 8;

				            // Add padding
				            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
				            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
				                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
				                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
				            );
				            data.sigBytes = (dataWords.length + 1) * 4;

				            // Hash final blocks
				            this._process();

				            // Shortcuts
				            var hash = this._hash;
				            var H = hash.words;

				            // Swap endian
				            for (var i = 0; i < 5; i++) {
				                // Shortcut
				                var H_i = H[i];

				                // Swap
				                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
				                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
				            }

				            // Return final computed hash
				            return hash;
				        },

				        clone: function () {
				            var clone = Hasher.clone.call(this);
				            clone._hash = this._hash.clone();

				            return clone;
				        }
				    });


				    function f1(x, y, z) {
				        return ((x) ^ (y) ^ (z));

				    }

				    function f2(x, y, z) {
				        return (((x)&(y)) | ((~x)&(z)));
				    }

				    function f3(x, y, z) {
				        return (((x) | (~(y))) ^ (z));
				    }

				    function f4(x, y, z) {
				        return (((x) & (z)) | ((y)&(~(z))));
				    }

				    function f5(x, y, z) {
				        return ((x) ^ ((y) |(~(z))));

				    }

				    function rotl(x,n) {
				        return (x<<n) | (x>>>(32-n));
				    }


				    /**
				     * Shortcut function to the hasher's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     *
				     * @return {WordArray} The hash.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hash = CryptoJS.RIPEMD160('message');
				     *     var hash = CryptoJS.RIPEMD160(wordArray);
				     */
				    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

				    /**
				     * Shortcut function to the HMAC's object interface.
				     *
				     * @param {WordArray|string} message The message to hash.
				     * @param {WordArray|string} key The secret key.
				     *
				     * @return {WordArray} The HMAC.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
				     */
				    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
				}());


				return CryptoJS.RIPEMD160;

			})); 
		} (ripemd160$1));
		return ripemd160$1.exports;
	}

	var hmac$1 = {exports: {}};

	var hmac = hmac$1.exports;

	var hasRequiredHmac;

	function requireHmac () {
		if (hasRequiredHmac) return hmac$1.exports;
		hasRequiredHmac = 1;
		(function (module, exports) {
	(function (root, factory) {
				{
					// CommonJS
					module.exports = factory(requireCore());
				}
			}(hmac, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var Base = C_lib.Base;
				    var C_enc = C.enc;
				    var Utf8 = C_enc.Utf8;
				    var C_algo = C.algo;

				    /**
				     * HMAC algorithm.
				     */
				    C_algo.HMAC = Base.extend({
				        /**
				         * Initializes a newly created HMAC.
				         *
				         * @param {Hasher} hasher The hash algorithm to use.
				         * @param {WordArray|string} key The secret key.
				         *
				         * @example
				         *
				         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
				         */
				        init: function (hasher, key) {
				            // Init hasher
				            hasher = this._hasher = new hasher.init();

				            // Convert string to WordArray, else assume WordArray already
				            if (typeof key == 'string') {
				                key = Utf8.parse(key);
				            }

				            // Shortcuts
				            var hasherBlockSize = hasher.blockSize;
				            var hasherBlockSizeBytes = hasherBlockSize * 4;

				            // Allow arbitrary length keys
				            if (key.sigBytes > hasherBlockSizeBytes) {
				                key = hasher.finalize(key);
				            }

				            // Clamp excess bits
				            key.clamp();

				            // Clone key for inner and outer pads
				            var oKey = this._oKey = key.clone();
				            var iKey = this._iKey = key.clone();

				            // Shortcuts
				            var oKeyWords = oKey.words;
				            var iKeyWords = iKey.words;

				            // XOR keys with pad constants
				            for (var i = 0; i < hasherBlockSize; i++) {
				                oKeyWords[i] ^= 0x5c5c5c5c;
				                iKeyWords[i] ^= 0x36363636;
				            }
				            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

				            // Set initial values
				            this.reset();
				        },

				        /**
				         * Resets this HMAC to its initial state.
				         *
				         * @example
				         *
				         *     hmacHasher.reset();
				         */
				        reset: function () {
				            // Shortcut
				            var hasher = this._hasher;

				            // Reset
				            hasher.reset();
				            hasher.update(this._iKey);
				        },

				        /**
				         * Updates this HMAC with a message.
				         *
				         * @param {WordArray|string} messageUpdate The message to append.
				         *
				         * @return {HMAC} This HMAC instance.
				         *
				         * @example
				         *
				         *     hmacHasher.update('message');
				         *     hmacHasher.update(wordArray);
				         */
				        update: function (messageUpdate) {
				            this._hasher.update(messageUpdate);

				            // Chainable
				            return this;
				        },

				        /**
				         * Finalizes the HMAC computation.
				         * Note that the finalize operation is effectively a destructive, read-once operation.
				         *
				         * @param {WordArray|string} messageUpdate (Optional) A final message update.
				         *
				         * @return {WordArray} The HMAC.
				         *
				         * @example
				         *
				         *     var hmac = hmacHasher.finalize();
				         *     var hmac = hmacHasher.finalize('message');
				         *     var hmac = hmacHasher.finalize(wordArray);
				         */
				        finalize: function (messageUpdate) {
				            // Shortcut
				            var hasher = this._hasher;

				            // Compute HMAC
				            var innerHash = hasher.finalize(messageUpdate);
				            hasher.reset();
				            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

				            return hmac;
				        }
				    });
				}());


			})); 
		} (hmac$1));
		return hmac$1.exports;
	}

	var pbkdf2$1 = {exports: {}};

	var pbkdf2 = pbkdf2$1.exports;

	var hasRequiredPbkdf2;

	function requirePbkdf2 () {
		if (hasRequiredPbkdf2) return pbkdf2$1.exports;
		hasRequiredPbkdf2 = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireSha256(), requireHmac());
				}
			}(pbkdf2, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var Base = C_lib.Base;
				    var WordArray = C_lib.WordArray;
				    var C_algo = C.algo;
				    var SHA256 = C_algo.SHA256;
				    var HMAC = C_algo.HMAC;

				    /**
				     * Password-Based Key Derivation Function 2 algorithm.
				     */
				    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
				        /**
				         * Configuration options.
				         *
				         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
				         * @property {Hasher} hasher The hasher to use. Default: SHA256
				         * @property {number} iterations The number of iterations to perform. Default: 250000
				         */
				        cfg: Base.extend({
				            keySize: 128/32,
				            hasher: SHA256,
				            iterations: 250000
				        }),

				        /**
				         * Initializes a newly created key derivation function.
				         *
				         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
				         *
				         * @example
				         *
				         *     var kdf = CryptoJS.algo.PBKDF2.create();
				         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
				         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
				         */
				        init: function (cfg) {
				            this.cfg = this.cfg.extend(cfg);
				        },

				        /**
				         * Computes the Password-Based Key Derivation Function 2.
				         *
				         * @param {WordArray|string} password The password.
				         * @param {WordArray|string} salt A salt.
				         *
				         * @return {WordArray} The derived key.
				         *
				         * @example
				         *
				         *     var key = kdf.compute(password, salt);
				         */
				        compute: function (password, salt) {
				            // Shortcut
				            var cfg = this.cfg;

				            // Init HMAC
				            var hmac = HMAC.create(cfg.hasher, password);

				            // Initial values
				            var derivedKey = WordArray.create();
				            var blockIndex = WordArray.create([0x00000001]);

				            // Shortcuts
				            var derivedKeyWords = derivedKey.words;
				            var blockIndexWords = blockIndex.words;
				            var keySize = cfg.keySize;
				            var iterations = cfg.iterations;

				            // Generate key
				            while (derivedKeyWords.length < keySize) {
				                var block = hmac.update(salt).finalize(blockIndex);
				                hmac.reset();

				                // Shortcuts
				                var blockWords = block.words;
				                var blockWordsLength = blockWords.length;

				                // Iterations
				                var intermediate = block;
				                for (var i = 1; i < iterations; i++) {
				                    intermediate = hmac.finalize(intermediate);
				                    hmac.reset();

				                    // Shortcut
				                    var intermediateWords = intermediate.words;

				                    // XOR intermediate with block
				                    for (var j = 0; j < blockWordsLength; j++) {
				                        blockWords[j] ^= intermediateWords[j];
				                    }
				                }

				                derivedKey.concat(block);
				                blockIndexWords[0]++;
				            }
				            derivedKey.sigBytes = keySize * 4;

				            return derivedKey;
				        }
				    });

				    /**
				     * Computes the Password-Based Key Derivation Function 2.
				     *
				     * @param {WordArray|string} password The password.
				     * @param {WordArray|string} salt A salt.
				     * @param {Object} cfg (Optional) The configuration options to use for this computation.
				     *
				     * @return {WordArray} The derived key.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var key = CryptoJS.PBKDF2(password, salt);
				     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
				     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
				     */
				    C.PBKDF2 = function (password, salt, cfg) {
				        return PBKDF2.create(cfg).compute(password, salt);
				    };
				}());


				return CryptoJS.PBKDF2;

			})); 
		} (pbkdf2$1));
		return pbkdf2$1.exports;
	}

	var evpkdf$1 = {exports: {}};

	var evpkdf = evpkdf$1.exports;

	var hasRequiredEvpkdf;

	function requireEvpkdf () {
		if (hasRequiredEvpkdf) return evpkdf$1.exports;
		hasRequiredEvpkdf = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireSha1(), requireHmac());
				}
			}(evpkdf, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var Base = C_lib.Base;
				    var WordArray = C_lib.WordArray;
				    var C_algo = C.algo;
				    var MD5 = C_algo.MD5;

				    /**
				     * This key derivation function is meant to conform with EVP_BytesToKey.
				     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
				     */
				    var EvpKDF = C_algo.EvpKDF = Base.extend({
				        /**
				         * Configuration options.
				         *
				         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
				         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
				         * @property {number} iterations The number of iterations to perform. Default: 1
				         */
				        cfg: Base.extend({
				            keySize: 128/32,
				            hasher: MD5,
				            iterations: 1
				        }),

				        /**
				         * Initializes a newly created key derivation function.
				         *
				         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
				         *
				         * @example
				         *
				         *     var kdf = CryptoJS.algo.EvpKDF.create();
				         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
				         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
				         */
				        init: function (cfg) {
				            this.cfg = this.cfg.extend(cfg);
				        },

				        /**
				         * Derives a key from a password.
				         *
				         * @param {WordArray|string} password The password.
				         * @param {WordArray|string} salt A salt.
				         *
				         * @return {WordArray} The derived key.
				         *
				         * @example
				         *
				         *     var key = kdf.compute(password, salt);
				         */
				        compute: function (password, salt) {
				            var block;

				            // Shortcut
				            var cfg = this.cfg;

				            // Init hasher
				            var hasher = cfg.hasher.create();

				            // Initial values
				            var derivedKey = WordArray.create();

				            // Shortcuts
				            var derivedKeyWords = derivedKey.words;
				            var keySize = cfg.keySize;
				            var iterations = cfg.iterations;

				            // Generate key
				            while (derivedKeyWords.length < keySize) {
				                if (block) {
				                    hasher.update(block);
				                }
				                block = hasher.update(password).finalize(salt);
				                hasher.reset();

				                // Iterations
				                for (var i = 1; i < iterations; i++) {
				                    block = hasher.finalize(block);
				                    hasher.reset();
				                }

				                derivedKey.concat(block);
				            }
				            derivedKey.sigBytes = keySize * 4;

				            return derivedKey;
				        }
				    });

				    /**
				     * Derives a key from a password.
				     *
				     * @param {WordArray|string} password The password.
				     * @param {WordArray|string} salt A salt.
				     * @param {Object} cfg (Optional) The configuration options to use for this computation.
				     *
				     * @return {WordArray} The derived key.
				     *
				     * @static
				     *
				     * @example
				     *
				     *     var key = CryptoJS.EvpKDF(password, salt);
				     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
				     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
				     */
				    C.EvpKDF = function (password, salt, cfg) {
				        return EvpKDF.create(cfg).compute(password, salt);
				    };
				}());


				return CryptoJS.EvpKDF;

			})); 
		} (evpkdf$1));
		return evpkdf$1.exports;
	}

	var cipherCore$1 = {exports: {}};

	var cipherCore = cipherCore$1.exports;

	var hasRequiredCipherCore;

	function requireCipherCore () {
		if (hasRequiredCipherCore) return cipherCore$1.exports;
		hasRequiredCipherCore = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireEvpkdf());
				}
			}(cipherCore, function (CryptoJS) {

				/**
				 * Cipher core components.
				 */
				CryptoJS.lib.Cipher || (function (undefined$1) {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var Base = C_lib.Base;
				    var WordArray = C_lib.WordArray;
				    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
				    var C_enc = C.enc;
				    C_enc.Utf8;
				    var Base64 = C_enc.Base64;
				    var C_algo = C.algo;
				    var EvpKDF = C_algo.EvpKDF;

				    /**
				     * Abstract base cipher template.
				     *
				     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
				     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
				     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
				     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
				     */
				    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
				        /**
				         * Configuration options.
				         *
				         * @property {WordArray} iv The IV to use for this operation.
				         */
				        cfg: Base.extend(),

				        /**
				         * Creates this cipher in encryption mode.
				         *
				         * @param {WordArray} key The key.
				         * @param {Object} cfg (Optional) The configuration options to use for this operation.
				         *
				         * @return {Cipher} A cipher instance.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
				         */
				        createEncryptor: function (key, cfg) {
				            return this.create(this._ENC_XFORM_MODE, key, cfg);
				        },

				        /**
				         * Creates this cipher in decryption mode.
				         *
				         * @param {WordArray} key The key.
				         * @param {Object} cfg (Optional) The configuration options to use for this operation.
				         *
				         * @return {Cipher} A cipher instance.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
				         */
				        createDecryptor: function (key, cfg) {
				            return this.create(this._DEC_XFORM_MODE, key, cfg);
				        },

				        /**
				         * Initializes a newly created cipher.
				         *
				         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
				         * @param {WordArray} key The key.
				         * @param {Object} cfg (Optional) The configuration options to use for this operation.
				         *
				         * @example
				         *
				         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
				         */
				        init: function (xformMode, key, cfg) {
				            // Apply config defaults
				            this.cfg = this.cfg.extend(cfg);

				            // Store transform mode and key
				            this._xformMode = xformMode;
				            this._key = key;

				            // Set initial values
				            this.reset();
				        },

				        /**
				         * Resets this cipher to its initial state.
				         *
				         * @example
				         *
				         *     cipher.reset();
				         */
				        reset: function () {
				            // Reset data buffer
				            BufferedBlockAlgorithm.reset.call(this);

				            // Perform concrete-cipher logic
				            this._doReset();
				        },

				        /**
				         * Adds data to be encrypted or decrypted.
				         *
				         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
				         *
				         * @return {WordArray} The data after processing.
				         *
				         * @example
				         *
				         *     var encrypted = cipher.process('data');
				         *     var encrypted = cipher.process(wordArray);
				         */
				        process: function (dataUpdate) {
				            // Append
				            this._append(dataUpdate);

				            // Process available blocks
				            return this._process();
				        },

				        /**
				         * Finalizes the encryption or decryption process.
				         * Note that the finalize operation is effectively a destructive, read-once operation.
				         *
				         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
				         *
				         * @return {WordArray} The data after final processing.
				         *
				         * @example
				         *
				         *     var encrypted = cipher.finalize();
				         *     var encrypted = cipher.finalize('data');
				         *     var encrypted = cipher.finalize(wordArray);
				         */
				        finalize: function (dataUpdate) {
				            // Final data update
				            if (dataUpdate) {
				                this._append(dataUpdate);
				            }

				            // Perform concrete-cipher logic
				            var finalProcessedData = this._doFinalize();

				            return finalProcessedData;
				        },

				        keySize: 128/32,

				        ivSize: 128/32,

				        _ENC_XFORM_MODE: 1,

				        _DEC_XFORM_MODE: 2,

				        /**
				         * Creates shortcut functions to a cipher's object interface.
				         *
				         * @param {Cipher} cipher The cipher to create a helper for.
				         *
				         * @return {Object} An object with encrypt and decrypt shortcut functions.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
				         */
				        _createHelper: (function () {
				            function selectCipherStrategy(key) {
				                if (typeof key == 'string') {
				                    return PasswordBasedCipher;
				                } else {
				                    return SerializableCipher;
				                }
				            }

				            return function (cipher) {
				                return {
				                    encrypt: function (message, key, cfg) {
				                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
				                    },

				                    decrypt: function (ciphertext, key, cfg) {
				                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
				                    }
				                };
				            };
				        }())
				    });

				    /**
				     * Abstract base stream cipher template.
				     *
				     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
				     */
				    C_lib.StreamCipher = Cipher.extend({
				        _doFinalize: function () {
				            // Process partial blocks
				            var finalProcessedBlocks = this._process(true);

				            return finalProcessedBlocks;
				        },

				        blockSize: 1
				    });

				    /**
				     * Mode namespace.
				     */
				    var C_mode = C.mode = {};

				    /**
				     * Abstract base block cipher mode template.
				     */
				    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
				        /**
				         * Creates this mode for encryption.
				         *
				         * @param {Cipher} cipher A block cipher instance.
				         * @param {Array} iv The IV words.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
				         */
				        createEncryptor: function (cipher, iv) {
				            return this.Encryptor.create(cipher, iv);
				        },

				        /**
				         * Creates this mode for decryption.
				         *
				         * @param {Cipher} cipher A block cipher instance.
				         * @param {Array} iv The IV words.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
				         */
				        createDecryptor: function (cipher, iv) {
				            return this.Decryptor.create(cipher, iv);
				        },

				        /**
				         * Initializes a newly created mode.
				         *
				         * @param {Cipher} cipher A block cipher instance.
				         * @param {Array} iv The IV words.
				         *
				         * @example
				         *
				         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
				         */
				        init: function (cipher, iv) {
				            this._cipher = cipher;
				            this._iv = iv;
				        }
				    });

				    /**
				     * Cipher Block Chaining mode.
				     */
				    var CBC = C_mode.CBC = (function () {
				        /**
				         * Abstract base CBC mode.
				         */
				        var CBC = BlockCipherMode.extend();

				        /**
				         * CBC encryptor.
				         */
				        CBC.Encryptor = CBC.extend({
				            /**
				             * Processes the data block at offset.
				             *
				             * @param {Array} words The data words to operate on.
				             * @param {number} offset The offset where the block starts.
				             *
				             * @example
				             *
				             *     mode.processBlock(data.words, offset);
				             */
				            processBlock: function (words, offset) {
				                // Shortcuts
				                var cipher = this._cipher;
				                var blockSize = cipher.blockSize;

				                // XOR and encrypt
				                xorBlock.call(this, words, offset, blockSize);
				                cipher.encryptBlock(words, offset);

				                // Remember this block to use with next block
				                this._prevBlock = words.slice(offset, offset + blockSize);
				            }
				        });

				        /**
				         * CBC decryptor.
				         */
				        CBC.Decryptor = CBC.extend({
				            /**
				             * Processes the data block at offset.
				             *
				             * @param {Array} words The data words to operate on.
				             * @param {number} offset The offset where the block starts.
				             *
				             * @example
				             *
				             *     mode.processBlock(data.words, offset);
				             */
				            processBlock: function (words, offset) {
				                // Shortcuts
				                var cipher = this._cipher;
				                var blockSize = cipher.blockSize;

				                // Remember this block to use with next block
				                var thisBlock = words.slice(offset, offset + blockSize);

				                // Decrypt and XOR
				                cipher.decryptBlock(words, offset);
				                xorBlock.call(this, words, offset, blockSize);

				                // This block becomes the previous block
				                this._prevBlock = thisBlock;
				            }
				        });

				        function xorBlock(words, offset, blockSize) {
				            var block;

				            // Shortcut
				            var iv = this._iv;

				            // Choose mixing block
				            if (iv) {
				                block = iv;

				                // Remove IV for subsequent blocks
				                this._iv = undefined$1;
				            } else {
				                block = this._prevBlock;
				            }

				            // XOR blocks
				            for (var i = 0; i < blockSize; i++) {
				                words[offset + i] ^= block[i];
				            }
				        }

				        return CBC;
				    }());

				    /**
				     * Padding namespace.
				     */
				    var C_pad = C.pad = {};

				    /**
				     * PKCS #5/7 padding strategy.
				     */
				    var Pkcs7 = C_pad.Pkcs7 = {
				        /**
				         * Pads data using the algorithm defined in PKCS #5/7.
				         *
				         * @param {WordArray} data The data to pad.
				         * @param {number} blockSize The multiple that the data should be padded to.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
				         */
				        pad: function (data, blockSize) {
				            // Shortcut
				            var blockSizeBytes = blockSize * 4;

				            // Count padding bytes
				            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

				            // Create padding word
				            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

				            // Create padding
				            var paddingWords = [];
				            for (var i = 0; i < nPaddingBytes; i += 4) {
				                paddingWords.push(paddingWord);
				            }
				            var padding = WordArray.create(paddingWords, nPaddingBytes);

				            // Add padding
				            data.concat(padding);
				        },

				        /**
				         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
				         *
				         * @param {WordArray} data The data to unpad.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
				         */
				        unpad: function (data) {
				            // Get number of padding bytes from last byte
				            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

				            // Remove padding
				            data.sigBytes -= nPaddingBytes;
				        }
				    };

				    /**
				     * Abstract base block cipher template.
				     *
				     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
				     */
				    C_lib.BlockCipher = Cipher.extend({
				        /**
				         * Configuration options.
				         *
				         * @property {Mode} mode The block mode to use. Default: CBC
				         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
				         */
				        cfg: Cipher.cfg.extend({
				            mode: CBC,
				            padding: Pkcs7
				        }),

				        reset: function () {
				            var modeCreator;

				            // Reset cipher
				            Cipher.reset.call(this);

				            // Shortcuts
				            var cfg = this.cfg;
				            var iv = cfg.iv;
				            var mode = cfg.mode;

				            // Reset block mode
				            if (this._xformMode == this._ENC_XFORM_MODE) {
				                modeCreator = mode.createEncryptor;
				            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
				                modeCreator = mode.createDecryptor;
				                // Keep at least one block in the buffer for unpadding
				                this._minBufferSize = 1;
				            }

				            if (this._mode && this._mode.__creator == modeCreator) {
				                this._mode.init(this, iv && iv.words);
				            } else {
				                this._mode = modeCreator.call(mode, this, iv && iv.words);
				                this._mode.__creator = modeCreator;
				            }
				        },

				        _doProcessBlock: function (words, offset) {
				            this._mode.processBlock(words, offset);
				        },

				        _doFinalize: function () {
				            var finalProcessedBlocks;

				            // Shortcut
				            var padding = this.cfg.padding;

				            // Finalize
				            if (this._xformMode == this._ENC_XFORM_MODE) {
				                // Pad data
				                padding.pad(this._data, this.blockSize);

				                // Process final blocks
				                finalProcessedBlocks = this._process(true);
				            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
				                // Process final blocks
				                finalProcessedBlocks = this._process(true);

				                // Unpad data
				                padding.unpad(finalProcessedBlocks);
				            }

				            return finalProcessedBlocks;
				        },

				        blockSize: 128/32
				    });

				    /**
				     * A collection of cipher parameters.
				     *
				     * @property {WordArray} ciphertext The raw ciphertext.
				     * @property {WordArray} key The key to this ciphertext.
				     * @property {WordArray} iv The IV used in the ciphering operation.
				     * @property {WordArray} salt The salt used with a key derivation function.
				     * @property {Cipher} algorithm The cipher algorithm.
				     * @property {Mode} mode The block mode used in the ciphering operation.
				     * @property {Padding} padding The padding scheme used in the ciphering operation.
				     * @property {number} blockSize The block size of the cipher.
				     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
				     */
				    var CipherParams = C_lib.CipherParams = Base.extend({
				        /**
				         * Initializes a newly created cipher params object.
				         *
				         * @param {Object} cipherParams An object with any of the possible cipher parameters.
				         *
				         * @example
				         *
				         *     var cipherParams = CryptoJS.lib.CipherParams.create({
				         *         ciphertext: ciphertextWordArray,
				         *         key: keyWordArray,
				         *         iv: ivWordArray,
				         *         salt: saltWordArray,
				         *         algorithm: CryptoJS.algo.AES,
				         *         mode: CryptoJS.mode.CBC,
				         *         padding: CryptoJS.pad.PKCS7,
				         *         blockSize: 4,
				         *         formatter: CryptoJS.format.OpenSSL
				         *     });
				         */
				        init: function (cipherParams) {
				            this.mixIn(cipherParams);
				        },

				        /**
				         * Converts this cipher params object to a string.
				         *
				         * @param {Format} formatter (Optional) The formatting strategy to use.
				         *
				         * @return {string} The stringified cipher params.
				         *
				         * @throws Error If neither the formatter nor the default formatter is set.
				         *
				         * @example
				         *
				         *     var string = cipherParams + '';
				         *     var string = cipherParams.toString();
				         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
				         */
				        toString: function (formatter) {
				            return (formatter || this.formatter).stringify(this);
				        }
				    });

				    /**
				     * Format namespace.
				     */
				    var C_format = C.format = {};

				    /**
				     * OpenSSL formatting strategy.
				     */
				    var OpenSSLFormatter = C_format.OpenSSL = {
				        /**
				         * Converts a cipher params object to an OpenSSL-compatible string.
				         *
				         * @param {CipherParams} cipherParams The cipher params object.
				         *
				         * @return {string} The OpenSSL-compatible string.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
				         */
				        stringify: function (cipherParams) {
				            var wordArray;

				            // Shortcuts
				            var ciphertext = cipherParams.ciphertext;
				            var salt = cipherParams.salt;

				            // Format
				            if (salt) {
				                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
				            } else {
				                wordArray = ciphertext;
				            }

				            return wordArray.toString(Base64);
				        },

				        /**
				         * Converts an OpenSSL-compatible string to a cipher params object.
				         *
				         * @param {string} openSSLStr The OpenSSL-compatible string.
				         *
				         * @return {CipherParams} The cipher params object.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
				         */
				        parse: function (openSSLStr) {
				            var salt;

				            // Parse base64
				            var ciphertext = Base64.parse(openSSLStr);

				            // Shortcut
				            var ciphertextWords = ciphertext.words;

				            // Test for salt
				            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
				                // Extract salt
				                salt = WordArray.create(ciphertextWords.slice(2, 4));

				                // Remove salt from ciphertext
				                ciphertextWords.splice(0, 4);
				                ciphertext.sigBytes -= 16;
				            }

				            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
				        }
				    };

				    /**
				     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
				     */
				    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
				        /**
				         * Configuration options.
				         *
				         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
				         */
				        cfg: Base.extend({
				            format: OpenSSLFormatter
				        }),

				        /**
				         * Encrypts a message.
				         *
				         * @param {Cipher} cipher The cipher algorithm to use.
				         * @param {WordArray|string} message The message to encrypt.
				         * @param {WordArray} key The key.
				         * @param {Object} cfg (Optional) The configuration options to use for this operation.
				         *
				         * @return {CipherParams} A cipher params object.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
				         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
				         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
				         */
				        encrypt: function (cipher, message, key, cfg) {
				            // Apply config defaults
				            cfg = this.cfg.extend(cfg);

				            // Encrypt
				            var encryptor = cipher.createEncryptor(key, cfg);
				            var ciphertext = encryptor.finalize(message);

				            // Shortcut
				            var cipherCfg = encryptor.cfg;

				            // Create and return serializable cipher params
				            return CipherParams.create({
				                ciphertext: ciphertext,
				                key: key,
				                iv: cipherCfg.iv,
				                algorithm: cipher,
				                mode: cipherCfg.mode,
				                padding: cipherCfg.padding,
				                blockSize: cipher.blockSize,
				                formatter: cfg.format
				            });
				        },

				        /**
				         * Decrypts serialized ciphertext.
				         *
				         * @param {Cipher} cipher The cipher algorithm to use.
				         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
				         * @param {WordArray} key The key.
				         * @param {Object} cfg (Optional) The configuration options to use for this operation.
				         *
				         * @return {WordArray} The plaintext.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
				         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
				         */
				        decrypt: function (cipher, ciphertext, key, cfg) {
				            // Apply config defaults
				            cfg = this.cfg.extend(cfg);

				            // Convert string to CipherParams
				            ciphertext = this._parse(ciphertext, cfg.format);

				            // Decrypt
				            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

				            return plaintext;
				        },

				        /**
				         * Converts serialized ciphertext to CipherParams,
				         * else assumed CipherParams already and returns ciphertext unchanged.
				         *
				         * @param {CipherParams|string} ciphertext The ciphertext.
				         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
				         *
				         * @return {CipherParams} The unserialized ciphertext.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
				         */
				        _parse: function (ciphertext, format) {
				            if (typeof ciphertext == 'string') {
				                return format.parse(ciphertext, this);
				            } else {
				                return ciphertext;
				            }
				        }
				    });

				    /**
				     * Key derivation function namespace.
				     */
				    var C_kdf = C.kdf = {};

				    /**
				     * OpenSSL key derivation function.
				     */
				    var OpenSSLKdf = C_kdf.OpenSSL = {
				        /**
				         * Derives a key and IV from a password.
				         *
				         * @param {string} password The password to derive from.
				         * @param {number} keySize The size in words of the key to generate.
				         * @param {number} ivSize The size in words of the IV to generate.
				         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
				         *
				         * @return {CipherParams} A cipher params object with the key, IV, and salt.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
				         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
				         */
				        execute: function (password, keySize, ivSize, salt, hasher) {
				            // Generate random salt
				            if (!salt) {
				                salt = WordArray.random(64/8);
				            }

				            // Derive key and IV
				            if (!hasher) {
				                var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
				            } else {
				                var key = EvpKDF.create({ keySize: keySize + ivSize, hasher: hasher }).compute(password, salt);
				            }


				            // Separate key and IV
				            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
				            key.sigBytes = keySize * 4;

				            // Return params
				            return CipherParams.create({ key: key, iv: iv, salt: salt });
				        }
				    };

				    /**
				     * A serializable cipher wrapper that derives the key from a password,
				     * and returns ciphertext as a serializable cipher params object.
				     */
				    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
				        /**
				         * Configuration options.
				         *
				         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
				         */
				        cfg: SerializableCipher.cfg.extend({
				            kdf: OpenSSLKdf
				        }),

				        /**
				         * Encrypts a message using a password.
				         *
				         * @param {Cipher} cipher The cipher algorithm to use.
				         * @param {WordArray|string} message The message to encrypt.
				         * @param {string} password The password.
				         * @param {Object} cfg (Optional) The configuration options to use for this operation.
				         *
				         * @return {CipherParams} A cipher params object.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
				         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
				         */
				        encrypt: function (cipher, message, password, cfg) {
				            // Apply config defaults
				            cfg = this.cfg.extend(cfg);

				            // Derive key and other params
				            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);

				            // Add IV to config
				            cfg.iv = derivedParams.iv;

				            // Encrypt
				            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

				            // Mix in derived params
				            ciphertext.mixIn(derivedParams);

				            return ciphertext;
				        },

				        /**
				         * Decrypts serialized ciphertext using a password.
				         *
				         * @param {Cipher} cipher The cipher algorithm to use.
				         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
				         * @param {string} password The password.
				         * @param {Object} cfg (Optional) The configuration options to use for this operation.
				         *
				         * @return {WordArray} The plaintext.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
				         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
				         */
				        decrypt: function (cipher, ciphertext, password, cfg) {
				            // Apply config defaults
				            cfg = this.cfg.extend(cfg);

				            // Convert string to CipherParams
				            ciphertext = this._parse(ciphertext, cfg.format);

				            // Derive key and other params
				            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);

				            // Add IV to config
				            cfg.iv = derivedParams.iv;

				            // Decrypt
				            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

				            return plaintext;
				        }
				    });
				}());


			})); 
		} (cipherCore$1));
		return cipherCore$1.exports;
	}

	var modeCfb$1 = {exports: {}};

	var modeCfb = modeCfb$1.exports;

	var hasRequiredModeCfb;

	function requireModeCfb () {
		if (hasRequiredModeCfb) return modeCfb$1.exports;
		hasRequiredModeCfb = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireCipherCore());
				}
			}(modeCfb, function (CryptoJS) {

				/**
				 * Cipher Feedback block mode.
				 */
				CryptoJS.mode.CFB = (function () {
				    var CFB = CryptoJS.lib.BlockCipherMode.extend();

				    CFB.Encryptor = CFB.extend({
				        processBlock: function (words, offset) {
				            // Shortcuts
				            var cipher = this._cipher;
				            var blockSize = cipher.blockSize;

				            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

				            // Remember this block to use with next block
				            this._prevBlock = words.slice(offset, offset + blockSize);
				        }
				    });

				    CFB.Decryptor = CFB.extend({
				        processBlock: function (words, offset) {
				            // Shortcuts
				            var cipher = this._cipher;
				            var blockSize = cipher.blockSize;

				            // Remember this block to use with next block
				            var thisBlock = words.slice(offset, offset + blockSize);

				            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

				            // This block becomes the previous block
				            this._prevBlock = thisBlock;
				        }
				    });

				    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
				        var keystream;

				        // Shortcut
				        var iv = this._iv;

				        // Generate keystream
				        if (iv) {
				            keystream = iv.slice(0);

				            // Remove IV for subsequent blocks
				            this._iv = undefined;
				        } else {
				            keystream = this._prevBlock;
				        }
				        cipher.encryptBlock(keystream, 0);

				        // Encrypt
				        for (var i = 0; i < blockSize; i++) {
				            words[offset + i] ^= keystream[i];
				        }
				    }

				    return CFB;
				}());


				return CryptoJS.mode.CFB;

			})); 
		} (modeCfb$1));
		return modeCfb$1.exports;
	}

	var modeCtr$1 = {exports: {}};

	var modeCtr = modeCtr$1.exports;

	var hasRequiredModeCtr;

	function requireModeCtr () {
		if (hasRequiredModeCtr) return modeCtr$1.exports;
		hasRequiredModeCtr = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireCipherCore());
				}
			}(modeCtr, function (CryptoJS) {

				/**
				 * Counter block mode.
				 */
				CryptoJS.mode.CTR = (function () {
				    var CTR = CryptoJS.lib.BlockCipherMode.extend();

				    var Encryptor = CTR.Encryptor = CTR.extend({
				        processBlock: function (words, offset) {
				            // Shortcuts
				            var cipher = this._cipher;
				            var blockSize = cipher.blockSize;
				            var iv = this._iv;
				            var counter = this._counter;

				            // Generate keystream
				            if (iv) {
				                counter = this._counter = iv.slice(0);

				                // Remove IV for subsequent blocks
				                this._iv = undefined;
				            }
				            var keystream = counter.slice(0);
				            cipher.encryptBlock(keystream, 0);

				            // Increment counter
				            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0;

				            // Encrypt
				            for (var i = 0; i < blockSize; i++) {
				                words[offset + i] ^= keystream[i];
				            }
				        }
				    });

				    CTR.Decryptor = Encryptor;

				    return CTR;
				}());


				return CryptoJS.mode.CTR;

			})); 
		} (modeCtr$1));
		return modeCtr$1.exports;
	}

	var modeCtrGladman$1 = {exports: {}};

	var modeCtrGladman = modeCtrGladman$1.exports;

	var hasRequiredModeCtrGladman;

	function requireModeCtrGladman () {
		if (hasRequiredModeCtrGladman) return modeCtrGladman$1.exports;
		hasRequiredModeCtrGladman = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireCipherCore());
				}
			}(modeCtrGladman, function (CryptoJS) {

				/** @preserve
				 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
				 * derived from CryptoJS.mode.CTR
				 * Jan Hruby jhruby.web@gmail.com
				 */
				CryptoJS.mode.CTRGladman = (function () {
				    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

					function incWord(word)
					{
						if (((word >> 24) & 0xff) === 0xff) { //overflow
						var b1 = (word >> 16)&0xff;
						var b2 = (word >> 8)&0xff;
						var b3 = word & 0xff;

						if (b1 === 0xff) // overflow b1
						{
						b1 = 0;
						if (b2 === 0xff)
						{
							b2 = 0;
							if (b3 === 0xff)
							{
								b3 = 0;
							}
							else
							{
								++b3;
							}
						}
						else
						{
							++b2;
						}
						}
						else
						{
						++b1;
						}

						word = 0;
						word += (b1 << 16);
						word += (b2 << 8);
						word += b3;
						}
						else
						{
						word += (0x01 << 24);
						}
						return word;
					}

					function incCounter(counter)
					{
						if ((counter[0] = incWord(counter[0])) === 0)
						{
							// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
							counter[1] = incWord(counter[1]);
						}
						return counter;
					}

				    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
				        processBlock: function (words, offset) {
				            // Shortcuts
				            var cipher = this._cipher;
				            var blockSize = cipher.blockSize;
				            var iv = this._iv;
				            var counter = this._counter;

				            // Generate keystream
				            if (iv) {
				                counter = this._counter = iv.slice(0);

				                // Remove IV for subsequent blocks
				                this._iv = undefined;
				            }

							incCounter(counter);

							var keystream = counter.slice(0);
				            cipher.encryptBlock(keystream, 0);

				            // Encrypt
				            for (var i = 0; i < blockSize; i++) {
				                words[offset + i] ^= keystream[i];
				            }
				        }
				    });

				    CTRGladman.Decryptor = Encryptor;

				    return CTRGladman;
				}());




				return CryptoJS.mode.CTRGladman;

			})); 
		} (modeCtrGladman$1));
		return modeCtrGladman$1.exports;
	}

	var modeOfb$1 = {exports: {}};

	var modeOfb = modeOfb$1.exports;

	var hasRequiredModeOfb;

	function requireModeOfb () {
		if (hasRequiredModeOfb) return modeOfb$1.exports;
		hasRequiredModeOfb = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireCipherCore());
				}
			}(modeOfb, function (CryptoJS) {

				/**
				 * Output Feedback block mode.
				 */
				CryptoJS.mode.OFB = (function () {
				    var OFB = CryptoJS.lib.BlockCipherMode.extend();

				    var Encryptor = OFB.Encryptor = OFB.extend({
				        processBlock: function (words, offset) {
				            // Shortcuts
				            var cipher = this._cipher;
				            var blockSize = cipher.blockSize;
				            var iv = this._iv;
				            var keystream = this._keystream;

				            // Generate keystream
				            if (iv) {
				                keystream = this._keystream = iv.slice(0);

				                // Remove IV for subsequent blocks
				                this._iv = undefined;
				            }
				            cipher.encryptBlock(keystream, 0);

				            // Encrypt
				            for (var i = 0; i < blockSize; i++) {
				                words[offset + i] ^= keystream[i];
				            }
				        }
				    });

				    OFB.Decryptor = Encryptor;

				    return OFB;
				}());


				return CryptoJS.mode.OFB;

			})); 
		} (modeOfb$1));
		return modeOfb$1.exports;
	}

	var modeEcb$1 = {exports: {}};

	var modeEcb = modeEcb$1.exports;

	var hasRequiredModeEcb;

	function requireModeEcb () {
		if (hasRequiredModeEcb) return modeEcb$1.exports;
		hasRequiredModeEcb = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireCipherCore());
				}
			}(modeEcb, function (CryptoJS) {

				/**
				 * Electronic Codebook block mode.
				 */
				CryptoJS.mode.ECB = (function () {
				    var ECB = CryptoJS.lib.BlockCipherMode.extend();

				    ECB.Encryptor = ECB.extend({
				        processBlock: function (words, offset) {
				            this._cipher.encryptBlock(words, offset);
				        }
				    });

				    ECB.Decryptor = ECB.extend({
				        processBlock: function (words, offset) {
				            this._cipher.decryptBlock(words, offset);
				        }
				    });

				    return ECB;
				}());


				return CryptoJS.mode.ECB;

			})); 
		} (modeEcb$1));
		return modeEcb$1.exports;
	}

	var padAnsix923$1 = {exports: {}};

	var padAnsix923 = padAnsix923$1.exports;

	var hasRequiredPadAnsix923;

	function requirePadAnsix923 () {
		if (hasRequiredPadAnsix923) return padAnsix923$1.exports;
		hasRequiredPadAnsix923 = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireCipherCore());
				}
			}(padAnsix923, function (CryptoJS) {

				/**
				 * ANSI X.923 padding strategy.
				 */
				CryptoJS.pad.AnsiX923 = {
				    pad: function (data, blockSize) {
				        // Shortcuts
				        var dataSigBytes = data.sigBytes;
				        var blockSizeBytes = blockSize * 4;

				        // Count padding bytes
				        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

				        // Compute last byte position
				        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

				        // Pad
				        data.clamp();
				        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
				        data.sigBytes += nPaddingBytes;
				    },

				    unpad: function (data) {
				        // Get number of padding bytes from last byte
				        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

				        // Remove padding
				        data.sigBytes -= nPaddingBytes;
				    }
				};


				return CryptoJS.pad.Ansix923;

			})); 
		} (padAnsix923$1));
		return padAnsix923$1.exports;
	}

	var padIso10126$1 = {exports: {}};

	var padIso10126 = padIso10126$1.exports;

	var hasRequiredPadIso10126;

	function requirePadIso10126 () {
		if (hasRequiredPadIso10126) return padIso10126$1.exports;
		hasRequiredPadIso10126 = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireCipherCore());
				}
			}(padIso10126, function (CryptoJS) {

				/**
				 * ISO 10126 padding strategy.
				 */
				CryptoJS.pad.Iso10126 = {
				    pad: function (data, blockSize) {
				        // Shortcut
				        var blockSizeBytes = blockSize * 4;

				        // Count padding bytes
				        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

				        // Pad
				        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
				             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
				    },

				    unpad: function (data) {
				        // Get number of padding bytes from last byte
				        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

				        // Remove padding
				        data.sigBytes -= nPaddingBytes;
				    }
				};


				return CryptoJS.pad.Iso10126;

			})); 
		} (padIso10126$1));
		return padIso10126$1.exports;
	}

	var padIso97971$1 = {exports: {}};

	var padIso97971 = padIso97971$1.exports;

	var hasRequiredPadIso97971;

	function requirePadIso97971 () {
		if (hasRequiredPadIso97971) return padIso97971$1.exports;
		hasRequiredPadIso97971 = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireCipherCore());
				}
			}(padIso97971, function (CryptoJS) {

				/**
				 * ISO/IEC 9797-1 Padding Method 2.
				 */
				CryptoJS.pad.Iso97971 = {
				    pad: function (data, blockSize) {
				        // Add 0x80 byte
				        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

				        // Zero pad the rest
				        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
				    },

				    unpad: function (data) {
				        // Remove zero padding
				        CryptoJS.pad.ZeroPadding.unpad(data);

				        // Remove one more byte -- the 0x80 byte
				        data.sigBytes--;
				    }
				};


				return CryptoJS.pad.Iso97971;

			})); 
		} (padIso97971$1));
		return padIso97971$1.exports;
	}

	var padZeropadding$1 = {exports: {}};

	var padZeropadding = padZeropadding$1.exports;

	var hasRequiredPadZeropadding;

	function requirePadZeropadding () {
		if (hasRequiredPadZeropadding) return padZeropadding$1.exports;
		hasRequiredPadZeropadding = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireCipherCore());
				}
			}(padZeropadding, function (CryptoJS) {

				/**
				 * Zero padding strategy.
				 */
				CryptoJS.pad.ZeroPadding = {
				    pad: function (data, blockSize) {
				        // Shortcut
				        var blockSizeBytes = blockSize * 4;

				        // Pad
				        data.clamp();
				        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
				    },

				    unpad: function (data) {
				        // Shortcut
				        var dataWords = data.words;

				        // Unpad
				        var i = data.sigBytes - 1;
				        for (var i = data.sigBytes - 1; i >= 0; i--) {
				            if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
				                data.sigBytes = i + 1;
				                break;
				            }
				        }
				    }
				};


				return CryptoJS.pad.ZeroPadding;

			})); 
		} (padZeropadding$1));
		return padZeropadding$1.exports;
	}

	var padNopadding$1 = {exports: {}};

	var padNopadding = padNopadding$1.exports;

	var hasRequiredPadNopadding;

	function requirePadNopadding () {
		if (hasRequiredPadNopadding) return padNopadding$1.exports;
		hasRequiredPadNopadding = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireCipherCore());
				}
			}(padNopadding, function (CryptoJS) {

				/**
				 * A noop padding strategy.
				 */
				CryptoJS.pad.NoPadding = {
				    pad: function () {
				    },

				    unpad: function () {
				    }
				};


				return CryptoJS.pad.NoPadding;

			})); 
		} (padNopadding$1));
		return padNopadding$1.exports;
	}

	var formatHex$1 = {exports: {}};

	var formatHex = formatHex$1.exports;

	var hasRequiredFormatHex;

	function requireFormatHex () {
		if (hasRequiredFormatHex) return formatHex$1.exports;
		hasRequiredFormatHex = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireCipherCore());
				}
			}(formatHex, function (CryptoJS) {

				(function (undefined$1) {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var CipherParams = C_lib.CipherParams;
				    var C_enc = C.enc;
				    var Hex = C_enc.Hex;
				    var C_format = C.format;

				    C_format.Hex = {
				        /**
				         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
				         *
				         * @param {CipherParams} cipherParams The cipher params object.
				         *
				         * @return {string} The hexadecimally encoded string.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
				         */
				        stringify: function (cipherParams) {
				            return cipherParams.ciphertext.toString(Hex);
				        },

				        /**
				         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
				         *
				         * @param {string} input The hexadecimally encoded string.
				         *
				         * @return {CipherParams} The cipher params object.
				         *
				         * @static
				         *
				         * @example
				         *
				         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
				         */
				        parse: function (input) {
				            var ciphertext = Hex.parse(input);
				            return CipherParams.create({ ciphertext: ciphertext });
				        }
				    };
				}());


				return CryptoJS.format.Hex;

			})); 
		} (formatHex$1));
		return formatHex$1.exports;
	}

	var aes$1 = {exports: {}};

	var aes = aes$1.exports;

	var hasRequiredAes;

	function requireAes () {
		if (hasRequiredAes) return aes$1.exports;
		hasRequiredAes = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
				}
			}(aes, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var BlockCipher = C_lib.BlockCipher;
				    var C_algo = C.algo;

				    // Lookup tables
				    var SBOX = [];
				    var INV_SBOX = [];
				    var SUB_MIX_0 = [];
				    var SUB_MIX_1 = [];
				    var SUB_MIX_2 = [];
				    var SUB_MIX_3 = [];
				    var INV_SUB_MIX_0 = [];
				    var INV_SUB_MIX_1 = [];
				    var INV_SUB_MIX_2 = [];
				    var INV_SUB_MIX_3 = [];

				    // Compute lookup tables
				    (function () {
				        // Compute double table
				        var d = [];
				        for (var i = 0; i < 256; i++) {
				            if (i < 128) {
				                d[i] = i << 1;
				            } else {
				                d[i] = (i << 1) ^ 0x11b;
				            }
				        }

				        // Walk GF(2^8)
				        var x = 0;
				        var xi = 0;
				        for (var i = 0; i < 256; i++) {
				            // Compute sbox
				            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
				            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
				            SBOX[x] = sx;
				            INV_SBOX[sx] = x;

				            // Compute multiplication
				            var x2 = d[x];
				            var x4 = d[x2];
				            var x8 = d[x4];

				            // Compute sub bytes, mix columns tables
				            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
				            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
				            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
				            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
				            SUB_MIX_3[x] = t;

				            // Compute inv sub bytes, inv mix columns tables
				            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
				            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
				            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
				            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
				            INV_SUB_MIX_3[sx] = t;

				            // Compute next counter
				            if (!x) {
				                x = xi = 1;
				            } else {
				                x = x2 ^ d[d[d[x8 ^ x2]]];
				                xi ^= d[d[xi]];
				            }
				        }
				    }());

				    // Precomputed Rcon lookup
				    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

				    /**
				     * AES block cipher algorithm.
				     */
				    var AES = C_algo.AES = BlockCipher.extend({
				        _doReset: function () {
				            var t;

				            // Skip reset of nRounds has been set before and key did not change
				            if (this._nRounds && this._keyPriorReset === this._key) {
				                return;
				            }

				            // Shortcuts
				            var key = this._keyPriorReset = this._key;
				            var keyWords = key.words;
				            var keySize = key.sigBytes / 4;

				            // Compute number of rounds
				            var nRounds = this._nRounds = keySize + 6;

				            // Compute number of key schedule rows
				            var ksRows = (nRounds + 1) * 4;

				            // Compute key schedule
				            var keySchedule = this._keySchedule = [];
				            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
				                if (ksRow < keySize) {
				                    keySchedule[ksRow] = keyWords[ksRow];
				                } else {
				                    t = keySchedule[ksRow - 1];

				                    if (!(ksRow % keySize)) {
				                        // Rot word
				                        t = (t << 8) | (t >>> 24);

				                        // Sub word
				                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

				                        // Mix Rcon
				                        t ^= RCON[(ksRow / keySize) | 0] << 24;
				                    } else if (keySize > 6 && ksRow % keySize == 4) {
				                        // Sub word
				                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
				                    }

				                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
				                }
				            }

				            // Compute inv key schedule
				            var invKeySchedule = this._invKeySchedule = [];
				            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
				                var ksRow = ksRows - invKsRow;

				                if (invKsRow % 4) {
				                    var t = keySchedule[ksRow];
				                } else {
				                    var t = keySchedule[ksRow - 4];
				                }

				                if (invKsRow < 4 || ksRow <= 4) {
				                    invKeySchedule[invKsRow] = t;
				                } else {
				                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
				                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
				                }
				            }
				        },

				        encryptBlock: function (M, offset) {
				            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
				        },

				        decryptBlock: function (M, offset) {
				            // Swap 2nd and 4th rows
				            var t = M[offset + 1];
				            M[offset + 1] = M[offset + 3];
				            M[offset + 3] = t;

				            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

				            // Inv swap 2nd and 4th rows
				            var t = M[offset + 1];
				            M[offset + 1] = M[offset + 3];
				            M[offset + 3] = t;
				        },

				        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
				            // Shortcut
				            var nRounds = this._nRounds;

				            // Get input, add round key
				            var s0 = M[offset]     ^ keySchedule[0];
				            var s1 = M[offset + 1] ^ keySchedule[1];
				            var s2 = M[offset + 2] ^ keySchedule[2];
				            var s3 = M[offset + 3] ^ keySchedule[3];

				            // Key schedule row counter
				            var ksRow = 4;

				            // Rounds
				            for (var round = 1; round < nRounds; round++) {
				                // Shift rows, sub bytes, mix columns, add round key
				                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
				                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
				                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
				                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

				                // Update state
				                s0 = t0;
				                s1 = t1;
				                s2 = t2;
				                s3 = t3;
				            }

				            // Shift rows, sub bytes, add round key
				            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
				            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
				            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
				            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

				            // Set output
				            M[offset]     = t0;
				            M[offset + 1] = t1;
				            M[offset + 2] = t2;
				            M[offset + 3] = t3;
				        },

				        keySize: 256/32
				    });

				    /**
				     * Shortcut functions to the cipher's object interface.
				     *
				     * @example
				     *
				     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
				     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
				     */
				    C.AES = BlockCipher._createHelper(AES);
				}());


				return CryptoJS.AES;

			})); 
		} (aes$1));
		return aes$1.exports;
	}

	var tripledes$1 = {exports: {}};

	var tripledes = tripledes$1.exports;

	var hasRequiredTripledes;

	function requireTripledes () {
		if (hasRequiredTripledes) return tripledes$1.exports;
		hasRequiredTripledes = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
				}
			}(tripledes, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var WordArray = C_lib.WordArray;
				    var BlockCipher = C_lib.BlockCipher;
				    var C_algo = C.algo;

				    // Permuted Choice 1 constants
				    var PC1 = [
				        57, 49, 41, 33, 25, 17, 9,  1,
				        58, 50, 42, 34, 26, 18, 10, 2,
				        59, 51, 43, 35, 27, 19, 11, 3,
				        60, 52, 44, 36, 63, 55, 47, 39,
				        31, 23, 15, 7,  62, 54, 46, 38,
				        30, 22, 14, 6,  61, 53, 45, 37,
				        29, 21, 13, 5,  28, 20, 12, 4
				    ];

				    // Permuted Choice 2 constants
				    var PC2 = [
				        14, 17, 11, 24, 1,  5,
				        3,  28, 15, 6,  21, 10,
				        23, 19, 12, 4,  26, 8,
				        16, 7,  27, 20, 13, 2,
				        41, 52, 31, 37, 47, 55,
				        30, 40, 51, 45, 33, 48,
				        44, 49, 39, 56, 34, 53,
				        46, 42, 50, 36, 29, 32
				    ];

				    // Cumulative bit shift constants
				    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

				    // SBOXes and round permutation constants
				    var SBOX_P = [
				        {
				            0x0: 0x808200,
				            0x10000000: 0x8000,
				            0x20000000: 0x808002,
				            0x30000000: 0x2,
				            0x40000000: 0x200,
				            0x50000000: 0x808202,
				            0x60000000: 0x800202,
				            0x70000000: 0x800000,
				            0x80000000: 0x202,
				            0x90000000: 0x800200,
				            0xa0000000: 0x8200,
				            0xb0000000: 0x808000,
				            0xc0000000: 0x8002,
				            0xd0000000: 0x800002,
				            0xe0000000: 0x0,
				            0xf0000000: 0x8202,
				            0x8000000: 0x0,
				            0x18000000: 0x808202,
				            0x28000000: 0x8202,
				            0x38000000: 0x8000,
				            0x48000000: 0x808200,
				            0x58000000: 0x200,
				            0x68000000: 0x808002,
				            0x78000000: 0x2,
				            0x88000000: 0x800200,
				            0x98000000: 0x8200,
				            0xa8000000: 0x808000,
				            0xb8000000: 0x800202,
				            0xc8000000: 0x800002,
				            0xd8000000: 0x8002,
				            0xe8000000: 0x202,
				            0xf8000000: 0x800000,
				            0x1: 0x8000,
				            0x10000001: 0x2,
				            0x20000001: 0x808200,
				            0x30000001: 0x800000,
				            0x40000001: 0x808002,
				            0x50000001: 0x8200,
				            0x60000001: 0x200,
				            0x70000001: 0x800202,
				            0x80000001: 0x808202,
				            0x90000001: 0x808000,
				            0xa0000001: 0x800002,
				            0xb0000001: 0x8202,
				            0xc0000001: 0x202,
				            0xd0000001: 0x800200,
				            0xe0000001: 0x8002,
				            0xf0000001: 0x0,
				            0x8000001: 0x808202,
				            0x18000001: 0x808000,
				            0x28000001: 0x800000,
				            0x38000001: 0x200,
				            0x48000001: 0x8000,
				            0x58000001: 0x800002,
				            0x68000001: 0x2,
				            0x78000001: 0x8202,
				            0x88000001: 0x8002,
				            0x98000001: 0x800202,
				            0xa8000001: 0x202,
				            0xb8000001: 0x808200,
				            0xc8000001: 0x800200,
				            0xd8000001: 0x0,
				            0xe8000001: 0x8200,
				            0xf8000001: 0x808002
				        },
				        {
				            0x0: 0x40084010,
				            0x1000000: 0x4000,
				            0x2000000: 0x80000,
				            0x3000000: 0x40080010,
				            0x4000000: 0x40000010,
				            0x5000000: 0x40084000,
				            0x6000000: 0x40004000,
				            0x7000000: 0x10,
				            0x8000000: 0x84000,
				            0x9000000: 0x40004010,
				            0xa000000: 0x40000000,
				            0xb000000: 0x84010,
				            0xc000000: 0x80010,
				            0xd000000: 0x0,
				            0xe000000: 0x4010,
				            0xf000000: 0x40080000,
				            0x800000: 0x40004000,
				            0x1800000: 0x84010,
				            0x2800000: 0x10,
				            0x3800000: 0x40004010,
				            0x4800000: 0x40084010,
				            0x5800000: 0x40000000,
				            0x6800000: 0x80000,
				            0x7800000: 0x40080010,
				            0x8800000: 0x80010,
				            0x9800000: 0x0,
				            0xa800000: 0x4000,
				            0xb800000: 0x40080000,
				            0xc800000: 0x40000010,
				            0xd800000: 0x84000,
				            0xe800000: 0x40084000,
				            0xf800000: 0x4010,
				            0x10000000: 0x0,
				            0x11000000: 0x40080010,
				            0x12000000: 0x40004010,
				            0x13000000: 0x40084000,
				            0x14000000: 0x40080000,
				            0x15000000: 0x10,
				            0x16000000: 0x84010,
				            0x17000000: 0x4000,
				            0x18000000: 0x4010,
				            0x19000000: 0x80000,
				            0x1a000000: 0x80010,
				            0x1b000000: 0x40000010,
				            0x1c000000: 0x84000,
				            0x1d000000: 0x40004000,
				            0x1e000000: 0x40000000,
				            0x1f000000: 0x40084010,
				            0x10800000: 0x84010,
				            0x11800000: 0x80000,
				            0x12800000: 0x40080000,
				            0x13800000: 0x4000,
				            0x14800000: 0x40004000,
				            0x15800000: 0x40084010,
				            0x16800000: 0x10,
				            0x17800000: 0x40000000,
				            0x18800000: 0x40084000,
				            0x19800000: 0x40000010,
				            0x1a800000: 0x40004010,
				            0x1b800000: 0x80010,
				            0x1c800000: 0x0,
				            0x1d800000: 0x4010,
				            0x1e800000: 0x40080010,
				            0x1f800000: 0x84000
				        },
				        {
				            0x0: 0x104,
				            0x100000: 0x0,
				            0x200000: 0x4000100,
				            0x300000: 0x10104,
				            0x400000: 0x10004,
				            0x500000: 0x4000004,
				            0x600000: 0x4010104,
				            0x700000: 0x4010000,
				            0x800000: 0x4000000,
				            0x900000: 0x4010100,
				            0xa00000: 0x10100,
				            0xb00000: 0x4010004,
				            0xc00000: 0x4000104,
				            0xd00000: 0x10000,
				            0xe00000: 0x4,
				            0xf00000: 0x100,
				            0x80000: 0x4010100,
				            0x180000: 0x4010004,
				            0x280000: 0x0,
				            0x380000: 0x4000100,
				            0x480000: 0x4000004,
				            0x580000: 0x10000,
				            0x680000: 0x10004,
				            0x780000: 0x104,
				            0x880000: 0x4,
				            0x980000: 0x100,
				            0xa80000: 0x4010000,
				            0xb80000: 0x10104,
				            0xc80000: 0x10100,
				            0xd80000: 0x4000104,
				            0xe80000: 0x4010104,
				            0xf80000: 0x4000000,
				            0x1000000: 0x4010100,
				            0x1100000: 0x10004,
				            0x1200000: 0x10000,
				            0x1300000: 0x4000100,
				            0x1400000: 0x100,
				            0x1500000: 0x4010104,
				            0x1600000: 0x4000004,
				            0x1700000: 0x0,
				            0x1800000: 0x4000104,
				            0x1900000: 0x4000000,
				            0x1a00000: 0x4,
				            0x1b00000: 0x10100,
				            0x1c00000: 0x4010000,
				            0x1d00000: 0x104,
				            0x1e00000: 0x10104,
				            0x1f00000: 0x4010004,
				            0x1080000: 0x4000000,
				            0x1180000: 0x104,
				            0x1280000: 0x4010100,
				            0x1380000: 0x0,
				            0x1480000: 0x10004,
				            0x1580000: 0x4000100,
				            0x1680000: 0x100,
				            0x1780000: 0x4010004,
				            0x1880000: 0x10000,
				            0x1980000: 0x4010104,
				            0x1a80000: 0x10104,
				            0x1b80000: 0x4000004,
				            0x1c80000: 0x4000104,
				            0x1d80000: 0x4010000,
				            0x1e80000: 0x4,
				            0x1f80000: 0x10100
				        },
				        {
				            0x0: 0x80401000,
				            0x10000: 0x80001040,
				            0x20000: 0x401040,
				            0x30000: 0x80400000,
				            0x40000: 0x0,
				            0x50000: 0x401000,
				            0x60000: 0x80000040,
				            0x70000: 0x400040,
				            0x80000: 0x80000000,
				            0x90000: 0x400000,
				            0xa0000: 0x40,
				            0xb0000: 0x80001000,
				            0xc0000: 0x80400040,
				            0xd0000: 0x1040,
				            0xe0000: 0x1000,
				            0xf0000: 0x80401040,
				            0x8000: 0x80001040,
				            0x18000: 0x40,
				            0x28000: 0x80400040,
				            0x38000: 0x80001000,
				            0x48000: 0x401000,
				            0x58000: 0x80401040,
				            0x68000: 0x0,
				            0x78000: 0x80400000,
				            0x88000: 0x1000,
				            0x98000: 0x80401000,
				            0xa8000: 0x400000,
				            0xb8000: 0x1040,
				            0xc8000: 0x80000000,
				            0xd8000: 0x400040,
				            0xe8000: 0x401040,
				            0xf8000: 0x80000040,
				            0x100000: 0x400040,
				            0x110000: 0x401000,
				            0x120000: 0x80000040,
				            0x130000: 0x0,
				            0x140000: 0x1040,
				            0x150000: 0x80400040,
				            0x160000: 0x80401000,
				            0x170000: 0x80001040,
				            0x180000: 0x80401040,
				            0x190000: 0x80000000,
				            0x1a0000: 0x80400000,
				            0x1b0000: 0x401040,
				            0x1c0000: 0x80001000,
				            0x1d0000: 0x400000,
				            0x1e0000: 0x40,
				            0x1f0000: 0x1000,
				            0x108000: 0x80400000,
				            0x118000: 0x80401040,
				            0x128000: 0x0,
				            0x138000: 0x401000,
				            0x148000: 0x400040,
				            0x158000: 0x80000000,
				            0x168000: 0x80001040,
				            0x178000: 0x40,
				            0x188000: 0x80000040,
				            0x198000: 0x1000,
				            0x1a8000: 0x80001000,
				            0x1b8000: 0x80400040,
				            0x1c8000: 0x1040,
				            0x1d8000: 0x80401000,
				            0x1e8000: 0x400000,
				            0x1f8000: 0x401040
				        },
				        {
				            0x0: 0x80,
				            0x1000: 0x1040000,
				            0x2000: 0x40000,
				            0x3000: 0x20000000,
				            0x4000: 0x20040080,
				            0x5000: 0x1000080,
				            0x6000: 0x21000080,
				            0x7000: 0x40080,
				            0x8000: 0x1000000,
				            0x9000: 0x20040000,
				            0xa000: 0x20000080,
				            0xb000: 0x21040080,
				            0xc000: 0x21040000,
				            0xd000: 0x0,
				            0xe000: 0x1040080,
				            0xf000: 0x21000000,
				            0x800: 0x1040080,
				            0x1800: 0x21000080,
				            0x2800: 0x80,
				            0x3800: 0x1040000,
				            0x4800: 0x40000,
				            0x5800: 0x20040080,
				            0x6800: 0x21040000,
				            0x7800: 0x20000000,
				            0x8800: 0x20040000,
				            0x9800: 0x0,
				            0xa800: 0x21040080,
				            0xb800: 0x1000080,
				            0xc800: 0x20000080,
				            0xd800: 0x21000000,
				            0xe800: 0x1000000,
				            0xf800: 0x40080,
				            0x10000: 0x40000,
				            0x11000: 0x80,
				            0x12000: 0x20000000,
				            0x13000: 0x21000080,
				            0x14000: 0x1000080,
				            0x15000: 0x21040000,
				            0x16000: 0x20040080,
				            0x17000: 0x1000000,
				            0x18000: 0x21040080,
				            0x19000: 0x21000000,
				            0x1a000: 0x1040000,
				            0x1b000: 0x20040000,
				            0x1c000: 0x40080,
				            0x1d000: 0x20000080,
				            0x1e000: 0x0,
				            0x1f000: 0x1040080,
				            0x10800: 0x21000080,
				            0x11800: 0x1000000,
				            0x12800: 0x1040000,
				            0x13800: 0x20040080,
				            0x14800: 0x20000000,
				            0x15800: 0x1040080,
				            0x16800: 0x80,
				            0x17800: 0x21040000,
				            0x18800: 0x40080,
				            0x19800: 0x21040080,
				            0x1a800: 0x0,
				            0x1b800: 0x21000000,
				            0x1c800: 0x1000080,
				            0x1d800: 0x40000,
				            0x1e800: 0x20040000,
				            0x1f800: 0x20000080
				        },
				        {
				            0x0: 0x10000008,
				            0x100: 0x2000,
				            0x200: 0x10200000,
				            0x300: 0x10202008,
				            0x400: 0x10002000,
				            0x500: 0x200000,
				            0x600: 0x200008,
				            0x700: 0x10000000,
				            0x800: 0x0,
				            0x900: 0x10002008,
				            0xa00: 0x202000,
				            0xb00: 0x8,
				            0xc00: 0x10200008,
				            0xd00: 0x202008,
				            0xe00: 0x2008,
				            0xf00: 0x10202000,
				            0x80: 0x10200000,
				            0x180: 0x10202008,
				            0x280: 0x8,
				            0x380: 0x200000,
				            0x480: 0x202008,
				            0x580: 0x10000008,
				            0x680: 0x10002000,
				            0x780: 0x2008,
				            0x880: 0x200008,
				            0x980: 0x2000,
				            0xa80: 0x10002008,
				            0xb80: 0x10200008,
				            0xc80: 0x0,
				            0xd80: 0x10202000,
				            0xe80: 0x202000,
				            0xf80: 0x10000000,
				            0x1000: 0x10002000,
				            0x1100: 0x10200008,
				            0x1200: 0x10202008,
				            0x1300: 0x2008,
				            0x1400: 0x200000,
				            0x1500: 0x10000000,
				            0x1600: 0x10000008,
				            0x1700: 0x202000,
				            0x1800: 0x202008,
				            0x1900: 0x0,
				            0x1a00: 0x8,
				            0x1b00: 0x10200000,
				            0x1c00: 0x2000,
				            0x1d00: 0x10002008,
				            0x1e00: 0x10202000,
				            0x1f00: 0x200008,
				            0x1080: 0x8,
				            0x1180: 0x202000,
				            0x1280: 0x200000,
				            0x1380: 0x10000008,
				            0x1480: 0x10002000,
				            0x1580: 0x2008,
				            0x1680: 0x10202008,
				            0x1780: 0x10200000,
				            0x1880: 0x10202000,
				            0x1980: 0x10200008,
				            0x1a80: 0x2000,
				            0x1b80: 0x202008,
				            0x1c80: 0x200008,
				            0x1d80: 0x0,
				            0x1e80: 0x10000000,
				            0x1f80: 0x10002008
				        },
				        {
				            0x0: 0x100000,
				            0x10: 0x2000401,
				            0x20: 0x400,
				            0x30: 0x100401,
				            0x40: 0x2100401,
				            0x50: 0x0,
				            0x60: 0x1,
				            0x70: 0x2100001,
				            0x80: 0x2000400,
				            0x90: 0x100001,
				            0xa0: 0x2000001,
				            0xb0: 0x2100400,
				            0xc0: 0x2100000,
				            0xd0: 0x401,
				            0xe0: 0x100400,
				            0xf0: 0x2000000,
				            0x8: 0x2100001,
				            0x18: 0x0,
				            0x28: 0x2000401,
				            0x38: 0x2100400,
				            0x48: 0x100000,
				            0x58: 0x2000001,
				            0x68: 0x2000000,
				            0x78: 0x401,
				            0x88: 0x100401,
				            0x98: 0x2000400,
				            0xa8: 0x2100000,
				            0xb8: 0x100001,
				            0xc8: 0x400,
				            0xd8: 0x2100401,
				            0xe8: 0x1,
				            0xf8: 0x100400,
				            0x100: 0x2000000,
				            0x110: 0x100000,
				            0x120: 0x2000401,
				            0x130: 0x2100001,
				            0x140: 0x100001,
				            0x150: 0x2000400,
				            0x160: 0x2100400,
				            0x170: 0x100401,
				            0x180: 0x401,
				            0x190: 0x2100401,
				            0x1a0: 0x100400,
				            0x1b0: 0x1,
				            0x1c0: 0x0,
				            0x1d0: 0x2100000,
				            0x1e0: 0x2000001,
				            0x1f0: 0x400,
				            0x108: 0x100400,
				            0x118: 0x2000401,
				            0x128: 0x2100001,
				            0x138: 0x1,
				            0x148: 0x2000000,
				            0x158: 0x100000,
				            0x168: 0x401,
				            0x178: 0x2100400,
				            0x188: 0x2000001,
				            0x198: 0x2100000,
				            0x1a8: 0x0,
				            0x1b8: 0x2100401,
				            0x1c8: 0x100401,
				            0x1d8: 0x400,
				            0x1e8: 0x2000400,
				            0x1f8: 0x100001
				        },
				        {
				            0x0: 0x8000820,
				            0x1: 0x20000,
				            0x2: 0x8000000,
				            0x3: 0x20,
				            0x4: 0x20020,
				            0x5: 0x8020820,
				            0x6: 0x8020800,
				            0x7: 0x800,
				            0x8: 0x8020000,
				            0x9: 0x8000800,
				            0xa: 0x20800,
				            0xb: 0x8020020,
				            0xc: 0x820,
				            0xd: 0x0,
				            0xe: 0x8000020,
				            0xf: 0x20820,
				            0x80000000: 0x800,
				            0x80000001: 0x8020820,
				            0x80000002: 0x8000820,
				            0x80000003: 0x8000000,
				            0x80000004: 0x8020000,
				            0x80000005: 0x20800,
				            0x80000006: 0x20820,
				            0x80000007: 0x20,
				            0x80000008: 0x8000020,
				            0x80000009: 0x820,
				            0x8000000a: 0x20020,
				            0x8000000b: 0x8020800,
				            0x8000000c: 0x0,
				            0x8000000d: 0x8020020,
				            0x8000000e: 0x8000800,
				            0x8000000f: 0x20000,
				            0x10: 0x20820,
				            0x11: 0x8020800,
				            0x12: 0x20,
				            0x13: 0x800,
				            0x14: 0x8000800,
				            0x15: 0x8000020,
				            0x16: 0x8020020,
				            0x17: 0x20000,
				            0x18: 0x0,
				            0x19: 0x20020,
				            0x1a: 0x8020000,
				            0x1b: 0x8000820,
				            0x1c: 0x8020820,
				            0x1d: 0x20800,
				            0x1e: 0x820,
				            0x1f: 0x8000000,
				            0x80000010: 0x20000,
				            0x80000011: 0x800,
				            0x80000012: 0x8020020,
				            0x80000013: 0x20820,
				            0x80000014: 0x20,
				            0x80000015: 0x8020000,
				            0x80000016: 0x8000000,
				            0x80000017: 0x8000820,
				            0x80000018: 0x8020820,
				            0x80000019: 0x8000020,
				            0x8000001a: 0x8000800,
				            0x8000001b: 0x0,
				            0x8000001c: 0x20800,
				            0x8000001d: 0x820,
				            0x8000001e: 0x20020,
				            0x8000001f: 0x8020800
				        }
				    ];

				    // Masks that select the SBOX input
				    var SBOX_MASK = [
				        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
				        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
				    ];

				    /**
				     * DES block cipher algorithm.
				     */
				    var DES = C_algo.DES = BlockCipher.extend({
				        _doReset: function () {
				            // Shortcuts
				            var key = this._key;
				            var keyWords = key.words;

				            // Select 56 bits according to PC1
				            var keyBits = [];
				            for (var i = 0; i < 56; i++) {
				                var keyBitPos = PC1[i] - 1;
				                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
				            }

				            // Assemble 16 subkeys
				            var subKeys = this._subKeys = [];
				            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
				                // Create subkey
				                var subKey = subKeys[nSubKey] = [];

				                // Shortcut
				                var bitShift = BIT_SHIFTS[nSubKey];

				                // Select 48 bits according to PC2
				                for (var i = 0; i < 24; i++) {
				                    // Select from the left 28 key bits
				                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

				                    // Select from the right 28 key bits
				                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
				                }

				                // Since each subkey is applied to an expanded 32-bit input,
				                // the subkey can be broken into 8 values scaled to 32-bits,
				                // which allows the key to be used without expansion
				                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
				                for (var i = 1; i < 7; i++) {
				                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
				                }
				                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
				            }

				            // Compute inverse subkeys
				            var invSubKeys = this._invSubKeys = [];
				            for (var i = 0; i < 16; i++) {
				                invSubKeys[i] = subKeys[15 - i];
				            }
				        },

				        encryptBlock: function (M, offset) {
				            this._doCryptBlock(M, offset, this._subKeys);
				        },

				        decryptBlock: function (M, offset) {
				            this._doCryptBlock(M, offset, this._invSubKeys);
				        },

				        _doCryptBlock: function (M, offset, subKeys) {
				            // Get input
				            this._lBlock = M[offset];
				            this._rBlock = M[offset + 1];

				            // Initial permutation
				            exchangeLR.call(this, 4,  0x0f0f0f0f);
				            exchangeLR.call(this, 16, 0x0000ffff);
				            exchangeRL.call(this, 2,  0x33333333);
				            exchangeRL.call(this, 8,  0x00ff00ff);
				            exchangeLR.call(this, 1,  0x55555555);

				            // Rounds
				            for (var round = 0; round < 16; round++) {
				                // Shortcuts
				                var subKey = subKeys[round];
				                var lBlock = this._lBlock;
				                var rBlock = this._rBlock;

				                // Feistel function
				                var f = 0;
				                for (var i = 0; i < 8; i++) {
				                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
				                }
				                this._lBlock = rBlock;
				                this._rBlock = lBlock ^ f;
				            }

				            // Undo swap from last round
				            var t = this._lBlock;
				            this._lBlock = this._rBlock;
				            this._rBlock = t;

				            // Final permutation
				            exchangeLR.call(this, 1,  0x55555555);
				            exchangeRL.call(this, 8,  0x00ff00ff);
				            exchangeRL.call(this, 2,  0x33333333);
				            exchangeLR.call(this, 16, 0x0000ffff);
				            exchangeLR.call(this, 4,  0x0f0f0f0f);

				            // Set output
				            M[offset] = this._lBlock;
				            M[offset + 1] = this._rBlock;
				        },

				        keySize: 64/32,

				        ivSize: 64/32,

				        blockSize: 64/32
				    });

				    // Swap bits across the left and right words
				    function exchangeLR(offset, mask) {
				        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
				        this._rBlock ^= t;
				        this._lBlock ^= t << offset;
				    }

				    function exchangeRL(offset, mask) {
				        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
				        this._lBlock ^= t;
				        this._rBlock ^= t << offset;
				    }

				    /**
				     * Shortcut functions to the cipher's object interface.
				     *
				     * @example
				     *
				     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
				     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
				     */
				    C.DES = BlockCipher._createHelper(DES);

				    /**
				     * Triple-DES block cipher algorithm.
				     */
				    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
				        _doReset: function () {
				            // Shortcuts
				            var key = this._key;
				            var keyWords = key.words;
				            // Make sure the key length is valid (64, 128 or >= 192 bit)
				            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
				                throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');
				            }

				            // Extend the key according to the keying options defined in 3DES standard
				            var key1 = keyWords.slice(0, 2);
				            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
				            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);

				            // Create DES instances
				            this._des1 = DES.createEncryptor(WordArray.create(key1));
				            this._des2 = DES.createEncryptor(WordArray.create(key2));
				            this._des3 = DES.createEncryptor(WordArray.create(key3));
				        },

				        encryptBlock: function (M, offset) {
				            this._des1.encryptBlock(M, offset);
				            this._des2.decryptBlock(M, offset);
				            this._des3.encryptBlock(M, offset);
				        },

				        decryptBlock: function (M, offset) {
				            this._des3.decryptBlock(M, offset);
				            this._des2.encryptBlock(M, offset);
				            this._des1.decryptBlock(M, offset);
				        },

				        keySize: 192/32,

				        ivSize: 64/32,

				        blockSize: 64/32
				    });

				    /**
				     * Shortcut functions to the cipher's object interface.
				     *
				     * @example
				     *
				     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
				     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
				     */
				    C.TripleDES = BlockCipher._createHelper(TripleDES);
				}());


				return CryptoJS.TripleDES;

			})); 
		} (tripledes$1));
		return tripledes$1.exports;
	}

	var rc4$1 = {exports: {}};

	var rc4 = rc4$1.exports;

	var hasRequiredRc4;

	function requireRc4 () {
		if (hasRequiredRc4) return rc4$1.exports;
		hasRequiredRc4 = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
				}
			}(rc4, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var StreamCipher = C_lib.StreamCipher;
				    var C_algo = C.algo;

				    /**
				     * RC4 stream cipher algorithm.
				     */
				    var RC4 = C_algo.RC4 = StreamCipher.extend({
				        _doReset: function () {
				            // Shortcuts
				            var key = this._key;
				            var keyWords = key.words;
				            var keySigBytes = key.sigBytes;

				            // Init sbox
				            var S = this._S = [];
				            for (var i = 0; i < 256; i++) {
				                S[i] = i;
				            }

				            // Key setup
				            for (var i = 0, j = 0; i < 256; i++) {
				                var keyByteIndex = i % keySigBytes;
				                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

				                j = (j + S[i] + keyByte) % 256;

				                // Swap
				                var t = S[i];
				                S[i] = S[j];
				                S[j] = t;
				            }

				            // Counters
				            this._i = this._j = 0;
				        },

				        _doProcessBlock: function (M, offset) {
				            M[offset] ^= generateKeystreamWord.call(this);
				        },

				        keySize: 256/32,

				        ivSize: 0
				    });

				    function generateKeystreamWord() {
				        // Shortcuts
				        var S = this._S;
				        var i = this._i;
				        var j = this._j;

				        // Generate keystream word
				        var keystreamWord = 0;
				        for (var n = 0; n < 4; n++) {
				            i = (i + 1) % 256;
				            j = (j + S[i]) % 256;

				            // Swap
				            var t = S[i];
				            S[i] = S[j];
				            S[j] = t;

				            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
				        }

				        // Update counters
				        this._i = i;
				        this._j = j;

				        return keystreamWord;
				    }

				    /**
				     * Shortcut functions to the cipher's object interface.
				     *
				     * @example
				     *
				     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
				     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
				     */
				    C.RC4 = StreamCipher._createHelper(RC4);

				    /**
				     * Modified RC4 stream cipher algorithm.
				     */
				    var RC4Drop = C_algo.RC4Drop = RC4.extend({
				        /**
				         * Configuration options.
				         *
				         * @property {number} drop The number of keystream words to drop. Default 192
				         */
				        cfg: RC4.cfg.extend({
				            drop: 192
				        }),

				        _doReset: function () {
				            RC4._doReset.call(this);

				            // Drop
				            for (var i = this.cfg.drop; i > 0; i--) {
				                generateKeystreamWord.call(this);
				            }
				        }
				    });

				    /**
				     * Shortcut functions to the cipher's object interface.
				     *
				     * @example
				     *
				     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
				     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
				     */
				    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
				}());


				return CryptoJS.RC4;

			})); 
		} (rc4$1));
		return rc4$1.exports;
	}

	var rabbit$1 = {exports: {}};

	var rabbit = rabbit$1.exports;

	var hasRequiredRabbit;

	function requireRabbit () {
		if (hasRequiredRabbit) return rabbit$1.exports;
		hasRequiredRabbit = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
				}
			}(rabbit, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var StreamCipher = C_lib.StreamCipher;
				    var C_algo = C.algo;

				    // Reusable objects
				    var S  = [];
				    var C_ = [];
				    var G  = [];

				    /**
				     * Rabbit stream cipher algorithm
				     */
				    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
				        _doReset: function () {
				            // Shortcuts
				            var K = this._key.words;
				            var iv = this.cfg.iv;

				            // Swap endian
				            for (var i = 0; i < 4; i++) {
				                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
				                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
				            }

				            // Generate initial state values
				            var X = this._X = [
				                K[0], (K[3] << 16) | (K[2] >>> 16),
				                K[1], (K[0] << 16) | (K[3] >>> 16),
				                K[2], (K[1] << 16) | (K[0] >>> 16),
				                K[3], (K[2] << 16) | (K[1] >>> 16)
				            ];

				            // Generate initial counter values
				            var C = this._C = [
				                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
				                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
				                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
				                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
				            ];

				            // Carry bit
				            this._b = 0;

				            // Iterate the system four times
				            for (var i = 0; i < 4; i++) {
				                nextState.call(this);
				            }

				            // Modify the counters
				            for (var i = 0; i < 8; i++) {
				                C[i] ^= X[(i + 4) & 7];
				            }

				            // IV setup
				            if (iv) {
				                // Shortcuts
				                var IV = iv.words;
				                var IV_0 = IV[0];
				                var IV_1 = IV[1];

				                // Generate four subvectors
				                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
				                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
				                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
				                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

				                // Modify counter values
				                C[0] ^= i0;
				                C[1] ^= i1;
				                C[2] ^= i2;
				                C[3] ^= i3;
				                C[4] ^= i0;
				                C[5] ^= i1;
				                C[6] ^= i2;
				                C[7] ^= i3;

				                // Iterate the system four times
				                for (var i = 0; i < 4; i++) {
				                    nextState.call(this);
				                }
				            }
				        },

				        _doProcessBlock: function (M, offset) {
				            // Shortcut
				            var X = this._X;

				            // Iterate the system
				            nextState.call(this);

				            // Generate four keystream words
				            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
				            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
				            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
				            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

				            for (var i = 0; i < 4; i++) {
				                // Swap endian
				                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
				                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

				                // Encrypt
				                M[offset + i] ^= S[i];
				            }
				        },

				        blockSize: 128/32,

				        ivSize: 64/32
				    });

				    function nextState() {
				        // Shortcuts
				        var X = this._X;
				        var C = this._C;

				        // Save old counter values
				        for (var i = 0; i < 8; i++) {
				            C_[i] = C[i];
				        }

				        // Calculate new counter values
				        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
				        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
				        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
				        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
				        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
				        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
				        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
				        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
				        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

				        // Calculate the g-values
				        for (var i = 0; i < 8; i++) {
				            var gx = X[i] + C[i];

				            // Construct high and low argument for squaring
				            var ga = gx & 0xffff;
				            var gb = gx >>> 16;

				            // Calculate high and low result of squaring
				            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
				            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

				            // High XOR low
				            G[i] = gh ^ gl;
				        }

				        // Calculate new state values
				        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
				        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
				        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
				        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
				        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
				        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
				        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
				        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
				    }

				    /**
				     * Shortcut functions to the cipher's object interface.
				     *
				     * @example
				     *
				     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
				     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
				     */
				    C.Rabbit = StreamCipher._createHelper(Rabbit);
				}());


				return CryptoJS.Rabbit;

			})); 
		} (rabbit$1));
		return rabbit$1.exports;
	}

	var rabbitLegacy$1 = {exports: {}};

	var rabbitLegacy = rabbitLegacy$1.exports;

	var hasRequiredRabbitLegacy;

	function requireRabbitLegacy () {
		if (hasRequiredRabbitLegacy) return rabbitLegacy$1.exports;
		hasRequiredRabbitLegacy = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
				}
			}(rabbitLegacy, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var StreamCipher = C_lib.StreamCipher;
				    var C_algo = C.algo;

				    // Reusable objects
				    var S  = [];
				    var C_ = [];
				    var G  = [];

				    /**
				     * Rabbit stream cipher algorithm.
				     *
				     * This is a legacy version that neglected to convert the key to little-endian.
				     * This error doesn't affect the cipher's security,
				     * but it does affect its compatibility with other implementations.
				     */
				    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
				        _doReset: function () {
				            // Shortcuts
				            var K = this._key.words;
				            var iv = this.cfg.iv;

				            // Generate initial state values
				            var X = this._X = [
				                K[0], (K[3] << 16) | (K[2] >>> 16),
				                K[1], (K[0] << 16) | (K[3] >>> 16),
				                K[2], (K[1] << 16) | (K[0] >>> 16),
				                K[3], (K[2] << 16) | (K[1] >>> 16)
				            ];

				            // Generate initial counter values
				            var C = this._C = [
				                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
				                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
				                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
				                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
				            ];

				            // Carry bit
				            this._b = 0;

				            // Iterate the system four times
				            for (var i = 0; i < 4; i++) {
				                nextState.call(this);
				            }

				            // Modify the counters
				            for (var i = 0; i < 8; i++) {
				                C[i] ^= X[(i + 4) & 7];
				            }

				            // IV setup
				            if (iv) {
				                // Shortcuts
				                var IV = iv.words;
				                var IV_0 = IV[0];
				                var IV_1 = IV[1];

				                // Generate four subvectors
				                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
				                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
				                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
				                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

				                // Modify counter values
				                C[0] ^= i0;
				                C[1] ^= i1;
				                C[2] ^= i2;
				                C[3] ^= i3;
				                C[4] ^= i0;
				                C[5] ^= i1;
				                C[6] ^= i2;
				                C[7] ^= i3;

				                // Iterate the system four times
				                for (var i = 0; i < 4; i++) {
				                    nextState.call(this);
				                }
				            }
				        },

				        _doProcessBlock: function (M, offset) {
				            // Shortcut
				            var X = this._X;

				            // Iterate the system
				            nextState.call(this);

				            // Generate four keystream words
				            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
				            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
				            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
				            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

				            for (var i = 0; i < 4; i++) {
				                // Swap endian
				                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
				                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

				                // Encrypt
				                M[offset + i] ^= S[i];
				            }
				        },

				        blockSize: 128/32,

				        ivSize: 64/32
				    });

				    function nextState() {
				        // Shortcuts
				        var X = this._X;
				        var C = this._C;

				        // Save old counter values
				        for (var i = 0; i < 8; i++) {
				            C_[i] = C[i];
				        }

				        // Calculate new counter values
				        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
				        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
				        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
				        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
				        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
				        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
				        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
				        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
				        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

				        // Calculate the g-values
				        for (var i = 0; i < 8; i++) {
				            var gx = X[i] + C[i];

				            // Construct high and low argument for squaring
				            var ga = gx & 0xffff;
				            var gb = gx >>> 16;

				            // Calculate high and low result of squaring
				            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
				            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

				            // High XOR low
				            G[i] = gh ^ gl;
				        }

				        // Calculate new state values
				        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
				        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
				        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
				        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
				        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
				        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
				        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
				        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
				    }

				    /**
				     * Shortcut functions to the cipher's object interface.
				     *
				     * @example
				     *
				     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
				     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
				     */
				    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
				}());


				return CryptoJS.RabbitLegacy;

			})); 
		} (rabbitLegacy$1));
		return rabbitLegacy$1.exports;
	}

	var blowfish$1 = {exports: {}};

	var blowfish = blowfish$1.exports;

	var hasRequiredBlowfish;

	function requireBlowfish () {
		if (hasRequiredBlowfish) return blowfish$1.exports;
		hasRequiredBlowfish = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
				}
			}(blowfish, function (CryptoJS) {

				(function () {
				    // Shortcuts
				    var C = CryptoJS;
				    var C_lib = C.lib;
				    var BlockCipher = C_lib.BlockCipher;
				    var C_algo = C.algo;

				    const N = 16;

				    //Origin pbox and sbox, derived from PI
				    const ORIG_P = [
				        0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,
				        0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,
				        0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,
				        0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917,
				        0x9216D5D9, 0x8979FB1B
				    ];

				    const ORIG_S = [
				        [   0xD1310BA6, 0x98DFB5AC, 0x2FFD72DB, 0xD01ADFB7,
				            0xB8E1AFED, 0x6A267E96, 0xBA7C9045, 0xF12C7F99,
				            0x24A19947, 0xB3916CF7, 0x0801F2E2, 0x858EFC16,
				            0x636920D8, 0x71574E69, 0xA458FEA3, 0xF4933D7E,
				            0x0D95748F, 0x728EB658, 0x718BCD58, 0x82154AEE,
				            0x7B54A41D, 0xC25A59B5, 0x9C30D539, 0x2AF26013,
				            0xC5D1B023, 0x286085F0, 0xCA417918, 0xB8DB38EF,
				            0x8E79DCB0, 0x603A180E, 0x6C9E0E8B, 0xB01E8A3E,
				            0xD71577C1, 0xBD314B27, 0x78AF2FDA, 0x55605C60,
				            0xE65525F3, 0xAA55AB94, 0x57489862, 0x63E81440,
				            0x55CA396A, 0x2AAB10B6, 0xB4CC5C34, 0x1141E8CE,
				            0xA15486AF, 0x7C72E993, 0xB3EE1411, 0x636FBC2A,
				            0x2BA9C55D, 0x741831F6, 0xCE5C3E16, 0x9B87931E,
				            0xAFD6BA33, 0x6C24CF5C, 0x7A325381, 0x28958677,
				            0x3B8F4898, 0x6B4BB9AF, 0xC4BFE81B, 0x66282193,
				            0x61D809CC, 0xFB21A991, 0x487CAC60, 0x5DEC8032,
				            0xEF845D5D, 0xE98575B1, 0xDC262302, 0xEB651B88,
				            0x23893E81, 0xD396ACC5, 0x0F6D6FF3, 0x83F44239,
				            0x2E0B4482, 0xA4842004, 0x69C8F04A, 0x9E1F9B5E,
				            0x21C66842, 0xF6E96C9A, 0x670C9C61, 0xABD388F0,
				            0x6A51A0D2, 0xD8542F68, 0x960FA728, 0xAB5133A3,
				            0x6EEF0B6C, 0x137A3BE4, 0xBA3BF050, 0x7EFB2A98,
				            0xA1F1651D, 0x39AF0176, 0x66CA593E, 0x82430E88,
				            0x8CEE8619, 0x456F9FB4, 0x7D84A5C3, 0x3B8B5EBE,
				            0xE06F75D8, 0x85C12073, 0x401A449F, 0x56C16AA6,
				            0x4ED3AA62, 0x363F7706, 0x1BFEDF72, 0x429B023D,
				            0x37D0D724, 0xD00A1248, 0xDB0FEAD3, 0x49F1C09B,
				            0x075372C9, 0x80991B7B, 0x25D479D8, 0xF6E8DEF7,
				            0xE3FE501A, 0xB6794C3B, 0x976CE0BD, 0x04C006BA,
				            0xC1A94FB6, 0x409F60C4, 0x5E5C9EC2, 0x196A2463,
				            0x68FB6FAF, 0x3E6C53B5, 0x1339B2EB, 0x3B52EC6F,
				            0x6DFC511F, 0x9B30952C, 0xCC814544, 0xAF5EBD09,
				            0xBEE3D004, 0xDE334AFD, 0x660F2807, 0x192E4BB3,
				            0xC0CBA857, 0x45C8740F, 0xD20B5F39, 0xB9D3FBDB,
				            0x5579C0BD, 0x1A60320A, 0xD6A100C6, 0x402C7279,
				            0x679F25FE, 0xFB1FA3CC, 0x8EA5E9F8, 0xDB3222F8,
				            0x3C7516DF, 0xFD616B15, 0x2F501EC8, 0xAD0552AB,
				            0x323DB5FA, 0xFD238760, 0x53317B48, 0x3E00DF82,
				            0x9E5C57BB, 0xCA6F8CA0, 0x1A87562E, 0xDF1769DB,
				            0xD542A8F6, 0x287EFFC3, 0xAC6732C6, 0x8C4F5573,
				            0x695B27B0, 0xBBCA58C8, 0xE1FFA35D, 0xB8F011A0,
				            0x10FA3D98, 0xFD2183B8, 0x4AFCB56C, 0x2DD1D35B,
				            0x9A53E479, 0xB6F84565, 0xD28E49BC, 0x4BFB9790,
				            0xE1DDF2DA, 0xA4CB7E33, 0x62FB1341, 0xCEE4C6E8,
				            0xEF20CADA, 0x36774C01, 0xD07E9EFE, 0x2BF11FB4,
				            0x95DBDA4D, 0xAE909198, 0xEAAD8E71, 0x6B93D5A0,
				            0xD08ED1D0, 0xAFC725E0, 0x8E3C5B2F, 0x8E7594B7,
				            0x8FF6E2FB, 0xF2122B64, 0x8888B812, 0x900DF01C,
				            0x4FAD5EA0, 0x688FC31C, 0xD1CFF191, 0xB3A8C1AD,
				            0x2F2F2218, 0xBE0E1777, 0xEA752DFE, 0x8B021FA1,
				            0xE5A0CC0F, 0xB56F74E8, 0x18ACF3D6, 0xCE89E299,
				            0xB4A84FE0, 0xFD13E0B7, 0x7CC43B81, 0xD2ADA8D9,
				            0x165FA266, 0x80957705, 0x93CC7314, 0x211A1477,
				            0xE6AD2065, 0x77B5FA86, 0xC75442F5, 0xFB9D35CF,
				            0xEBCDAF0C, 0x7B3E89A0, 0xD6411BD3, 0xAE1E7E49,
				            0x00250E2D, 0x2071B35E, 0x226800BB, 0x57B8E0AF,
				            0x2464369B, 0xF009B91E, 0x5563911D, 0x59DFA6AA,
				            0x78C14389, 0xD95A537F, 0x207D5BA2, 0x02E5B9C5,
				            0x83260376, 0x6295CFA9, 0x11C81968, 0x4E734A41,
				            0xB3472DCA, 0x7B14A94A, 0x1B510052, 0x9A532915,
				            0xD60F573F, 0xBC9BC6E4, 0x2B60A476, 0x81E67400,
				            0x08BA6FB5, 0x571BE91F, 0xF296EC6B, 0x2A0DD915,
				            0xB6636521, 0xE7B9F9B6, 0xFF34052E, 0xC5855664,
				            0x53B02D5D, 0xA99F8FA1, 0x08BA4799, 0x6E85076A   ],
				        [   0x4B7A70E9, 0xB5B32944, 0xDB75092E, 0xC4192623,
				            0xAD6EA6B0, 0x49A7DF7D, 0x9CEE60B8, 0x8FEDB266,
				            0xECAA8C71, 0x699A17FF, 0x5664526C, 0xC2B19EE1,
				            0x193602A5, 0x75094C29, 0xA0591340, 0xE4183A3E,
				            0x3F54989A, 0x5B429D65, 0x6B8FE4D6, 0x99F73FD6,
				            0xA1D29C07, 0xEFE830F5, 0x4D2D38E6, 0xF0255DC1,
				            0x4CDD2086, 0x8470EB26, 0x6382E9C6, 0x021ECC5E,
				            0x09686B3F, 0x3EBAEFC9, 0x3C971814, 0x6B6A70A1,
				            0x687F3584, 0x52A0E286, 0xB79C5305, 0xAA500737,
				            0x3E07841C, 0x7FDEAE5C, 0x8E7D44EC, 0x5716F2B8,
				            0xB03ADA37, 0xF0500C0D, 0xF01C1F04, 0x0200B3FF,
				            0xAE0CF51A, 0x3CB574B2, 0x25837A58, 0xDC0921BD,
				            0xD19113F9, 0x7CA92FF6, 0x94324773, 0x22F54701,
				            0x3AE5E581, 0x37C2DADC, 0xC8B57634, 0x9AF3DDA7,
				            0xA9446146, 0x0FD0030E, 0xECC8C73E, 0xA4751E41,
				            0xE238CD99, 0x3BEA0E2F, 0x3280BBA1, 0x183EB331,
				            0x4E548B38, 0x4F6DB908, 0x6F420D03, 0xF60A04BF,
				            0x2CB81290, 0x24977C79, 0x5679B072, 0xBCAF89AF,
				            0xDE9A771F, 0xD9930810, 0xB38BAE12, 0xDCCF3F2E,
				            0x5512721F, 0x2E6B7124, 0x501ADDE6, 0x9F84CD87,
				            0x7A584718, 0x7408DA17, 0xBC9F9ABC, 0xE94B7D8C,
				            0xEC7AEC3A, 0xDB851DFA, 0x63094366, 0xC464C3D2,
				            0xEF1C1847, 0x3215D908, 0xDD433B37, 0x24C2BA16,
				            0x12A14D43, 0x2A65C451, 0x50940002, 0x133AE4DD,
				            0x71DFF89E, 0x10314E55, 0x81AC77D6, 0x5F11199B,
				            0x043556F1, 0xD7A3C76B, 0x3C11183B, 0x5924A509,
				            0xF28FE6ED, 0x97F1FBFA, 0x9EBABF2C, 0x1E153C6E,
				            0x86E34570, 0xEAE96FB1, 0x860E5E0A, 0x5A3E2AB3,
				            0x771FE71C, 0x4E3D06FA, 0x2965DCB9, 0x99E71D0F,
				            0x803E89D6, 0x5266C825, 0x2E4CC978, 0x9C10B36A,
				            0xC6150EBA, 0x94E2EA78, 0xA5FC3C53, 0x1E0A2DF4,
				            0xF2F74EA7, 0x361D2B3D, 0x1939260F, 0x19C27960,
				            0x5223A708, 0xF71312B6, 0xEBADFE6E, 0xEAC31F66,
				            0xE3BC4595, 0xA67BC883, 0xB17F37D1, 0x018CFF28,
				            0xC332DDEF, 0xBE6C5AA5, 0x65582185, 0x68AB9802,
				            0xEECEA50F, 0xDB2F953B, 0x2AEF7DAD, 0x5B6E2F84,
				            0x1521B628, 0x29076170, 0xECDD4775, 0x619F1510,
				            0x13CCA830, 0xEB61BD96, 0x0334FE1E, 0xAA0363CF,
				            0xB5735C90, 0x4C70A239, 0xD59E9E0B, 0xCBAADE14,
				            0xEECC86BC, 0x60622CA7, 0x9CAB5CAB, 0xB2F3846E,
				            0x648B1EAF, 0x19BDF0CA, 0xA02369B9, 0x655ABB50,
				            0x40685A32, 0x3C2AB4B3, 0x319EE9D5, 0xC021B8F7,
				            0x9B540B19, 0x875FA099, 0x95F7997E, 0x623D7DA8,
				            0xF837889A, 0x97E32D77, 0x11ED935F, 0x16681281,
				            0x0E358829, 0xC7E61FD6, 0x96DEDFA1, 0x7858BA99,
				            0x57F584A5, 0x1B227263, 0x9B83C3FF, 0x1AC24696,
				            0xCDB30AEB, 0x532E3054, 0x8FD948E4, 0x6DBC3128,
				            0x58EBF2EF, 0x34C6FFEA, 0xFE28ED61, 0xEE7C3C73,
				            0x5D4A14D9, 0xE864B7E3, 0x42105D14, 0x203E13E0,
				            0x45EEE2B6, 0xA3AAABEA, 0xDB6C4F15, 0xFACB4FD0,
				            0xC742F442, 0xEF6ABBB5, 0x654F3B1D, 0x41CD2105,
				            0xD81E799E, 0x86854DC7, 0xE44B476A, 0x3D816250,
				            0xCF62A1F2, 0x5B8D2646, 0xFC8883A0, 0xC1C7B6A3,
				            0x7F1524C3, 0x69CB7492, 0x47848A0B, 0x5692B285,
				            0x095BBF00, 0xAD19489D, 0x1462B174, 0x23820E00,
				            0x58428D2A, 0x0C55F5EA, 0x1DADF43E, 0x233F7061,
				            0x3372F092, 0x8D937E41, 0xD65FECF1, 0x6C223BDB,
				            0x7CDE3759, 0xCBEE7460, 0x4085F2A7, 0xCE77326E,
				            0xA6078084, 0x19F8509E, 0xE8EFD855, 0x61D99735,
				            0xA969A7AA, 0xC50C06C2, 0x5A04ABFC, 0x800BCADC,
				            0x9E447A2E, 0xC3453484, 0xFDD56705, 0x0E1E9EC9,
				            0xDB73DBD3, 0x105588CD, 0x675FDA79, 0xE3674340,
				            0xC5C43465, 0x713E38D8, 0x3D28F89E, 0xF16DFF20,
				            0x153E21E7, 0x8FB03D4A, 0xE6E39F2B, 0xDB83ADF7   ],
				        [   0xE93D5A68, 0x948140F7, 0xF64C261C, 0x94692934,
				            0x411520F7, 0x7602D4F7, 0xBCF46B2E, 0xD4A20068,
				            0xD4082471, 0x3320F46A, 0x43B7D4B7, 0x500061AF,
				            0x1E39F62E, 0x97244546, 0x14214F74, 0xBF8B8840,
				            0x4D95FC1D, 0x96B591AF, 0x70F4DDD3, 0x66A02F45,
				            0xBFBC09EC, 0x03BD9785, 0x7FAC6DD0, 0x31CB8504,
				            0x96EB27B3, 0x55FD3941, 0xDA2547E6, 0xABCA0A9A,
				            0x28507825, 0x530429F4, 0x0A2C86DA, 0xE9B66DFB,
				            0x68DC1462, 0xD7486900, 0x680EC0A4, 0x27A18DEE,
				            0x4F3FFEA2, 0xE887AD8C, 0xB58CE006, 0x7AF4D6B6,
				            0xAACE1E7C, 0xD3375FEC, 0xCE78A399, 0x406B2A42,
				            0x20FE9E35, 0xD9F385B9, 0xEE39D7AB, 0x3B124E8B,
				            0x1DC9FAF7, 0x4B6D1856, 0x26A36631, 0xEAE397B2,
				            0x3A6EFA74, 0xDD5B4332, 0x6841E7F7, 0xCA7820FB,
				            0xFB0AF54E, 0xD8FEB397, 0x454056AC, 0xBA489527,
				            0x55533A3A, 0x20838D87, 0xFE6BA9B7, 0xD096954B,
				            0x55A867BC, 0xA1159A58, 0xCCA92963, 0x99E1DB33,
				            0xA62A4A56, 0x3F3125F9, 0x5EF47E1C, 0x9029317C,
				            0xFDF8E802, 0x04272F70, 0x80BB155C, 0x05282CE3,
				            0x95C11548, 0xE4C66D22, 0x48C1133F, 0xC70F86DC,
				            0x07F9C9EE, 0x41041F0F, 0x404779A4, 0x5D886E17,
				            0x325F51EB, 0xD59BC0D1, 0xF2BCC18F, 0x41113564,
				            0x257B7834, 0x602A9C60, 0xDFF8E8A3, 0x1F636C1B,
				            0x0E12B4C2, 0x02E1329E, 0xAF664FD1, 0xCAD18115,
				            0x6B2395E0, 0x333E92E1, 0x3B240B62, 0xEEBEB922,
				            0x85B2A20E, 0xE6BA0D99, 0xDE720C8C, 0x2DA2F728,
				            0xD0127845, 0x95B794FD, 0x647D0862, 0xE7CCF5F0,
				            0x5449A36F, 0x877D48FA, 0xC39DFD27, 0xF33E8D1E,
				            0x0A476341, 0x992EFF74, 0x3A6F6EAB, 0xF4F8FD37,
				            0xA812DC60, 0xA1EBDDF8, 0x991BE14C, 0xDB6E6B0D,
				            0xC67B5510, 0x6D672C37, 0x2765D43B, 0xDCD0E804,
				            0xF1290DC7, 0xCC00FFA3, 0xB5390F92, 0x690FED0B,
				            0x667B9FFB, 0xCEDB7D9C, 0xA091CF0B, 0xD9155EA3,
				            0xBB132F88, 0x515BAD24, 0x7B9479BF, 0x763BD6EB,
				            0x37392EB3, 0xCC115979, 0x8026E297, 0xF42E312D,
				            0x6842ADA7, 0xC66A2B3B, 0x12754CCC, 0x782EF11C,
				            0x6A124237, 0xB79251E7, 0x06A1BBE6, 0x4BFB6350,
				            0x1A6B1018, 0x11CAEDFA, 0x3D25BDD8, 0xE2E1C3C9,
				            0x44421659, 0x0A121386, 0xD90CEC6E, 0xD5ABEA2A,
				            0x64AF674E, 0xDA86A85F, 0xBEBFE988, 0x64E4C3FE,
				            0x9DBC8057, 0xF0F7C086, 0x60787BF8, 0x6003604D,
				            0xD1FD8346, 0xF6381FB0, 0x7745AE04, 0xD736FCCC,
				            0x83426B33, 0xF01EAB71, 0xB0804187, 0x3C005E5F,
				            0x77A057BE, 0xBDE8AE24, 0x55464299, 0xBF582E61,
				            0x4E58F48F, 0xF2DDFDA2, 0xF474EF38, 0x8789BDC2,
				            0x5366F9C3, 0xC8B38E74, 0xB475F255, 0x46FCD9B9,
				            0x7AEB2661, 0x8B1DDF84, 0x846A0E79, 0x915F95E2,
				            0x466E598E, 0x20B45770, 0x8CD55591, 0xC902DE4C,
				            0xB90BACE1, 0xBB8205D0, 0x11A86248, 0x7574A99E,
				            0xB77F19B6, 0xE0A9DC09, 0x662D09A1, 0xC4324633,
				            0xE85A1F02, 0x09F0BE8C, 0x4A99A025, 0x1D6EFE10,
				            0x1AB93D1D, 0x0BA5A4DF, 0xA186F20F, 0x2868F169,
				            0xDCB7DA83, 0x573906FE, 0xA1E2CE9B, 0x4FCD7F52,
				            0x50115E01, 0xA70683FA, 0xA002B5C4, 0x0DE6D027,
				            0x9AF88C27, 0x773F8641, 0xC3604C06, 0x61A806B5,
				            0xF0177A28, 0xC0F586E0, 0x006058AA, 0x30DC7D62,
				            0x11E69ED7, 0x2338EA63, 0x53C2DD94, 0xC2C21634,
				            0xBBCBEE56, 0x90BCB6DE, 0xEBFC7DA1, 0xCE591D76,
				            0x6F05E409, 0x4B7C0188, 0x39720A3D, 0x7C927C24,
				            0x86E3725F, 0x724D9DB9, 0x1AC15BB4, 0xD39EB8FC,
				            0xED545578, 0x08FCA5B5, 0xD83D7CD3, 0x4DAD0FC4,
				            0x1E50EF5E, 0xB161E6F8, 0xA28514D9, 0x6C51133C,
				            0x6FD5C7E7, 0x56E14EC4, 0x362ABFCE, 0xDDC6C837,
				            0xD79A3234, 0x92638212, 0x670EFA8E, 0x406000E0  ],
				        [   0x3A39CE37, 0xD3FAF5CF, 0xABC27737, 0x5AC52D1B,
				            0x5CB0679E, 0x4FA33742, 0xD3822740, 0x99BC9BBE,
				            0xD5118E9D, 0xBF0F7315, 0xD62D1C7E, 0xC700C47B,
				            0xB78C1B6B, 0x21A19045, 0xB26EB1BE, 0x6A366EB4,
				            0x5748AB2F, 0xBC946E79, 0xC6A376D2, 0x6549C2C8,
				            0x530FF8EE, 0x468DDE7D, 0xD5730A1D, 0x4CD04DC6,
				            0x2939BBDB, 0xA9BA4650, 0xAC9526E8, 0xBE5EE304,
				            0xA1FAD5F0, 0x6A2D519A, 0x63EF8CE2, 0x9A86EE22,
				            0xC089C2B8, 0x43242EF6, 0xA51E03AA, 0x9CF2D0A4,
				            0x83C061BA, 0x9BE96A4D, 0x8FE51550, 0xBA645BD6,
				            0x2826A2F9, 0xA73A3AE1, 0x4BA99586, 0xEF5562E9,
				            0xC72FEFD3, 0xF752F7DA, 0x3F046F69, 0x77FA0A59,
				            0x80E4A915, 0x87B08601, 0x9B09E6AD, 0x3B3EE593,
				            0xE990FD5A, 0x9E34D797, 0x2CF0B7D9, 0x022B8B51,
				            0x96D5AC3A, 0x017DA67D, 0xD1CF3ED6, 0x7C7D2D28,
				            0x1F9F25CF, 0xADF2B89B, 0x5AD6B472, 0x5A88F54C,
				            0xE029AC71, 0xE019A5E6, 0x47B0ACFD, 0xED93FA9B,
				            0xE8D3C48D, 0x283B57CC, 0xF8D56629, 0x79132E28,
				            0x785F0191, 0xED756055, 0xF7960E44, 0xE3D35E8C,
				            0x15056DD4, 0x88F46DBA, 0x03A16125, 0x0564F0BD,
				            0xC3EB9E15, 0x3C9057A2, 0x97271AEC, 0xA93A072A,
				            0x1B3F6D9B, 0x1E6321F5, 0xF59C66FB, 0x26DCF319,
				            0x7533D928, 0xB155FDF5, 0x03563482, 0x8ABA3CBB,
				            0x28517711, 0xC20AD9F8, 0xABCC5167, 0xCCAD925F,
				            0x4DE81751, 0x3830DC8E, 0x379D5862, 0x9320F991,
				            0xEA7A90C2, 0xFB3E7BCE, 0x5121CE64, 0x774FBE32,
				            0xA8B6E37E, 0xC3293D46, 0x48DE5369, 0x6413E680,
				            0xA2AE0810, 0xDD6DB224, 0x69852DFD, 0x09072166,
				            0xB39A460A, 0x6445C0DD, 0x586CDECF, 0x1C20C8AE,
				            0x5BBEF7DD, 0x1B588D40, 0xCCD2017F, 0x6BB4E3BB,
				            0xDDA26A7E, 0x3A59FF45, 0x3E350A44, 0xBCB4CDD5,
				            0x72EACEA8, 0xFA6484BB, 0x8D6612AE, 0xBF3C6F47,
				            0xD29BE463, 0x542F5D9E, 0xAEC2771B, 0xF64E6370,
				            0x740E0D8D, 0xE75B1357, 0xF8721671, 0xAF537D5D,
				            0x4040CB08, 0x4EB4E2CC, 0x34D2466A, 0x0115AF84,
				            0xE1B00428, 0x95983A1D, 0x06B89FB4, 0xCE6EA048,
				            0x6F3F3B82, 0x3520AB82, 0x011A1D4B, 0x277227F8,
				            0x611560B1, 0xE7933FDC, 0xBB3A792B, 0x344525BD,
				            0xA08839E1, 0x51CE794B, 0x2F32C9B7, 0xA01FBAC9,
				            0xE01CC87E, 0xBCC7D1F6, 0xCF0111C3, 0xA1E8AAC7,
				            0x1A908749, 0xD44FBD9A, 0xD0DADECB, 0xD50ADA38,
				            0x0339C32A, 0xC6913667, 0x8DF9317C, 0xE0B12B4F,
				            0xF79E59B7, 0x43F5BB3A, 0xF2D519FF, 0x27D9459C,
				            0xBF97222C, 0x15E6FC2A, 0x0F91FC71, 0x9B941525,
				            0xFAE59361, 0xCEB69CEB, 0xC2A86459, 0x12BAA8D1,
				            0xB6C1075E, 0xE3056A0C, 0x10D25065, 0xCB03A442,
				            0xE0EC6E0E, 0x1698DB3B, 0x4C98A0BE, 0x3278E964,
				            0x9F1F9532, 0xE0D392DF, 0xD3A0342B, 0x8971F21E,
				            0x1B0A7441, 0x4BA3348C, 0xC5BE7120, 0xC37632D8,
				            0xDF359F8D, 0x9B992F2E, 0xE60B6F47, 0x0FE3F11D,
				            0xE54CDA54, 0x1EDAD891, 0xCE6279CF, 0xCD3E7E6F,
				            0x1618B166, 0xFD2C1D05, 0x848FD2C5, 0xF6FB2299,
				            0xF523F357, 0xA6327623, 0x93A83531, 0x56CCCD02,
				            0xACF08162, 0x5A75EBB5, 0x6E163697, 0x88D273CC,
				            0xDE966292, 0x81B949D0, 0x4C50901B, 0x71C65614,
				            0xE6C6C7BD, 0x327A140A, 0x45E1D006, 0xC3F27B9A,
				            0xC9AA53FD, 0x62A80F00, 0xBB25BFE2, 0x35BDD2F6,
				            0x71126905, 0xB2040222, 0xB6CBCF7C, 0xCD769C2B,
				            0x53113EC0, 0x1640E3D3, 0x38ABBD60, 0x2547ADF0,
				            0xBA38209C, 0xF746CE76, 0x77AFA1C5, 0x20756060,
				            0x85CBFE4E, 0x8AE88DD8, 0x7AAAF9B0, 0x4CF9AA7E,
				            0x1948C25C, 0x02FB8A8C, 0x01C36AE4, 0xD6EBE1F9,
				            0x90D4F869, 0xA65CDEA0, 0x3F09252D, 0xC208E69F,
				            0xB74E6132, 0xCE77E25B, 0x578FDFE3, 0x3AC372E6  ]
				    ];

				    var BLOWFISH_CTX = {
				        pbox: [],
				        sbox: []
				    };

				    function F(ctx, x){
				        let a = (x >> 24) & 0xFF;
				        let b = (x >> 16) & 0xFF;
				        let c = (x >> 8) & 0xFF;
				        let d = x & 0xFF;

				        let y = ctx.sbox[0][a] + ctx.sbox[1][b];
				        y = y ^ ctx.sbox[2][c];
				        y = y + ctx.sbox[3][d];

				        return y;
				    }

				    function BlowFish_Encrypt(ctx, left, right){
				        let Xl = left;
				        let Xr = right;
				        let temp;

				        for(let i = 0; i < N; ++i){
				            Xl = Xl ^ ctx.pbox[i];
				            Xr = F(ctx, Xl) ^ Xr;

				            temp = Xl;
				            Xl = Xr;
				            Xr = temp;
				        }

				        temp = Xl;
				        Xl = Xr;
				        Xr = temp;

				        Xr = Xr ^ ctx.pbox[N];
				        Xl = Xl ^ ctx.pbox[N + 1];

				        return {left: Xl, right: Xr};
				    }

				    function BlowFish_Decrypt(ctx, left, right){
				        let Xl = left;
				        let Xr = right;
				        let temp;

				        for(let i = N + 1; i > 1; --i){
				            Xl = Xl ^ ctx.pbox[i];
				            Xr = F(ctx, Xl) ^ Xr;

				            temp = Xl;
				            Xl = Xr;
				            Xr = temp;
				        }

				        temp = Xl;
				        Xl = Xr;
				        Xr = temp;

				        Xr = Xr ^ ctx.pbox[1];
				        Xl = Xl ^ ctx.pbox[0];

				        return {left: Xl, right: Xr};
				    }

				    /**
				     * Initialization ctx's pbox and sbox.
				     *
				     * @param {Object} ctx The object has pbox and sbox.
				     * @param {Array} key An array of 32-bit words.
				     * @param {int} keysize The length of the key.
				     *
				     * @example
				     *
				     *     BlowFishInit(BLOWFISH_CTX, key, 128/32);
				     */
				    function BlowFishInit(ctx, key, keysize)
				    {
				        for(let Row = 0; Row < 4; Row++)
				        {
				            ctx.sbox[Row] = [];
				            for(let Col = 0; Col < 256; Col++)
				            {
				                ctx.sbox[Row][Col] = ORIG_S[Row][Col];
				            }
				        }

				        let keyIndex = 0;
				        for(let index = 0; index < N + 2; index++)
				        {
				            ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
				            keyIndex++;
				            if(keyIndex >= keysize)
				            {
				                keyIndex = 0;
				            }
				        }

				        let Data1 = 0;
				        let Data2 = 0;
				        let res = 0;
				        for(let i = 0; i < N + 2; i += 2)
				        {
				            res = BlowFish_Encrypt(ctx, Data1, Data2);
				            Data1 = res.left;
				            Data2 = res.right;
				            ctx.pbox[i] = Data1;
				            ctx.pbox[i + 1] = Data2;
				        }

				        for(let i = 0; i < 4; i++)
				        {
				            for(let j = 0; j < 256; j += 2)
				            {
				                res = BlowFish_Encrypt(ctx, Data1, Data2);
				                Data1 = res.left;
				                Data2 = res.right;
				                ctx.sbox[i][j] = Data1;
				                ctx.sbox[i][j + 1] = Data2;
				            }
				        }

				        return true;
				    }

				    /**
				     * Blowfish block cipher algorithm.
				     */
				    var Blowfish = C_algo.Blowfish = BlockCipher.extend({
				        _doReset: function () {
				            // Skip reset of nRounds has been set before and key did not change
				            if (this._keyPriorReset === this._key) {
				                return;
				            }

				            // Shortcuts
				            var key = this._keyPriorReset = this._key;
				            var keyWords = key.words;
				            var keySize = key.sigBytes / 4;

				            //Initialization pbox and sbox
				            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
				        },

				        encryptBlock: function (M, offset) {
				            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
				            M[offset] = res.left;
				            M[offset + 1] = res.right;
				        },

				        decryptBlock: function (M, offset) {
				            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
				            M[offset] = res.left;
				            M[offset + 1] = res.right;
				        },

				        blockSize: 64/32,

				        keySize: 128/32,

				        ivSize: 64/32
				    });

				    /**
				     * Shortcut functions to the cipher's object interface.
				     *
				     * @example
				     *
				     *     var ciphertext = CryptoJS.Blowfish.encrypt(message, key, cfg);
				     *     var plaintext  = CryptoJS.Blowfish.decrypt(ciphertext, key, cfg);
				     */
				    C.Blowfish = BlockCipher._createHelper(Blowfish);
				}());


				return CryptoJS.Blowfish;

			})); 
		} (blowfish$1));
		return blowfish$1.exports;
	}

	var cryptoJs = cryptoJs$1.exports;

	var hasRequiredCryptoJs;

	function requireCryptoJs () {
		if (hasRequiredCryptoJs) return cryptoJs$1.exports;
		hasRequiredCryptoJs = 1;
		(function (module, exports) {
	(function (root, factory, undef) {
				{
					// CommonJS
					module.exports = factory(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy(), requireBlowfish());
				}
			}(cryptoJs, function (CryptoJS) {

				return CryptoJS;

			})); 
		} (cryptoJs$1));
		return cryptoJs$1.exports;
	}

	var cryptoJsExports = requireCryptoJs();

	var src = {};

	var global$1 = (typeof global !== "undefined" ? global :
	  typeof self !== "undefined" ? self :
	  typeof window !== "undefined" ? window : {});

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance = global$1.performance || {};
	performance.now        ||
	  performance.mozNow     ||
	  performance.msNow      ||
	  performance.oNow       ||
	  performance.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	var browser$1 = {
	  };

	var createStream = {};

	var alignTableData = {};

	var alignString = {};

	var stringWidth$1 = {exports: {}};

	var ansiRegex$1;
	var hasRequiredAnsiRegex;

	function requireAnsiRegex () {
		if (hasRequiredAnsiRegex) return ansiRegex$1;
		hasRequiredAnsiRegex = 1;

		ansiRegex$1 = ({onlyFirst = false} = {}) => {
			const pattern = [
				'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
				'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
			].join('|');

			return new RegExp(pattern, onlyFirst ? undefined : 'g');
		};
		return ansiRegex$1;
	}

	var stripAnsi$1;
	var hasRequiredStripAnsi;

	function requireStripAnsi () {
		if (hasRequiredStripAnsi) return stripAnsi$1;
		hasRequiredStripAnsi = 1;
		const ansiRegex = requireAnsiRegex();

		stripAnsi$1 = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
		return stripAnsi$1;
	}

	var isFullwidthCodePoint = {exports: {}};

	/* eslint-disable yoda */

	var hasRequiredIsFullwidthCodePoint;

	function requireIsFullwidthCodePoint () {
		if (hasRequiredIsFullwidthCodePoint) return isFullwidthCodePoint.exports;
		hasRequiredIsFullwidthCodePoint = 1;

		const isFullwidthCodePoint$1 = codePoint => {
			if (Number.isNaN(codePoint)) {
				return false;
			}

			// Code points are derived from:
			// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
			if (
				codePoint >= 0x1100 && (
					codePoint <= 0x115F || // Hangul Jamo
					codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
					codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
					// CJK Radicals Supplement .. Enclosed CJK Letters and Months
					(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||
					// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
					(0x3250 <= codePoint && codePoint <= 0x4DBF) ||
					// CJK Unified Ideographs .. Yi Radicals
					(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||
					// Hangul Jamo Extended-A
					(0xA960 <= codePoint && codePoint <= 0xA97C) ||
					// Hangul Syllables
					(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||
					// CJK Compatibility Ideographs
					(0xF900 <= codePoint && codePoint <= 0xFAFF) ||
					// Vertical Forms
					(0xFE10 <= codePoint && codePoint <= 0xFE19) ||
					// CJK Compatibility Forms .. Small Form Variants
					(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||
					// Halfwidth and Fullwidth Forms
					(0xFF01 <= codePoint && codePoint <= 0xFF60) ||
					(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||
					// Kana Supplement
					(0x1B000 <= codePoint && codePoint <= 0x1B001) ||
					// Enclosed Ideographic Supplement
					(0x1F200 <= codePoint && codePoint <= 0x1F251) ||
					// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
					(0x20000 <= codePoint && codePoint <= 0x3FFFD)
				)
			) {
				return true;
			}

			return false;
		};

		isFullwidthCodePoint.exports = isFullwidthCodePoint$1;
		isFullwidthCodePoint.exports.default = isFullwidthCodePoint$1;
		return isFullwidthCodePoint.exports;
	}

	var emojiRegex;
	var hasRequiredEmojiRegex;

	function requireEmojiRegex () {
		if (hasRequiredEmojiRegex) return emojiRegex;
		hasRequiredEmojiRegex = 1;

		emojiRegex = function () {
		  // https://mths.be/emoji
		  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
		};
		return emojiRegex;
	}

	var hasRequiredStringWidth;

	function requireStringWidth () {
		if (hasRequiredStringWidth) return stringWidth$1.exports;
		hasRequiredStringWidth = 1;
		const stripAnsi = requireStripAnsi();
		const isFullwidthCodePoint = requireIsFullwidthCodePoint();
		const emojiRegex = requireEmojiRegex();

		const stringWidth = string => {
			if (typeof string !== 'string' || string.length === 0) {
				return 0;
			}

			string = stripAnsi(string);

			if (string.length === 0) {
				return 0;
			}

			string = string.replace(emojiRegex(), '  ');

			let width = 0;

			for (let i = 0; i < string.length; i++) {
				const code = string.codePointAt(i);

				// Ignore control characters
				if (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {
					continue;
				}

				// Ignore combining characters
				if (code >= 0x300 && code <= 0x36F) {
					continue;
				}

				// Surrogates
				if (code > 0xFFFF) {
					i++;
				}

				width += isFullwidthCodePoint(code) ? 2 : 1;
			}

			return width;
		};

		stringWidth$1.exports = stringWidth;
		// TODO: remove this in the next major version
		stringWidth$1.exports.default = stringWidth;
		return stringWidth$1.exports;
	}

	var utils = {};

	var astralRegex_1;
	var hasRequiredAstralRegex;

	function requireAstralRegex () {
		if (hasRequiredAstralRegex) return astralRegex_1;
		hasRequiredAstralRegex = 1;
		const regex = '[\uD800-\uDBFF][\uDC00-\uDFFF]';

		const astralRegex = options => options && options.exact ? new RegExp(`^${regex}$`) : new RegExp(regex, 'g');

		astralRegex_1 = astralRegex;
		return astralRegex_1;
	}

	var ansiStyles = {exports: {}};

	var colorName;
	var hasRequiredColorName;

	function requireColorName () {
		if (hasRequiredColorName) return colorName;
		hasRequiredColorName = 1;

		colorName = {
			"aliceblue": [240, 248, 255],
			"antiquewhite": [250, 235, 215],
			"aqua": [0, 255, 255],
			"aquamarine": [127, 255, 212],
			"azure": [240, 255, 255],
			"beige": [245, 245, 220],
			"bisque": [255, 228, 196],
			"black": [0, 0, 0],
			"blanchedalmond": [255, 235, 205],
			"blue": [0, 0, 255],
			"blueviolet": [138, 43, 226],
			"brown": [165, 42, 42],
			"burlywood": [222, 184, 135],
			"cadetblue": [95, 158, 160],
			"chartreuse": [127, 255, 0],
			"chocolate": [210, 105, 30],
			"coral": [255, 127, 80],
			"cornflowerblue": [100, 149, 237],
			"cornsilk": [255, 248, 220],
			"crimson": [220, 20, 60],
			"cyan": [0, 255, 255],
			"darkblue": [0, 0, 139],
			"darkcyan": [0, 139, 139],
			"darkgoldenrod": [184, 134, 11],
			"darkgray": [169, 169, 169],
			"darkgreen": [0, 100, 0],
			"darkgrey": [169, 169, 169],
			"darkkhaki": [189, 183, 107],
			"darkmagenta": [139, 0, 139],
			"darkolivegreen": [85, 107, 47],
			"darkorange": [255, 140, 0],
			"darkorchid": [153, 50, 204],
			"darkred": [139, 0, 0],
			"darksalmon": [233, 150, 122],
			"darkseagreen": [143, 188, 143],
			"darkslateblue": [72, 61, 139],
			"darkslategray": [47, 79, 79],
			"darkslategrey": [47, 79, 79],
			"darkturquoise": [0, 206, 209],
			"darkviolet": [148, 0, 211],
			"deeppink": [255, 20, 147],
			"deepskyblue": [0, 191, 255],
			"dimgray": [105, 105, 105],
			"dimgrey": [105, 105, 105],
			"dodgerblue": [30, 144, 255],
			"firebrick": [178, 34, 34],
			"floralwhite": [255, 250, 240],
			"forestgreen": [34, 139, 34],
			"fuchsia": [255, 0, 255],
			"gainsboro": [220, 220, 220],
			"ghostwhite": [248, 248, 255],
			"gold": [255, 215, 0],
			"goldenrod": [218, 165, 32],
			"gray": [128, 128, 128],
			"green": [0, 128, 0],
			"greenyellow": [173, 255, 47],
			"grey": [128, 128, 128],
			"honeydew": [240, 255, 240],
			"hotpink": [255, 105, 180],
			"indianred": [205, 92, 92],
			"indigo": [75, 0, 130],
			"ivory": [255, 255, 240],
			"khaki": [240, 230, 140],
			"lavender": [230, 230, 250],
			"lavenderblush": [255, 240, 245],
			"lawngreen": [124, 252, 0],
			"lemonchiffon": [255, 250, 205],
			"lightblue": [173, 216, 230],
			"lightcoral": [240, 128, 128],
			"lightcyan": [224, 255, 255],
			"lightgoldenrodyellow": [250, 250, 210],
			"lightgray": [211, 211, 211],
			"lightgreen": [144, 238, 144],
			"lightgrey": [211, 211, 211],
			"lightpink": [255, 182, 193],
			"lightsalmon": [255, 160, 122],
			"lightseagreen": [32, 178, 170],
			"lightskyblue": [135, 206, 250],
			"lightslategray": [119, 136, 153],
			"lightslategrey": [119, 136, 153],
			"lightsteelblue": [176, 196, 222],
			"lightyellow": [255, 255, 224],
			"lime": [0, 255, 0],
			"limegreen": [50, 205, 50],
			"linen": [250, 240, 230],
			"magenta": [255, 0, 255],
			"maroon": [128, 0, 0],
			"mediumaquamarine": [102, 205, 170],
			"mediumblue": [0, 0, 205],
			"mediumorchid": [186, 85, 211],
			"mediumpurple": [147, 112, 219],
			"mediumseagreen": [60, 179, 113],
			"mediumslateblue": [123, 104, 238],
			"mediumspringgreen": [0, 250, 154],
			"mediumturquoise": [72, 209, 204],
			"mediumvioletred": [199, 21, 133],
			"midnightblue": [25, 25, 112],
			"mintcream": [245, 255, 250],
			"mistyrose": [255, 228, 225],
			"moccasin": [255, 228, 181],
			"navajowhite": [255, 222, 173],
			"navy": [0, 0, 128],
			"oldlace": [253, 245, 230],
			"olive": [128, 128, 0],
			"olivedrab": [107, 142, 35],
			"orange": [255, 165, 0],
			"orangered": [255, 69, 0],
			"orchid": [218, 112, 214],
			"palegoldenrod": [238, 232, 170],
			"palegreen": [152, 251, 152],
			"paleturquoise": [175, 238, 238],
			"palevioletred": [219, 112, 147],
			"papayawhip": [255, 239, 213],
			"peachpuff": [255, 218, 185],
			"peru": [205, 133, 63],
			"pink": [255, 192, 203],
			"plum": [221, 160, 221],
			"powderblue": [176, 224, 230],
			"purple": [128, 0, 128],
			"rebeccapurple": [102, 51, 153],
			"red": [255, 0, 0],
			"rosybrown": [188, 143, 143],
			"royalblue": [65, 105, 225],
			"saddlebrown": [139, 69, 19],
			"salmon": [250, 128, 114],
			"sandybrown": [244, 164, 96],
			"seagreen": [46, 139, 87],
			"seashell": [255, 245, 238],
			"sienna": [160, 82, 45],
			"silver": [192, 192, 192],
			"skyblue": [135, 206, 235],
			"slateblue": [106, 90, 205],
			"slategray": [112, 128, 144],
			"slategrey": [112, 128, 144],
			"snow": [255, 250, 250],
			"springgreen": [0, 255, 127],
			"steelblue": [70, 130, 180],
			"tan": [210, 180, 140],
			"teal": [0, 128, 128],
			"thistle": [216, 191, 216],
			"tomato": [255, 99, 71],
			"turquoise": [64, 224, 208],
			"violet": [238, 130, 238],
			"wheat": [245, 222, 179],
			"white": [255, 255, 255],
			"whitesmoke": [245, 245, 245],
			"yellow": [255, 255, 0],
			"yellowgreen": [154, 205, 50]
		};
		return colorName;
	}

	/* MIT license */

	var conversions;
	var hasRequiredConversions;

	function requireConversions () {
		if (hasRequiredConversions) return conversions;
		hasRequiredConversions = 1;
		/* eslint-disable no-mixed-operators */
		const cssKeywords = requireColorName();

		// NOTE: conversions should only return primitive values (i.e. arrays, or
		//       values that give correct `typeof` results).
		//       do not use box values types (i.e. Number(), String(), etc.)

		const reverseKeywords = {};
		for (const key of Object.keys(cssKeywords)) {
			reverseKeywords[cssKeywords[key]] = key;
		}

		const convert = {
			rgb: {channels: 3, labels: 'rgb'},
			hsl: {channels: 3, labels: 'hsl'},
			hsv: {channels: 3, labels: 'hsv'},
			hwb: {channels: 3, labels: 'hwb'},
			cmyk: {channels: 4, labels: 'cmyk'},
			xyz: {channels: 3, labels: 'xyz'},
			lab: {channels: 3, labels: 'lab'},
			lch: {channels: 3, labels: 'lch'},
			hex: {channels: 1, labels: ['hex']},
			keyword: {channels: 1, labels: ['keyword']},
			ansi16: {channels: 1, labels: ['ansi16']},
			ansi256: {channels: 1, labels: ['ansi256']},
			hcg: {channels: 3, labels: ['h', 'c', 'g']},
			apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
			gray: {channels: 1, labels: ['gray']}
		};

		conversions = convert;

		// Hide .channels and .labels properties
		for (const model of Object.keys(convert)) {
			if (!('channels' in convert[model])) {
				throw new Error('missing channels property: ' + model);
			}

			if (!('labels' in convert[model])) {
				throw new Error('missing channel labels property: ' + model);
			}

			if (convert[model].labels.length !== convert[model].channels) {
				throw new Error('channel and label counts mismatch: ' + model);
			}

			const {channels, labels} = convert[model];
			delete convert[model].channels;
			delete convert[model].labels;
			Object.defineProperty(convert[model], 'channels', {value: channels});
			Object.defineProperty(convert[model], 'labels', {value: labels});
		}

		convert.rgb.hsl = function (rgb) {
			const r = rgb[0] / 255;
			const g = rgb[1] / 255;
			const b = rgb[2] / 255;
			const min = Math.min(r, g, b);
			const max = Math.max(r, g, b);
			const delta = max - min;
			let h;
			let s;

			if (max === min) {
				h = 0;
			} else if (r === max) {
				h = (g - b) / delta;
			} else if (g === max) {
				h = 2 + (b - r) / delta;
			} else if (b === max) {
				h = 4 + (r - g) / delta;
			}

			h = Math.min(h * 60, 360);

			if (h < 0) {
				h += 360;
			}

			const l = (min + max) / 2;

			if (max === min) {
				s = 0;
			} else if (l <= 0.5) {
				s = delta / (max + min);
			} else {
				s = delta / (2 - max - min);
			}

			return [h, s * 100, l * 100];
		};

		convert.rgb.hsv = function (rgb) {
			let rdif;
			let gdif;
			let bdif;
			let h;
			let s;

			const r = rgb[0] / 255;
			const g = rgb[1] / 255;
			const b = rgb[2] / 255;
			const v = Math.max(r, g, b);
			const diff = v - Math.min(r, g, b);
			const diffc = function (c) {
				return (v - c) / 6 / diff + 1 / 2;
			};

			if (diff === 0) {
				h = 0;
				s = 0;
			} else {
				s = diff / v;
				rdif = diffc(r);
				gdif = diffc(g);
				bdif = diffc(b);

				if (r === v) {
					h = bdif - gdif;
				} else if (g === v) {
					h = (1 / 3) + rdif - bdif;
				} else if (b === v) {
					h = (2 / 3) + gdif - rdif;
				}

				if (h < 0) {
					h += 1;
				} else if (h > 1) {
					h -= 1;
				}
			}

			return [
				h * 360,
				s * 100,
				v * 100
			];
		};

		convert.rgb.hwb = function (rgb) {
			const r = rgb[0];
			const g = rgb[1];
			let b = rgb[2];
			const h = convert.rgb.hsl(rgb)[0];
			const w = 1 / 255 * Math.min(r, Math.min(g, b));

			b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

			return [h, w * 100, b * 100];
		};

		convert.rgb.cmyk = function (rgb) {
			const r = rgb[0] / 255;
			const g = rgb[1] / 255;
			const b = rgb[2] / 255;

			const k = Math.min(1 - r, 1 - g, 1 - b);
			const c = (1 - r - k) / (1 - k) || 0;
			const m = (1 - g - k) / (1 - k) || 0;
			const y = (1 - b - k) / (1 - k) || 0;

			return [c * 100, m * 100, y * 100, k * 100];
		};

		function comparativeDistance(x, y) {
			/*
				See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
			*/
			return (
				((x[0] - y[0]) ** 2) +
				((x[1] - y[1]) ** 2) +
				((x[2] - y[2]) ** 2)
			);
		}

		convert.rgb.keyword = function (rgb) {
			const reversed = reverseKeywords[rgb];
			if (reversed) {
				return reversed;
			}

			let currentClosestDistance = Infinity;
			let currentClosestKeyword;

			for (const keyword of Object.keys(cssKeywords)) {
				const value = cssKeywords[keyword];

				// Compute comparative distance
				const distance = comparativeDistance(rgb, value);

				// Check if its less, if so set as closest
				if (distance < currentClosestDistance) {
					currentClosestDistance = distance;
					currentClosestKeyword = keyword;
				}
			}

			return currentClosestKeyword;
		};

		convert.keyword.rgb = function (keyword) {
			return cssKeywords[keyword];
		};

		convert.rgb.xyz = function (rgb) {
			let r = rgb[0] / 255;
			let g = rgb[1] / 255;
			let b = rgb[2] / 255;

			// Assume sRGB
			r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
			g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
			b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

			const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
			const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
			const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

			return [x * 100, y * 100, z * 100];
		};

		convert.rgb.lab = function (rgb) {
			const xyz = convert.rgb.xyz(rgb);
			let x = xyz[0];
			let y = xyz[1];
			let z = xyz[2];

			x /= 95.047;
			y /= 100;
			z /= 108.883;

			x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
			y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
			z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

			const l = (116 * y) - 16;
			const a = 500 * (x - y);
			const b = 200 * (y - z);

			return [l, a, b];
		};

		convert.hsl.rgb = function (hsl) {
			const h = hsl[0] / 360;
			const s = hsl[1] / 100;
			const l = hsl[2] / 100;
			let t2;
			let t3;
			let val;

			if (s === 0) {
				val = l * 255;
				return [val, val, val];
			}

			if (l < 0.5) {
				t2 = l * (1 + s);
			} else {
				t2 = l + s - l * s;
			}

			const t1 = 2 * l - t2;

			const rgb = [0, 0, 0];
			for (let i = 0; i < 3; i++) {
				t3 = h + 1 / 3 * -(i - 1);
				if (t3 < 0) {
					t3++;
				}

				if (t3 > 1) {
					t3--;
				}

				if (6 * t3 < 1) {
					val = t1 + (t2 - t1) * 6 * t3;
				} else if (2 * t3 < 1) {
					val = t2;
				} else if (3 * t3 < 2) {
					val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
				} else {
					val = t1;
				}

				rgb[i] = val * 255;
			}

			return rgb;
		};

		convert.hsl.hsv = function (hsl) {
			const h = hsl[0];
			let s = hsl[1] / 100;
			let l = hsl[2] / 100;
			let smin = s;
			const lmin = Math.max(l, 0.01);

			l *= 2;
			s *= (l <= 1) ? l : 2 - l;
			smin *= lmin <= 1 ? lmin : 2 - lmin;
			const v = (l + s) / 2;
			const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

			return [h, sv * 100, v * 100];
		};

		convert.hsv.rgb = function (hsv) {
			const h = hsv[0] / 60;
			const s = hsv[1] / 100;
			let v = hsv[2] / 100;
			const hi = Math.floor(h) % 6;

			const f = h - Math.floor(h);
			const p = 255 * v * (1 - s);
			const q = 255 * v * (1 - (s * f));
			const t = 255 * v * (1 - (s * (1 - f)));
			v *= 255;

			switch (hi) {
				case 0:
					return [v, t, p];
				case 1:
					return [q, v, p];
				case 2:
					return [p, v, t];
				case 3:
					return [p, q, v];
				case 4:
					return [t, p, v];
				case 5:
					return [v, p, q];
			}
		};

		convert.hsv.hsl = function (hsv) {
			const h = hsv[0];
			const s = hsv[1] / 100;
			const v = hsv[2] / 100;
			const vmin = Math.max(v, 0.01);
			let sl;
			let l;

			l = (2 - s) * v;
			const lmin = (2 - s) * vmin;
			sl = s * vmin;
			sl /= (lmin <= 1) ? lmin : 2 - lmin;
			sl = sl || 0;
			l /= 2;

			return [h, sl * 100, l * 100];
		};

		// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
		convert.hwb.rgb = function (hwb) {
			const h = hwb[0] / 360;
			let wh = hwb[1] / 100;
			let bl = hwb[2] / 100;
			const ratio = wh + bl;
			let f;

			// Wh + bl cant be > 1
			if (ratio > 1) {
				wh /= ratio;
				bl /= ratio;
			}

			const i = Math.floor(6 * h);
			const v = 1 - bl;
			f = 6 * h - i;

			if ((i & 0x01) !== 0) {
				f = 1 - f;
			}

			const n = wh + f * (v - wh); // Linear interpolation

			let r;
			let g;
			let b;
			/* eslint-disable max-statements-per-line,no-multi-spaces */
			switch (i) {
				default:
				case 6:
				case 0: r = v;  g = n;  b = wh; break;
				case 1: r = n;  g = v;  b = wh; break;
				case 2: r = wh; g = v;  b = n; break;
				case 3: r = wh; g = n;  b = v; break;
				case 4: r = n;  g = wh; b = v; break;
				case 5: r = v;  g = wh; b = n; break;
			}
			/* eslint-enable max-statements-per-line,no-multi-spaces */

			return [r * 255, g * 255, b * 255];
		};

		convert.cmyk.rgb = function (cmyk) {
			const c = cmyk[0] / 100;
			const m = cmyk[1] / 100;
			const y = cmyk[2] / 100;
			const k = cmyk[3] / 100;

			const r = 1 - Math.min(1, c * (1 - k) + k);
			const g = 1 - Math.min(1, m * (1 - k) + k);
			const b = 1 - Math.min(1, y * (1 - k) + k);

			return [r * 255, g * 255, b * 255];
		};

		convert.xyz.rgb = function (xyz) {
			const x = xyz[0] / 100;
			const y = xyz[1] / 100;
			const z = xyz[2] / 100;
			let r;
			let g;
			let b;

			r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
			g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
			b = (x * 0.0557) + (y * -0.204) + (z * 1.0570);

			// Assume sRGB
			r = r > 0.0031308
				? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
				: r * 12.92;

			g = g > 0.0031308
				? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
				: g * 12.92;

			b = b > 0.0031308
				? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
				: b * 12.92;

			r = Math.min(Math.max(0, r), 1);
			g = Math.min(Math.max(0, g), 1);
			b = Math.min(Math.max(0, b), 1);

			return [r * 255, g * 255, b * 255];
		};

		convert.xyz.lab = function (xyz) {
			let x = xyz[0];
			let y = xyz[1];
			let z = xyz[2];

			x /= 95.047;
			y /= 100;
			z /= 108.883;

			x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
			y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
			z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

			const l = (116 * y) - 16;
			const a = 500 * (x - y);
			const b = 200 * (y - z);

			return [l, a, b];
		};

		convert.lab.xyz = function (lab) {
			const l = lab[0];
			const a = lab[1];
			const b = lab[2];
			let x;
			let y;
			let z;

			y = (l + 16) / 116;
			x = a / 500 + y;
			z = y - b / 200;

			const y2 = y ** 3;
			const x2 = x ** 3;
			const z2 = z ** 3;
			y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
			x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
			z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

			x *= 95.047;
			y *= 100;
			z *= 108.883;

			return [x, y, z];
		};

		convert.lab.lch = function (lab) {
			const l = lab[0];
			const a = lab[1];
			const b = lab[2];
			let h;

			const hr = Math.atan2(b, a);
			h = hr * 360 / 2 / Math.PI;

			if (h < 0) {
				h += 360;
			}

			const c = Math.sqrt(a * a + b * b);

			return [l, c, h];
		};

		convert.lch.lab = function (lch) {
			const l = lch[0];
			const c = lch[1];
			const h = lch[2];

			const hr = h / 360 * 2 * Math.PI;
			const a = c * Math.cos(hr);
			const b = c * Math.sin(hr);

			return [l, a, b];
		};

		convert.rgb.ansi16 = function (args, saturation = null) {
			const [r, g, b] = args;
			let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

			value = Math.round(value / 50);

			if (value === 0) {
				return 30;
			}

			let ansi = 30
				+ ((Math.round(b / 255) << 2)
				| (Math.round(g / 255) << 1)
				| Math.round(r / 255));

			if (value === 2) {
				ansi += 60;
			}

			return ansi;
		};

		convert.hsv.ansi16 = function (args) {
			// Optimization here; we already know the value and don't need to get
			// it converted for us.
			return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
		};

		convert.rgb.ansi256 = function (args) {
			const r = args[0];
			const g = args[1];
			const b = args[2];

			// We use the extended greyscale palette here, with the exception of
			// black and white. normal palette only has 4 greyscale shades.
			if (r === g && g === b) {
				if (r < 8) {
					return 16;
				}

				if (r > 248) {
					return 231;
				}

				return Math.round(((r - 8) / 247) * 24) + 232;
			}

			const ansi = 16
				+ (36 * Math.round(r / 255 * 5))
				+ (6 * Math.round(g / 255 * 5))
				+ Math.round(b / 255 * 5);

			return ansi;
		};

		convert.ansi16.rgb = function (args) {
			let color = args % 10;

			// Handle greyscale
			if (color === 0 || color === 7) {
				if (args > 50) {
					color += 3.5;
				}

				color = color / 10.5 * 255;

				return [color, color, color];
			}

			const mult = (~~(args > 50) + 1) * 0.5;
			const r = ((color & 1) * mult) * 255;
			const g = (((color >> 1) & 1) * mult) * 255;
			const b = (((color >> 2) & 1) * mult) * 255;

			return [r, g, b];
		};

		convert.ansi256.rgb = function (args) {
			// Handle greyscale
			if (args >= 232) {
				const c = (args - 232) * 10 + 8;
				return [c, c, c];
			}

			args -= 16;

			let rem;
			const r = Math.floor(args / 36) / 5 * 255;
			const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
			const b = (rem % 6) / 5 * 255;

			return [r, g, b];
		};

		convert.rgb.hex = function (args) {
			const integer = ((Math.round(args[0]) & 0xFF) << 16)
				+ ((Math.round(args[1]) & 0xFF) << 8)
				+ (Math.round(args[2]) & 0xFF);

			const string = integer.toString(16).toUpperCase();
			return '000000'.substring(string.length) + string;
		};

		convert.hex.rgb = function (args) {
			const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
			if (!match) {
				return [0, 0, 0];
			}

			let colorString = match[0];

			if (match[0].length === 3) {
				colorString = colorString.split('').map(char => {
					return char + char;
				}).join('');
			}

			const integer = parseInt(colorString, 16);
			const r = (integer >> 16) & 0xFF;
			const g = (integer >> 8) & 0xFF;
			const b = integer & 0xFF;

			return [r, g, b];
		};

		convert.rgb.hcg = function (rgb) {
			const r = rgb[0] / 255;
			const g = rgb[1] / 255;
			const b = rgb[2] / 255;
			const max = Math.max(Math.max(r, g), b);
			const min = Math.min(Math.min(r, g), b);
			const chroma = (max - min);
			let grayscale;
			let hue;

			if (chroma < 1) {
				grayscale = min / (1 - chroma);
			} else {
				grayscale = 0;
			}

			if (chroma <= 0) {
				hue = 0;
			} else
			if (max === r) {
				hue = ((g - b) / chroma) % 6;
			} else
			if (max === g) {
				hue = 2 + (b - r) / chroma;
			} else {
				hue = 4 + (r - g) / chroma;
			}

			hue /= 6;
			hue %= 1;

			return [hue * 360, chroma * 100, grayscale * 100];
		};

		convert.hsl.hcg = function (hsl) {
			const s = hsl[1] / 100;
			const l = hsl[2] / 100;

			const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

			let f = 0;
			if (c < 1.0) {
				f = (l - 0.5 * c) / (1.0 - c);
			}

			return [hsl[0], c * 100, f * 100];
		};

		convert.hsv.hcg = function (hsv) {
			const s = hsv[1] / 100;
			const v = hsv[2] / 100;

			const c = s * v;
			let f = 0;

			if (c < 1.0) {
				f = (v - c) / (1 - c);
			}

			return [hsv[0], c * 100, f * 100];
		};

		convert.hcg.rgb = function (hcg) {
			const h = hcg[0] / 360;
			const c = hcg[1] / 100;
			const g = hcg[2] / 100;

			if (c === 0.0) {
				return [g * 255, g * 255, g * 255];
			}

			const pure = [0, 0, 0];
			const hi = (h % 1) * 6;
			const v = hi % 1;
			const w = 1 - v;
			let mg = 0;

			/* eslint-disable max-statements-per-line */
			switch (Math.floor(hi)) {
				case 0:
					pure[0] = 1; pure[1] = v; pure[2] = 0; break;
				case 1:
					pure[0] = w; pure[1] = 1; pure[2] = 0; break;
				case 2:
					pure[0] = 0; pure[1] = 1; pure[2] = v; break;
				case 3:
					pure[0] = 0; pure[1] = w; pure[2] = 1; break;
				case 4:
					pure[0] = v; pure[1] = 0; pure[2] = 1; break;
				default:
					pure[0] = 1; pure[1] = 0; pure[2] = w;
			}
			/* eslint-enable max-statements-per-line */

			mg = (1.0 - c) * g;

			return [
				(c * pure[0] + mg) * 255,
				(c * pure[1] + mg) * 255,
				(c * pure[2] + mg) * 255
			];
		};

		convert.hcg.hsv = function (hcg) {
			const c = hcg[1] / 100;
			const g = hcg[2] / 100;

			const v = c + g * (1.0 - c);
			let f = 0;

			if (v > 0.0) {
				f = c / v;
			}

			return [hcg[0], f * 100, v * 100];
		};

		convert.hcg.hsl = function (hcg) {
			const c = hcg[1] / 100;
			const g = hcg[2] / 100;

			const l = g * (1.0 - c) + 0.5 * c;
			let s = 0;

			if (l > 0.0 && l < 0.5) {
				s = c / (2 * l);
			} else
			if (l >= 0.5 && l < 1.0) {
				s = c / (2 * (1 - l));
			}

			return [hcg[0], s * 100, l * 100];
		};

		convert.hcg.hwb = function (hcg) {
			const c = hcg[1] / 100;
			const g = hcg[2] / 100;
			const v = c + g * (1.0 - c);
			return [hcg[0], (v - c) * 100, (1 - v) * 100];
		};

		convert.hwb.hcg = function (hwb) {
			const w = hwb[1] / 100;
			const b = hwb[2] / 100;
			const v = 1 - b;
			const c = v - w;
			let g = 0;

			if (c < 1) {
				g = (v - c) / (1 - c);
			}

			return [hwb[0], c * 100, g * 100];
		};

		convert.apple.rgb = function (apple) {
			return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
		};

		convert.rgb.apple = function (rgb) {
			return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
		};

		convert.gray.rgb = function (args) {
			return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
		};

		convert.gray.hsl = function (args) {
			return [0, 0, args[0]];
		};

		convert.gray.hsv = convert.gray.hsl;

		convert.gray.hwb = function (gray) {
			return [0, 100, gray[0]];
		};

		convert.gray.cmyk = function (gray) {
			return [0, 0, 0, gray[0]];
		};

		convert.gray.lab = function (gray) {
			return [gray[0], 0, 0];
		};

		convert.gray.hex = function (gray) {
			const val = Math.round(gray[0] / 100 * 255) & 0xFF;
			const integer = (val << 16) + (val << 8) + val;

			const string = integer.toString(16).toUpperCase();
			return '000000'.substring(string.length) + string;
		};

		convert.rgb.gray = function (rgb) {
			const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
			return [val / 255 * 100];
		};
		return conversions;
	}

	var route;
	var hasRequiredRoute;

	function requireRoute () {
		if (hasRequiredRoute) return route;
		hasRequiredRoute = 1;
		const conversions = requireConversions();

		/*
			This function routes a model to all other models.

			all functions that are routed have a property `.conversion` attached
			to the returned synthetic function. This property is an array
			of strings, each with the steps in between the 'from' and 'to'
			color models (inclusive).

			conversions that are not possible simply are not included.
		*/

		function buildGraph() {
			const graph = {};
			// https://jsperf.com/object-keys-vs-for-in-with-closure/3
			const models = Object.keys(conversions);

			for (let len = models.length, i = 0; i < len; i++) {
				graph[models[i]] = {
					// http://jsperf.com/1-vs-infinity
					// micro-opt, but this is simple.
					distance: -1,
					parent: null
				};
			}

			return graph;
		}

		// https://en.wikipedia.org/wiki/Breadth-first_search
		function deriveBFS(fromModel) {
			const graph = buildGraph();
			const queue = [fromModel]; // Unshift -> queue -> pop

			graph[fromModel].distance = 0;

			while (queue.length) {
				const current = queue.pop();
				const adjacents = Object.keys(conversions[current]);

				for (let len = adjacents.length, i = 0; i < len; i++) {
					const adjacent = adjacents[i];
					const node = graph[adjacent];

					if (node.distance === -1) {
						node.distance = graph[current].distance + 1;
						node.parent = current;
						queue.unshift(adjacent);
					}
				}
			}

			return graph;
		}

		function link(from, to) {
			return function (args) {
				return to(from(args));
			};
		}

		function wrapConversion(toModel, graph) {
			const path = [graph[toModel].parent, toModel];
			let fn = conversions[graph[toModel].parent][toModel];

			let cur = graph[toModel].parent;
			while (graph[cur].parent) {
				path.unshift(graph[cur].parent);
				fn = link(conversions[graph[cur].parent][cur], fn);
				cur = graph[cur].parent;
			}

			fn.conversion = path;
			return fn;
		}

		route = function (fromModel) {
			const graph = deriveBFS(fromModel);
			const conversion = {};

			const models = Object.keys(graph);
			for (let len = models.length, i = 0; i < len; i++) {
				const toModel = models[i];
				const node = graph[toModel];

				if (node.parent === null) {
					// No possible conversion, or this node is the source model.
					continue;
				}

				conversion[toModel] = wrapConversion(toModel, graph);
			}

			return conversion;
		};
		return route;
	}

	var colorConvert;
	var hasRequiredColorConvert;

	function requireColorConvert () {
		if (hasRequiredColorConvert) return colorConvert;
		hasRequiredColorConvert = 1;
		const conversions = requireConversions();
		const route = requireRoute();

		const convert = {};

		const models = Object.keys(conversions);

		function wrapRaw(fn) {
			const wrappedFn = function (...args) {
				const arg0 = args[0];
				if (arg0 === undefined || arg0 === null) {
					return arg0;
				}

				if (arg0.length > 1) {
					args = arg0;
				}

				return fn(args);
			};

			// Preserve .conversion property if there is one
			if ('conversion' in fn) {
				wrappedFn.conversion = fn.conversion;
			}

			return wrappedFn;
		}

		function wrapRounded(fn) {
			const wrappedFn = function (...args) {
				const arg0 = args[0];

				if (arg0 === undefined || arg0 === null) {
					return arg0;
				}

				if (arg0.length > 1) {
					args = arg0;
				}

				const result = fn(args);

				// We're assuming the result is an array here.
				// see notice in conversions.js; don't use box types
				// in conversion functions.
				if (typeof result === 'object') {
					for (let len = result.length, i = 0; i < len; i++) {
						result[i] = Math.round(result[i]);
					}
				}

				return result;
			};

			// Preserve .conversion property if there is one
			if ('conversion' in fn) {
				wrappedFn.conversion = fn.conversion;
			}

			return wrappedFn;
		}

		models.forEach(fromModel => {
			convert[fromModel] = {};

			Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
			Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

			const routes = route(fromModel);
			const routeModels = Object.keys(routes);

			routeModels.forEach(toModel => {
				const fn = routes[toModel];

				convert[fromModel][toModel] = wrapRounded(fn);
				convert[fromModel][toModel].raw = wrapRaw(fn);
			});
		});

		colorConvert = convert;
		return colorConvert;
	}

	ansiStyles.exports;

	var hasRequiredAnsiStyles;

	function requireAnsiStyles () {
		if (hasRequiredAnsiStyles) return ansiStyles.exports;
		hasRequiredAnsiStyles = 1;
		(function (module) {

			const wrapAnsi16 = (fn, offset) => (...args) => {
				const code = fn(...args);
				return `\u001B[${code + offset}m`;
			};

			const wrapAnsi256 = (fn, offset) => (...args) => {
				const code = fn(...args);
				return `\u001B[${38 + offset};5;${code}m`;
			};

			const wrapAnsi16m = (fn, offset) => (...args) => {
				const rgb = fn(...args);
				return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
			};

			const ansi2ansi = n => n;
			const rgb2rgb = (r, g, b) => [r, g, b];

			const setLazyProperty = (object, property, get) => {
				Object.defineProperty(object, property, {
					get: () => {
						const value = get();

						Object.defineProperty(object, property, {
							value,
							enumerable: true,
							configurable: true
						});

						return value;
					},
					enumerable: true,
					configurable: true
				});
			};

			/** @type {typeof import('color-convert')} */
			let colorConvert;
			const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
				if (colorConvert === undefined) {
					colorConvert = requireColorConvert();
				}

				const offset = isBackground ? 10 : 0;
				const styles = {};

				for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
					const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
					if (sourceSpace === targetSpace) {
						styles[name] = wrap(identity, offset);
					} else if (typeof suite === 'object') {
						styles[name] = wrap(suite[targetSpace], offset);
					}
				}

				return styles;
			};

			function assembleStyles() {
				const codes = new Map();
				const styles = {
					modifier: {
						reset: [0, 0],
						// 21 isn't widely supported and 22 does the same thing
						bold: [1, 22],
						dim: [2, 22],
						italic: [3, 23],
						underline: [4, 24],
						inverse: [7, 27],
						hidden: [8, 28],
						strikethrough: [9, 29]
					},
					color: {
						black: [30, 39],
						red: [31, 39],
						green: [32, 39],
						yellow: [33, 39],
						blue: [34, 39],
						magenta: [35, 39],
						cyan: [36, 39],
						white: [37, 39],

						// Bright color
						blackBright: [90, 39],
						redBright: [91, 39],
						greenBright: [92, 39],
						yellowBright: [93, 39],
						blueBright: [94, 39],
						magentaBright: [95, 39],
						cyanBright: [96, 39],
						whiteBright: [97, 39]
					},
					bgColor: {
						bgBlack: [40, 49],
						bgRed: [41, 49],
						bgGreen: [42, 49],
						bgYellow: [43, 49],
						bgBlue: [44, 49],
						bgMagenta: [45, 49],
						bgCyan: [46, 49],
						bgWhite: [47, 49],

						// Bright color
						bgBlackBright: [100, 49],
						bgRedBright: [101, 49],
						bgGreenBright: [102, 49],
						bgYellowBright: [103, 49],
						bgBlueBright: [104, 49],
						bgMagentaBright: [105, 49],
						bgCyanBright: [106, 49],
						bgWhiteBright: [107, 49]
					}
				};

				// Alias bright black as gray (and grey)
				styles.color.gray = styles.color.blackBright;
				styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
				styles.color.grey = styles.color.blackBright;
				styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

				for (const [groupName, group] of Object.entries(styles)) {
					for (const [styleName, style] of Object.entries(group)) {
						styles[styleName] = {
							open: `\u001B[${style[0]}m`,
							close: `\u001B[${style[1]}m`
						};

						group[styleName] = styles[styleName];

						codes.set(style[0], style[1]);
					}

					Object.defineProperty(styles, groupName, {
						value: group,
						enumerable: false
					});
				}

				Object.defineProperty(styles, 'codes', {
					value: codes,
					enumerable: false
				});

				styles.color.close = '\u001B[39m';
				styles.bgColor.close = '\u001B[49m';

				setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
				setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
				setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
				setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
				setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
				setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

				return styles;
			}

			// Make the export immutable
			Object.defineProperty(module, 'exports', {
				enumerable: true,
				get: assembleStyles
			}); 
		} (ansiStyles));
		return ansiStyles.exports;
	}

	var sliceAnsi;
	var hasRequiredSliceAnsi;

	function requireSliceAnsi () {
		if (hasRequiredSliceAnsi) return sliceAnsi;
		hasRequiredSliceAnsi = 1;
		const isFullwidthCodePoint = requireIsFullwidthCodePoint();
		const astralRegex = requireAstralRegex();
		const ansiStyles = requireAnsiStyles();

		const ESCAPES = [
			'\u001B',
			'\u009B'
		];

		const wrapAnsi = code => `${ESCAPES[0]}[${code}m`;

		const checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {
			let output = [];
			ansiCodes = [...ansiCodes];

			for (let ansiCode of ansiCodes) {
				const ansiCodeOrigin = ansiCode;
				if (ansiCode.includes(';')) {
					ansiCode = ansiCode.split(';')[0][0] + '0';
				}

				const item = ansiStyles.codes.get(Number.parseInt(ansiCode, 10));
				if (item) {
					const indexEscape = ansiCodes.indexOf(item.toString());
					if (indexEscape === -1) {
						output.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));
					} else {
						ansiCodes.splice(indexEscape, 1);
					}
				} else if (isEscapes) {
					output.push(wrapAnsi(0));
					break;
				} else {
					output.push(wrapAnsi(ansiCodeOrigin));
				}
			}

			if (isEscapes) {
				output = output.filter((element, index) => output.indexOf(element) === index);

				if (endAnsiCode !== undefined) {
					const fistEscapeCode = wrapAnsi(ansiStyles.codes.get(Number.parseInt(endAnsiCode, 10)));
					output = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);
				}
			}

			return output.join('');
		};

		sliceAnsi = (string, begin, end) => {
			const characters = [...string];
			const ansiCodes = [];

			let stringEnd = typeof end === 'number' ? end : characters.length;
			let isInsideEscape = false;
			let ansiCode;
			let visible = 0;
			let output = '';

			for (const [index, character] of characters.entries()) {
				let leftEscape = false;

				if (ESCAPES.includes(character)) {
					const code = /\d[^m]*/.exec(string.slice(index, index + 18));
					ansiCode = code && code.length > 0 ? code[0] : undefined;

					if (visible < stringEnd) {
						isInsideEscape = true;

						if (ansiCode !== undefined) {
							ansiCodes.push(ansiCode);
						}
					}
				} else if (isInsideEscape && character === 'm') {
					isInsideEscape = false;
					leftEscape = true;
				}

				if (!isInsideEscape && !leftEscape) {
					visible++;
				}

				if (!astralRegex({exact: true}).test(character) && isFullwidthCodePoint(character.codePointAt())) {
					visible++;

					if (typeof end !== 'number') {
						stringEnd++;
					}
				}

				if (visible > begin && visible <= stringEnd) {
					output += character;
				} else if (visible === begin && !isInsideEscape && ansiCode !== undefined) {
					output = checkAnsi(ansiCodes);
				} else if (visible >= stringEnd) {
					output += checkAnsi(ansiCodes, true, ansiCode);
					break;
				}
			}

			return output;
		};
		return sliceAnsi;
	}

	var getBorderCharacters = {};

	var hasRequiredGetBorderCharacters;

	function requireGetBorderCharacters () {
		if (hasRequiredGetBorderCharacters) return getBorderCharacters;
		hasRequiredGetBorderCharacters = 1;
		/* eslint-disable sort-keys-fix/sort-keys-fix */
		Object.defineProperty(getBorderCharacters, "__esModule", { value: true });
		getBorderCharacters.getBorderCharacters = void 0;
		const getBorderCharacters$1 = (name) => {
		    if (name === 'honeywell') {
		        return {
		            topBody: '═',
		            topJoin: '╤',
		            topLeft: '╔',
		            topRight: '╗',
		            bottomBody: '═',
		            bottomJoin: '╧',
		            bottomLeft: '╚',
		            bottomRight: '╝',
		            bodyLeft: '║',
		            bodyRight: '║',
		            bodyJoin: '│',
		            headerJoin: '┬',
		            joinBody: '─',
		            joinLeft: '╟',
		            joinRight: '╢',
		            joinJoin: '┼',
		            joinMiddleDown: '┬',
		            joinMiddleUp: '┴',
		            joinMiddleLeft: '┤',
		            joinMiddleRight: '├',
		        };
		    }
		    if (name === 'norc') {
		        return {
		            topBody: '─',
		            topJoin: '┬',
		            topLeft: '┌',
		            topRight: '┐',
		            bottomBody: '─',
		            bottomJoin: '┴',
		            bottomLeft: '└',
		            bottomRight: '┘',
		            bodyLeft: '│',
		            bodyRight: '│',
		            bodyJoin: '│',
		            headerJoin: '┬',
		            joinBody: '─',
		            joinLeft: '├',
		            joinRight: '┤',
		            joinJoin: '┼',
		            joinMiddleDown: '┬',
		            joinMiddleUp: '┴',
		            joinMiddleLeft: '┤',
		            joinMiddleRight: '├',
		        };
		    }
		    if (name === 'ramac') {
		        return {
		            topBody: '-',
		            topJoin: '+',
		            topLeft: '+',
		            topRight: '+',
		            bottomBody: '-',
		            bottomJoin: '+',
		            bottomLeft: '+',
		            bottomRight: '+',
		            bodyLeft: '|',
		            bodyRight: '|',
		            bodyJoin: '|',
		            headerJoin: '+',
		            joinBody: '-',
		            joinLeft: '|',
		            joinRight: '|',
		            joinJoin: '|',
		            joinMiddleDown: '+',
		            joinMiddleUp: '+',
		            joinMiddleLeft: '+',
		            joinMiddleRight: '+',
		        };
		    }
		    if (name === 'void') {
		        return {
		            topBody: '',
		            topJoin: '',
		            topLeft: '',
		            topRight: '',
		            bottomBody: '',
		            bottomJoin: '',
		            bottomLeft: '',
		            bottomRight: '',
		            bodyLeft: '',
		            bodyRight: '',
		            bodyJoin: '',
		            headerJoin: '',
		            joinBody: '',
		            joinLeft: '',
		            joinRight: '',
		            joinJoin: '',
		            joinMiddleDown: '',
		            joinMiddleUp: '',
		            joinMiddleLeft: '',
		            joinMiddleRight: '',
		        };
		    }
		    throw new Error('Unknown border template "' + name + '".');
		};
		getBorderCharacters.getBorderCharacters = getBorderCharacters$1;
		
		return getBorderCharacters;
	}

	var hasRequiredUtils;

	function requireUtils () {
		if (hasRequiredUtils) return utils;
		hasRequiredUtils = 1;
		var __importDefault = (utils && utils.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(utils, "__esModule", { value: true });
		utils.isCellInRange = utils.areCellEqual = utils.calculateRangeCoordinate = utils.flatten = utils.extractTruncates = utils.sumArray = utils.sequence = utils.distributeUnevenly = utils.countSpaceSequence = utils.groupBySizes = utils.makeBorderConfig = utils.splitAnsi = utils.normalizeString = void 0;
		const slice_ansi_1 = __importDefault(requireSliceAnsi());
		const string_width_1 = __importDefault(requireStringWidth());
		const strip_ansi_1 = __importDefault(requireStripAnsi());
		const getBorderCharacters_1 = /*@__PURE__*/ requireGetBorderCharacters();
		/**
		 * Converts Windows-style newline to Unix-style
		 *
		 * @internal
		 */
		const normalizeString = (input) => {
		    return input.replace(/\r\n/g, '\n');
		};
		utils.normalizeString = normalizeString;
		/**
		 * Splits ansi string by newlines
		 *
		 * @internal
		 */
		const splitAnsi = (input) => {
		    const lengths = (0, strip_ansi_1.default)(input).split('\n').map(string_width_1.default);
		    const result = [];
		    let startIndex = 0;
		    lengths.forEach((length) => {
		        result.push(length === 0 ? '' : (0, slice_ansi_1.default)(input, startIndex, startIndex + length));
		        // Plus 1 for the newline character itself
		        startIndex += length + 1;
		    });
		    return result;
		};
		utils.splitAnsi = splitAnsi;
		/**
		 * Merges user provided border characters with the default border ("honeywell") characters.
		 *
		 * @internal
		 */
		const makeBorderConfig = (border) => {
		    return {
		        ...(0, getBorderCharacters_1.getBorderCharacters)('honeywell'),
		        ...border,
		    };
		};
		utils.makeBorderConfig = makeBorderConfig;
		/**
		 * Groups the array into sub-arrays by sizes.
		 *
		 * @internal
		 * @example
		 * groupBySizes(['a', 'b', 'c', 'd', 'e'], [2, 1, 2]) = [ ['a', 'b'], ['c'], ['d', 'e'] ]
		 */
		const groupBySizes = (array, sizes) => {
		    let startIndex = 0;
		    return sizes.map((size) => {
		        const group = array.slice(startIndex, startIndex + size);
		        startIndex += size;
		        return group;
		    });
		};
		utils.groupBySizes = groupBySizes;
		/**
		 * Counts the number of continuous spaces in a string
		 *
		 * @internal
		 * @example
		 * countGroupSpaces('a  bc  de f') = 3
		 */
		const countSpaceSequence = (input) => {
		    var _a, _b;
		    return (_b = (_a = input.match(/\s+/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
		};
		utils.countSpaceSequence = countSpaceSequence;
		/**
		 * Creates the non-increasing number array given sum and length
		 * whose the difference between maximum and minimum is not greater than 1
		 *
		 * @internal
		 * @example
		 * distributeUnevenly(6, 3) = [2, 2, 2]
		 * distributeUnevenly(8, 3) = [3, 3, 2]
		 */
		const distributeUnevenly = (sum, length) => {
		    const result = Array.from({ length }).fill(Math.floor(sum / length));
		    return result.map((element, index) => {
		        return element + (index < sum % length ? 1 : 0);
		    });
		};
		utils.distributeUnevenly = distributeUnevenly;
		const sequence = (start, end) => {
		    return Array.from({ length: end - start + 1 }, (_, index) => {
		        return index + start;
		    });
		};
		utils.sequence = sequence;
		const sumArray = (array) => {
		    return array.reduce((accumulator, element) => {
		        return accumulator + element;
		    }, 0);
		};
		utils.sumArray = sumArray;
		const extractTruncates = (config) => {
		    return config.columns.map(({ truncate }) => {
		        return truncate;
		    });
		};
		utils.extractTruncates = extractTruncates;
		const flatten = (array) => {
		    return [].concat(...array);
		};
		utils.flatten = flatten;
		const calculateRangeCoordinate = (spanningCellConfig) => {
		    const { row, col, colSpan = 1, rowSpan = 1 } = spanningCellConfig;
		    return { bottomRight: { col: col + colSpan - 1,
		            row: row + rowSpan - 1 },
		        topLeft: { col,
		            row } };
		};
		utils.calculateRangeCoordinate = calculateRangeCoordinate;
		const areCellEqual = (cell1, cell2) => {
		    return cell1.row === cell2.row && cell1.col === cell2.col;
		};
		utils.areCellEqual = areCellEqual;
		const isCellInRange = (cell, { topLeft, bottomRight }) => {
		    return (topLeft.row <= cell.row &&
		        cell.row <= bottomRight.row &&
		        topLeft.col <= cell.col &&
		        cell.col <= bottomRight.col);
		};
		utils.isCellInRange = isCellInRange;
		
		return utils;
	}

	var hasRequiredAlignString;

	function requireAlignString () {
		if (hasRequiredAlignString) return alignString;
		hasRequiredAlignString = 1;
		var __importDefault = (alignString && alignString.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(alignString, "__esModule", { value: true });
		alignString.alignString = void 0;
		const string_width_1 = __importDefault(requireStringWidth());
		const utils_1 = /*@__PURE__*/ requireUtils();
		const alignLeft = (subject, width) => {
		    return subject + ' '.repeat(width);
		};
		const alignRight = (subject, width) => {
		    return ' '.repeat(width) + subject;
		};
		const alignCenter = (subject, width) => {
		    return ' '.repeat(Math.floor(width / 2)) + subject + ' '.repeat(Math.ceil(width / 2));
		};
		const alignJustify = (subject, width) => {
		    const spaceSequenceCount = (0, utils_1.countSpaceSequence)(subject);
		    if (spaceSequenceCount === 0) {
		        return alignLeft(subject, width);
		    }
		    const addingSpaces = (0, utils_1.distributeUnevenly)(width, spaceSequenceCount);
		    if (Math.max(...addingSpaces) > 3) {
		        return alignLeft(subject, width);
		    }
		    let spaceSequenceIndex = 0;
		    return subject.replace(/\s+/g, (groupSpace) => {
		        return groupSpace + ' '.repeat(addingSpaces[spaceSequenceIndex++]);
		    });
		};
		/**
		 * Pads a string to the left and/or right to position the subject
		 * text in a desired alignment within a container.
		 */
		const alignString$1 = (subject, containerWidth, alignment) => {
		    const subjectWidth = (0, string_width_1.default)(subject);
		    if (subjectWidth === containerWidth) {
		        return subject;
		    }
		    if (subjectWidth > containerWidth) {
		        throw new Error('Subject parameter value width cannot be greater than the container width.');
		    }
		    if (subjectWidth === 0) {
		        return ' '.repeat(containerWidth);
		    }
		    const availableWidth = containerWidth - subjectWidth;
		    if (alignment === 'left') {
		        return alignLeft(subject, availableWidth);
		    }
		    if (alignment === 'right') {
		        return alignRight(subject, availableWidth);
		    }
		    if (alignment === 'justify') {
		        return alignJustify(subject, availableWidth);
		    }
		    return alignCenter(subject, availableWidth);
		};
		alignString.alignString = alignString$1;
		
		return alignString;
	}

	var hasRequiredAlignTableData;

	function requireAlignTableData () {
		if (hasRequiredAlignTableData) return alignTableData;
		hasRequiredAlignTableData = 1;
		Object.defineProperty(alignTableData, "__esModule", { value: true });
		alignTableData.alignTableData = void 0;
		const alignString_1 = /*@__PURE__*/ requireAlignString();
		const alignTableData$1 = (rows, config) => {
		    return rows.map((row, rowIndex) => {
		        return row.map((cell, cellIndex) => {
		            var _a;
		            const { width, alignment } = config.columns[cellIndex];
		            const containingRange = (_a = config.spanningCellManager) === null || _a === void 0 ? void 0 : _a.getContainingRange({ col: cellIndex,
		                row: rowIndex }, { mapped: true });
		            if (containingRange) {
		                return cell;
		            }
		            return (0, alignString_1.alignString)(cell, width, alignment);
		        });
		    });
		};
		alignTableData.alignTableData = alignTableData$1;
		
		return alignTableData;
	}

	var calculateRowHeights = {};

	var calculateCellHeight = {};

	var wrapCell = {};

	var wrapString = {};

	var hasRequiredWrapString;

	function requireWrapString () {
		if (hasRequiredWrapString) return wrapString;
		hasRequiredWrapString = 1;
		var __importDefault = (wrapString && wrapString.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(wrapString, "__esModule", { value: true });
		wrapString.wrapString = void 0;
		const slice_ansi_1 = __importDefault(requireSliceAnsi());
		const string_width_1 = __importDefault(requireStringWidth());
		/**
		 * Creates an array of strings split into groups the length of size.
		 * This function works with strings that contain ASCII characters.
		 *
		 * wrapText is different from would-be "chunk" implementation
		 * in that whitespace characters that occur on a chunk size limit are trimmed.
		 *
		 */
		const wrapString$1 = (subject, size) => {
		    let subjectSlice = subject;
		    const chunks = [];
		    do {
		        chunks.push((0, slice_ansi_1.default)(subjectSlice, 0, size));
		        subjectSlice = (0, slice_ansi_1.default)(subjectSlice, size).trim();
		    } while ((0, string_width_1.default)(subjectSlice));
		    return chunks;
		};
		wrapString.wrapString = wrapString$1;
		
		return wrapString;
	}

	var wrapWord = {};

	var hasRequiredWrapWord;

	function requireWrapWord () {
		if (hasRequiredWrapWord) return wrapWord;
		hasRequiredWrapWord = 1;
		var __importDefault = (wrapWord && wrapWord.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(wrapWord, "__esModule", { value: true });
		wrapWord.wrapWord = void 0;
		const slice_ansi_1 = __importDefault(requireSliceAnsi());
		const strip_ansi_1 = __importDefault(requireStripAnsi());
		const calculateStringLengths = (input, size) => {
		    let subject = (0, strip_ansi_1.default)(input);
		    const chunks = [];
		    // https://regex101.com/r/gY5kZ1/1
		    const re = new RegExp('(^.{1,' + String(Math.max(size, 1)) + '}(\\s+|$))|(^.{1,' + String(Math.max(size - 1, 1)) + '}(\\\\|/|_|\\.|,|;|-))');
		    do {
		        let chunk;
		        const match = re.exec(subject);
		        if (match) {
		            chunk = match[0];
		            subject = subject.slice(chunk.length);
		            const trimmedLength = chunk.trim().length;
		            const offset = chunk.length - trimmedLength;
		            chunks.push([trimmedLength, offset]);
		        }
		        else {
		            chunk = subject.slice(0, size);
		            subject = subject.slice(size);
		            chunks.push([chunk.length, 0]);
		        }
		    } while (subject.length);
		    return chunks;
		};
		const wrapWord$1 = (input, size) => {
		    const result = [];
		    let startIndex = 0;
		    calculateStringLengths(input, size).forEach(([length, offset]) => {
		        result.push((0, slice_ansi_1.default)(input, startIndex, startIndex + length));
		        startIndex += length + offset;
		    });
		    return result;
		};
		wrapWord.wrapWord = wrapWord$1;
		
		return wrapWord;
	}

	var hasRequiredWrapCell;

	function requireWrapCell () {
		if (hasRequiredWrapCell) return wrapCell;
		hasRequiredWrapCell = 1;
		Object.defineProperty(wrapCell, "__esModule", { value: true });
		wrapCell.wrapCell = void 0;
		const utils_1 = /*@__PURE__*/ requireUtils();
		const wrapString_1 = /*@__PURE__*/ requireWrapString();
		const wrapWord_1 = /*@__PURE__*/ requireWrapWord();
		/**
		 * Wrap a single cell value into a list of lines
		 *
		 * Always wraps on newlines, for the remainder uses either word or string wrapping
		 * depending on user configuration.
		 *
		 */
		const wrapCell$1 = (cellValue, cellWidth, useWrapWord) => {
		    // First split on literal newlines
		    const cellLines = (0, utils_1.splitAnsi)(cellValue);
		    // Then iterate over the list and word-wrap every remaining line if necessary.
		    for (let lineNr = 0; lineNr < cellLines.length;) {
		        let lineChunks;
		        if (useWrapWord) {
		            lineChunks = (0, wrapWord_1.wrapWord)(cellLines[lineNr], cellWidth);
		        }
		        else {
		            lineChunks = (0, wrapString_1.wrapString)(cellLines[lineNr], cellWidth);
		        }
		        // Replace our original array element with whatever the wrapping returned
		        cellLines.splice(lineNr, 1, ...lineChunks);
		        lineNr += lineChunks.length;
		    }
		    return cellLines;
		};
		wrapCell.wrapCell = wrapCell$1;
		
		return wrapCell;
	}

	var hasRequiredCalculateCellHeight;

	function requireCalculateCellHeight () {
		if (hasRequiredCalculateCellHeight) return calculateCellHeight;
		hasRequiredCalculateCellHeight = 1;
		Object.defineProperty(calculateCellHeight, "__esModule", { value: true });
		calculateCellHeight.calculateCellHeight = void 0;
		const wrapCell_1 = /*@__PURE__*/ requireWrapCell();
		/**
		 * Calculates height of cell content in regard to its width and word wrapping.
		 */
		const calculateCellHeight$1 = (value, columnWidth, useWrapWord = false) => {
		    return (0, wrapCell_1.wrapCell)(value, columnWidth, useWrapWord).length;
		};
		calculateCellHeight.calculateCellHeight = calculateCellHeight$1;
		
		return calculateCellHeight;
	}

	var hasRequiredCalculateRowHeights;

	function requireCalculateRowHeights () {
		if (hasRequiredCalculateRowHeights) return calculateRowHeights;
		hasRequiredCalculateRowHeights = 1;
		Object.defineProperty(calculateRowHeights, "__esModule", { value: true });
		calculateRowHeights.calculateRowHeights = void 0;
		const calculateCellHeight_1 = /*@__PURE__*/ requireCalculateCellHeight();
		const utils_1 = /*@__PURE__*/ requireUtils();
		/**
		 * Produces an array of values that describe the largest value length (height) in every row.
		 */
		const calculateRowHeights$1 = (rows, config) => {
		    const rowHeights = [];
		    for (const [rowIndex, row] of rows.entries()) {
		        let rowHeight = 1;
		        row.forEach((cell, cellIndex) => {
		            var _a;
		            const containingRange = (_a = config.spanningCellManager) === null || _a === void 0 ? void 0 : _a.getContainingRange({ col: cellIndex,
		                row: rowIndex });
		            if (!containingRange) {
		                const cellHeight = (0, calculateCellHeight_1.calculateCellHeight)(cell, config.columns[cellIndex].width, config.columns[cellIndex].wrapWord);
		                rowHeight = Math.max(rowHeight, cellHeight);
		                return;
		            }
		            const { topLeft, bottomRight, height } = containingRange;
		            // bottom-most cell of a range needs to contain all remain lines of spanning cells
		            if (rowIndex === bottomRight.row) {
		                const totalOccupiedSpanningCellHeight = (0, utils_1.sumArray)(rowHeights.slice(topLeft.row));
		                const totalHorizontalBorderHeight = bottomRight.row - topLeft.row;
		                const totalHiddenHorizontalBorderHeight = (0, utils_1.sequence)(topLeft.row + 1, bottomRight.row).filter((horizontalBorderIndex) => {
		                    var _a;
		                    /* istanbul ignore next */
		                    return !((_a = config.drawHorizontalLine) === null || _a === void 0 ? void 0 : _a.call(config, horizontalBorderIndex, rows.length));
		                }).length;
		                const cellHeight = height - totalOccupiedSpanningCellHeight - totalHorizontalBorderHeight + totalHiddenHorizontalBorderHeight;
		                rowHeight = Math.max(rowHeight, cellHeight);
		            }
		            // otherwise, just depend on other sibling cell heights in the row
		        });
		        rowHeights.push(rowHeight);
		    }
		    return rowHeights;
		};
		calculateRowHeights.calculateRowHeights = calculateRowHeights$1;
		
		return calculateRowHeights;
	}

	var drawBorder = {};

	var drawContent = {};

	var hasRequiredDrawContent;

	function requireDrawContent () {
		if (hasRequiredDrawContent) return drawContent;
		hasRequiredDrawContent = 1;
		Object.defineProperty(drawContent, "__esModule", { value: true });
		drawContent.drawContent = void 0;
		const drawContent$1 = (parameters) => {
		    const { contents, separatorGetter, drawSeparator, spanningCellManager, rowIndex, elementType } = parameters;
		    const contentSize = contents.length;
		    const result = [];
		    if (drawSeparator(0, contentSize)) {
		        result.push(separatorGetter(0, contentSize));
		    }
		    contents.forEach((content, contentIndex) => {
		        if (!elementType || elementType === 'border' || elementType === 'row') {
		            result.push(content);
		        }
		        if (elementType === 'cell' && rowIndex === undefined) {
		            result.push(content);
		        }
		        if (elementType === 'cell' && rowIndex !== undefined) {
		            /* istanbul ignore next */
		            const containingRange = spanningCellManager === null || spanningCellManager === void 0 ? void 0 : spanningCellManager.getContainingRange({ col: contentIndex,
		                row: rowIndex });
		            // when drawing content row, just add a cell when it is a normal cell
		            // or belongs to first column of spanning cell
		            if (!containingRange || contentIndex === containingRange.topLeft.col) {
		                result.push(content);
		            }
		        }
		        // Only append the middle separator if the content is not the last
		        if (contentIndex + 1 < contentSize && drawSeparator(contentIndex + 1, contentSize)) {
		            const separator = separatorGetter(contentIndex + 1, contentSize);
		            if (elementType === 'cell' && rowIndex !== undefined) {
		                const currentCell = { col: contentIndex + 1,
		                    row: rowIndex };
		                /* istanbul ignore next */
		                const containingRange = spanningCellManager === null || spanningCellManager === void 0 ? void 0 : spanningCellManager.getContainingRange(currentCell);
		                if (!containingRange || containingRange.topLeft.col === currentCell.col) {
		                    result.push(separator);
		                }
		            }
		            else {
		                result.push(separator);
		            }
		        }
		    });
		    if (drawSeparator(contentSize, contentSize)) {
		        result.push(separatorGetter(contentSize, contentSize));
		    }
		    return result.join('');
		};
		drawContent.drawContent = drawContent$1;
		
		return drawContent;
	}

	var hasRequiredDrawBorder;

	function requireDrawBorder () {
		if (hasRequiredDrawBorder) return drawBorder;
		hasRequiredDrawBorder = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.createTableBorderGetter = exports.drawBorderBottom = exports.drawBorderJoin = exports.drawBorderTop = exports.drawBorder = exports.createSeparatorGetter = exports.drawBorderSegments = void 0;
			const drawContent_1 = /*@__PURE__*/ requireDrawContent();
			const drawBorderSegments = (columnWidths, parameters) => {
			    const { separator, horizontalBorderIndex, spanningCellManager } = parameters;
			    return columnWidths.map((columnWidth, columnIndex) => {
			        const normalSegment = separator.body.repeat(columnWidth);
			        if (horizontalBorderIndex === undefined) {
			            return normalSegment;
			        }
			        /* istanbul ignore next */
			        const range = spanningCellManager === null || spanningCellManager === void 0 ? void 0 : spanningCellManager.getContainingRange({ col: columnIndex,
			            row: horizontalBorderIndex });
			        if (!range) {
			            return normalSegment;
			        }
			        const { topLeft } = range;
			        // draw border segments as usual for top border of spanning cell
			        if (horizontalBorderIndex === topLeft.row) {
			            return normalSegment;
			        }
			        // if for first column/row of spanning cell, just skip
			        if (columnIndex !== topLeft.col) {
			            return '';
			        }
			        return range.extractBorderContent(horizontalBorderIndex);
			    });
			};
			exports.drawBorderSegments = drawBorderSegments;
			const createSeparatorGetter = (dependencies) => {
			    const { separator, spanningCellManager, horizontalBorderIndex, rowCount } = dependencies;
			    // eslint-disable-next-line complexity
			    return (verticalBorderIndex, columnCount) => {
			        const inSameRange = spanningCellManager === null || spanningCellManager === void 0 ? void 0 : spanningCellManager.inSameRange;
			        if (horizontalBorderIndex !== undefined && inSameRange) {
			            const topCell = { col: verticalBorderIndex,
			                row: horizontalBorderIndex - 1 };
			            const leftCell = { col: verticalBorderIndex - 1,
			                row: horizontalBorderIndex };
			            const oppositeCell = { col: verticalBorderIndex - 1,
			                row: horizontalBorderIndex - 1 };
			            const currentCell = { col: verticalBorderIndex,
			                row: horizontalBorderIndex };
			            const pairs = [
			                [oppositeCell, topCell],
			                [topCell, currentCell],
			                [currentCell, leftCell],
			                [leftCell, oppositeCell],
			            ];
			            // left side of horizontal border
			            if (verticalBorderIndex === 0) {
			                if (inSameRange(currentCell, topCell) && separator.bodyJoinOuter) {
			                    return separator.bodyJoinOuter;
			                }
			                return separator.left;
			            }
			            // right side of horizontal border
			            if (verticalBorderIndex === columnCount) {
			                if (inSameRange(oppositeCell, leftCell) && separator.bodyJoinOuter) {
			                    return separator.bodyJoinOuter;
			                }
			                return separator.right;
			            }
			            // top horizontal border
			            if (horizontalBorderIndex === 0) {
			                if (inSameRange(currentCell, leftCell)) {
			                    return separator.body;
			                }
			                return separator.join;
			            }
			            // bottom horizontal border
			            if (horizontalBorderIndex === rowCount) {
			                if (inSameRange(topCell, oppositeCell)) {
			                    return separator.body;
			                }
			                return separator.join;
			            }
			            const sameRangeCount = pairs.map((pair) => {
			                return inSameRange(...pair);
			            }).filter(Boolean).length;
			            // four cells are belongs to different spanning cells
			            if (sameRangeCount === 0) {
			                return separator.join;
			            }
			            // belong to one spanning cell
			            if (sameRangeCount === 4) {
			                return '';
			            }
			            // belongs to two spanning cell
			            if (sameRangeCount === 2) {
			                if (inSameRange(...pairs[1]) && inSameRange(...pairs[3]) && separator.bodyJoinInner) {
			                    return separator.bodyJoinInner;
			                }
			                return separator.body;
			            }
			            /* istanbul ignore next */
			            if (sameRangeCount === 1) {
			                if (!separator.joinRight || !separator.joinLeft || !separator.joinUp || !separator.joinDown) {
			                    throw new Error(`Can not get border separator for position [${horizontalBorderIndex}, ${verticalBorderIndex}]`);
			                }
			                if (inSameRange(...pairs[0])) {
			                    return separator.joinDown;
			                }
			                if (inSameRange(...pairs[1])) {
			                    return separator.joinLeft;
			                }
			                if (inSameRange(...pairs[2])) {
			                    return separator.joinUp;
			                }
			                return separator.joinRight;
			            }
			            /* istanbul ignore next */
			            throw new Error('Invalid case');
			        }
			        if (verticalBorderIndex === 0) {
			            return separator.left;
			        }
			        if (verticalBorderIndex === columnCount) {
			            return separator.right;
			        }
			        return separator.join;
			    };
			};
			exports.createSeparatorGetter = createSeparatorGetter;
			const drawBorder = (columnWidths, parameters) => {
			    const borderSegments = (0, exports.drawBorderSegments)(columnWidths, parameters);
			    const { drawVerticalLine, horizontalBorderIndex, spanningCellManager } = parameters;
			    return (0, drawContent_1.drawContent)({
			        contents: borderSegments,
			        drawSeparator: drawVerticalLine,
			        elementType: 'border',
			        rowIndex: horizontalBorderIndex,
			        separatorGetter: (0, exports.createSeparatorGetter)(parameters),
			        spanningCellManager,
			    }) + '\n';
			};
			exports.drawBorder = drawBorder;
			const drawBorderTop = (columnWidths, parameters) => {
			    const { border } = parameters;
			    const result = (0, exports.drawBorder)(columnWidths, {
			        ...parameters,
			        separator: {
			            body: border.topBody,
			            join: border.topJoin,
			            left: border.topLeft,
			            right: border.topRight,
			        },
			    });
			    if (result === '\n') {
			        return '';
			    }
			    return result;
			};
			exports.drawBorderTop = drawBorderTop;
			const drawBorderJoin = (columnWidths, parameters) => {
			    const { border } = parameters;
			    return (0, exports.drawBorder)(columnWidths, {
			        ...parameters,
			        separator: {
			            body: border.joinBody,
			            bodyJoinInner: border.bodyJoin,
			            bodyJoinOuter: border.bodyLeft,
			            join: border.joinJoin,
			            joinDown: border.joinMiddleDown,
			            joinLeft: border.joinMiddleLeft,
			            joinRight: border.joinMiddleRight,
			            joinUp: border.joinMiddleUp,
			            left: border.joinLeft,
			            right: border.joinRight,
			        },
			    });
			};
			exports.drawBorderJoin = drawBorderJoin;
			const drawBorderBottom = (columnWidths, parameters) => {
			    const { border } = parameters;
			    return (0, exports.drawBorder)(columnWidths, {
			        ...parameters,
			        separator: {
			            body: border.bottomBody,
			            join: border.bottomJoin,
			            left: border.bottomLeft,
			            right: border.bottomRight,
			        },
			    });
			};
			exports.drawBorderBottom = drawBorderBottom;
			const createTableBorderGetter = (columnWidths, parameters) => {
			    return (index, size) => {
			        const drawBorderParameters = { ...parameters,
			            horizontalBorderIndex: index };
			        if (index === 0) {
			            return (0, exports.drawBorderTop)(columnWidths, drawBorderParameters);
			        }
			        else if (index === size) {
			            return (0, exports.drawBorderBottom)(columnWidths, drawBorderParameters);
			        }
			        return (0, exports.drawBorderJoin)(columnWidths, drawBorderParameters);
			    };
			};
			exports.createTableBorderGetter = createTableBorderGetter;
			
		} (drawBorder));
		return drawBorder;
	}

	var drawRow = {};

	var hasRequiredDrawRow;

	function requireDrawRow () {
		if (hasRequiredDrawRow) return drawRow;
		hasRequiredDrawRow = 1;
		Object.defineProperty(drawRow, "__esModule", { value: true });
		drawRow.drawRow = void 0;
		const drawContent_1 = /*@__PURE__*/ requireDrawContent();
		const drawRow$1 = (row, config) => {
		    const { border, drawVerticalLine, rowIndex, spanningCellManager } = config;
		    return (0, drawContent_1.drawContent)({
		        contents: row,
		        drawSeparator: drawVerticalLine,
		        elementType: 'cell',
		        rowIndex,
		        separatorGetter: (index, columnCount) => {
		            if (index === 0) {
		                return border.bodyLeft;
		            }
		            if (index === columnCount) {
		                return border.bodyRight;
		            }
		            return border.bodyJoin;
		        },
		        spanningCellManager,
		    }) + '\n';
		};
		drawRow.drawRow = drawRow$1;
		
		return drawRow;
	}

	var makeStreamConfig = {};

	var validateConfig = {};

	var validators = {};

	var equal = {};

	var fastDeepEqual;
	var hasRequiredFastDeepEqual;

	function requireFastDeepEqual () {
		if (hasRequiredFastDeepEqual) return fastDeepEqual;
		hasRequiredFastDeepEqual = 1;

		// do not edit .js files directly - edit src/index.jst



		fastDeepEqual = function equal(a, b) {
		  if (a === b) return true;

		  if (a && b && typeof a == 'object' && typeof b == 'object') {
		    if (a.constructor !== b.constructor) return false;

		    var length, i, keys;
		    if (Array.isArray(a)) {
		      length = a.length;
		      if (length != b.length) return false;
		      for (i = length; i-- !== 0;)
		        if (!equal(a[i], b[i])) return false;
		      return true;
		    }



		    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
		    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
		    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

		    keys = Object.keys(a);
		    length = keys.length;
		    if (length !== Object.keys(b).length) return false;

		    for (i = length; i-- !== 0;)
		      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

		    for (i = length; i-- !== 0;) {
		      var key = keys[i];

		      if (!equal(a[key], b[key])) return false;
		    }

		    return true;
		  }

		  // true if both NaN, false otherwise
		  return a!==a && b!==b;
		};
		return fastDeepEqual;
	}

	var hasRequiredEqual;

	function requireEqual () {
		if (hasRequiredEqual) return equal;
		hasRequiredEqual = 1;
		Object.defineProperty(equal, "__esModule", { value: true });
		// https://github.com/ajv-validator/ajv/issues/889
		const equal$1 = requireFastDeepEqual();
		equal$1.code = 'require("ajv/dist/runtime/equal").default';
		equal.default = equal$1;
		
		return equal;
	}

	var hasRequiredValidators;

	function requireValidators () {
		if (hasRequiredValidators) return validators;
		hasRequiredValidators = 1;
		(function (exports) {
			exports["config.json"] = validate43;
			const schema13 = {
			    "properties": {
			        "spanningCells": {
			            "items": {
			                "properties": {
			                    "col": {
			                        "type": "integer",
			                        "minimum": 0
			                    },
			                    "row": {
			                        "type": "integer",
			                        "minimum": 0
			                    },
			                    "colSpan": {
			                        "type": "integer",
			                        "minimum": 1
			                    },
			                    "rowSpan": {
			                        "type": "integer",
			                        "minimum": 1
			                    },
			                    "alignment": {
			                        "$ref": "shared.json#/definitions/alignment"
			                    },
			                    "verticalAlignment": {
			                        "$ref": "shared.json#/definitions/verticalAlignment"
			                    },
			                    "wrapWord": {
			                        "type": "boolean"
			                    },
			                    "truncate": {
			                        "type": "integer"
			                    },
			                    "paddingLeft": {
			                        "type": "integer"
			                    },
			                    "paddingRight": {
			                        "type": "integer"
			                    }
			                }}
			        }
			    }};
			const schema15 = {
			    "properties": {
			        "topBody": {
			            "$ref": "#/definitions/border"
			        },
			        "topJoin": {
			            "$ref": "#/definitions/border"
			        },
			        "topLeft": {
			            "$ref": "#/definitions/border"
			        },
			        "topRight": {
			            "$ref": "#/definitions/border"
			        },
			        "bottomBody": {
			            "$ref": "#/definitions/border"
			        },
			        "bottomJoin": {
			            "$ref": "#/definitions/border"
			        },
			        "bottomLeft": {
			            "$ref": "#/definitions/border"
			        },
			        "bottomRight": {
			            "$ref": "#/definitions/border"
			        },
			        "bodyLeft": {
			            "$ref": "#/definitions/border"
			        },
			        "bodyRight": {
			            "$ref": "#/definitions/border"
			        },
			        "bodyJoin": {
			            "$ref": "#/definitions/border"
			        },
			        "headerJoin": {
			            "$ref": "#/definitions/border"
			        },
			        "joinBody": {
			            "$ref": "#/definitions/border"
			        },
			        "joinLeft": {
			            "$ref": "#/definitions/border"
			        },
			        "joinRight": {
			            "$ref": "#/definitions/border"
			        },
			        "joinJoin": {
			            "$ref": "#/definitions/border"
			        },
			        "joinMiddleUp": {
			            "$ref": "#/definitions/border"
			        },
			        "joinMiddleDown": {
			            "$ref": "#/definitions/border"
			        },
			        "joinMiddleLeft": {
			            "$ref": "#/definitions/border"
			        },
			        "joinMiddleRight": {
			            "$ref": "#/definitions/border"
			        }
			    }};
			const func8 = Object.prototype.hasOwnProperty;
			function validate46(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    if (typeof data !== "string") {
			        const err0 = {
			            instancePath,
			            schemaPath: "#/type",
			            keyword: "type",
			            params: {
			                type: "string"
			            },
			            message: "must be string"
			        };
			        if (vErrors === null) {
			            vErrors = [err0];
			        }
			        else {
			            vErrors.push(err0);
			        }
			        errors++;
			    }
			    validate46.errors = vErrors;
			    return errors === 0;
			}
			function validate45(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    if (data && typeof data == "object" && !Array.isArray(data)) {
			        for (const key0 in data) {
			            if (!(func8.call(schema15.properties, key0))) {
			                const err0 = {
			                    instancePath,
			                    schemaPath: "#/additionalProperties",
			                    keyword: "additionalProperties",
			                    params: {
			                        additionalProperty: key0
			                    },
			                    message: "must NOT have additional properties"
			                };
			                if (vErrors === null) {
			                    vErrors = [err0];
			                }
			                else {
			                    vErrors.push(err0);
			                }
			                errors++;
			            }
			        }
			        if (data.topBody !== undefined) {
			            if (!(validate46(data.topBody, {
			                instancePath: instancePath + "/topBody",
			                parentData: data,
			                parentDataProperty: "topBody",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.topJoin !== undefined) {
			            if (!(validate46(data.topJoin, {
			                instancePath: instancePath + "/topJoin",
			                parentData: data,
			                parentDataProperty: "topJoin",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.topLeft !== undefined) {
			            if (!(validate46(data.topLeft, {
			                instancePath: instancePath + "/topLeft",
			                parentData: data,
			                parentDataProperty: "topLeft",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.topRight !== undefined) {
			            if (!(validate46(data.topRight, {
			                instancePath: instancePath + "/topRight",
			                parentData: data,
			                parentDataProperty: "topRight",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bottomBody !== undefined) {
			            if (!(validate46(data.bottomBody, {
			                instancePath: instancePath + "/bottomBody",
			                parentData: data,
			                parentDataProperty: "bottomBody",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bottomJoin !== undefined) {
			            if (!(validate46(data.bottomJoin, {
			                instancePath: instancePath + "/bottomJoin",
			                parentData: data,
			                parentDataProperty: "bottomJoin",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bottomLeft !== undefined) {
			            if (!(validate46(data.bottomLeft, {
			                instancePath: instancePath + "/bottomLeft",
			                parentData: data,
			                parentDataProperty: "bottomLeft",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bottomRight !== undefined) {
			            if (!(validate46(data.bottomRight, {
			                instancePath: instancePath + "/bottomRight",
			                parentData: data,
			                parentDataProperty: "bottomRight",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bodyLeft !== undefined) {
			            if (!(validate46(data.bodyLeft, {
			                instancePath: instancePath + "/bodyLeft",
			                parentData: data,
			                parentDataProperty: "bodyLeft",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bodyRight !== undefined) {
			            if (!(validate46(data.bodyRight, {
			                instancePath: instancePath + "/bodyRight",
			                parentData: data,
			                parentDataProperty: "bodyRight",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bodyJoin !== undefined) {
			            if (!(validate46(data.bodyJoin, {
			                instancePath: instancePath + "/bodyJoin",
			                parentData: data,
			                parentDataProperty: "bodyJoin",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.headerJoin !== undefined) {
			            if (!(validate46(data.headerJoin, {
			                instancePath: instancePath + "/headerJoin",
			                parentData: data,
			                parentDataProperty: "headerJoin",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinBody !== undefined) {
			            if (!(validate46(data.joinBody, {
			                instancePath: instancePath + "/joinBody",
			                parentData: data,
			                parentDataProperty: "joinBody",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinLeft !== undefined) {
			            if (!(validate46(data.joinLeft, {
			                instancePath: instancePath + "/joinLeft",
			                parentData: data,
			                parentDataProperty: "joinLeft",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinRight !== undefined) {
			            if (!(validate46(data.joinRight, {
			                instancePath: instancePath + "/joinRight",
			                parentData: data,
			                parentDataProperty: "joinRight",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinJoin !== undefined) {
			            if (!(validate46(data.joinJoin, {
			                instancePath: instancePath + "/joinJoin",
			                parentData: data,
			                parentDataProperty: "joinJoin",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinMiddleUp !== undefined) {
			            if (!(validate46(data.joinMiddleUp, {
			                instancePath: instancePath + "/joinMiddleUp",
			                parentData: data,
			                parentDataProperty: "joinMiddleUp",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinMiddleDown !== undefined) {
			            if (!(validate46(data.joinMiddleDown, {
			                instancePath: instancePath + "/joinMiddleDown",
			                parentData: data,
			                parentDataProperty: "joinMiddleDown",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinMiddleLeft !== undefined) {
			            if (!(validate46(data.joinMiddleLeft, {
			                instancePath: instancePath + "/joinMiddleLeft",
			                parentData: data,
			                parentDataProperty: "joinMiddleLeft",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinMiddleRight !== undefined) {
			            if (!(validate46(data.joinMiddleRight, {
			                instancePath: instancePath + "/joinMiddleRight",
			                parentData: data,
			                parentDataProperty: "joinMiddleRight",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			    }
			    else {
			        const err1 = {
			            instancePath,
			            schemaPath: "#/type",
			            keyword: "type",
			            params: {
			                type: "object"
			            },
			            message: "must be object"
			        };
			        if (vErrors === null) {
			            vErrors = [err1];
			        }
			        else {
			            vErrors.push(err1);
			        }
			        errors++;
			    }
			    validate45.errors = vErrors;
			    return errors === 0;
			}
			const schema17 = {
			    "enum": ["left", "right", "center", "justify"]
			};
			requireEqual().default;
			function validate68(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    if (typeof data !== "string") {
			        const err0 = {
			            instancePath,
			            schemaPath: "#/type",
			            keyword: "type",
			            params: {
			                type: "string"
			            },
			            message: "must be string"
			        };
			        if (vErrors === null) {
			            vErrors = [err0];
			        }
			        else {
			            vErrors.push(err0);
			        }
			        errors++;
			    }
			    if (!((((data === "left") || (data === "right")) || (data === "center")) || (data === "justify"))) {
			        const err1 = {
			            instancePath,
			            schemaPath: "#/enum",
			            keyword: "enum",
			            params: {
			                allowedValues: schema17.enum
			            },
			            message: "must be equal to one of the allowed values"
			        };
			        if (vErrors === null) {
			            vErrors = [err1];
			        }
			        else {
			            vErrors.push(err1);
			        }
			        errors++;
			    }
			    validate68.errors = vErrors;
			    return errors === 0;
			}
			const pattern0 = new RegExp("^[0-9]+$", "u");
			function validate72(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    if (typeof data !== "string") {
			        const err0 = {
			            instancePath,
			            schemaPath: "#/type",
			            keyword: "type",
			            params: {
			                type: "string"
			            },
			            message: "must be string"
			        };
			        if (vErrors === null) {
			            vErrors = [err0];
			        }
			        else {
			            vErrors.push(err0);
			        }
			        errors++;
			    }
			    if (!((((data === "left") || (data === "right")) || (data === "center")) || (data === "justify"))) {
			        const err1 = {
			            instancePath,
			            schemaPath: "#/enum",
			            keyword: "enum",
			            params: {
			                allowedValues: schema17.enum
			            },
			            message: "must be equal to one of the allowed values"
			        };
			        if (vErrors === null) {
			            vErrors = [err1];
			        }
			        else {
			            vErrors.push(err1);
			        }
			        errors++;
			    }
			    validate72.errors = vErrors;
			    return errors === 0;
			}
			const schema21 = {
			    "enum": ["top", "middle", "bottom"]
			};
			function validate74(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    if (typeof data !== "string") {
			        const err0 = {
			            instancePath,
			            schemaPath: "#/type",
			            keyword: "type",
			            params: {
			                type: "string"
			            },
			            message: "must be string"
			        };
			        if (vErrors === null) {
			            vErrors = [err0];
			        }
			        else {
			            vErrors.push(err0);
			        }
			        errors++;
			    }
			    if (!(((data === "top") || (data === "middle")) || (data === "bottom"))) {
			        const err1 = {
			            instancePath,
			            schemaPath: "#/enum",
			            keyword: "enum",
			            params: {
			                allowedValues: schema21.enum
			            },
			            message: "must be equal to one of the allowed values"
			        };
			        if (vErrors === null) {
			            vErrors = [err1];
			        }
			        else {
			            vErrors.push(err1);
			        }
			        errors++;
			    }
			    validate74.errors = vErrors;
			    return errors === 0;
			}
			function validate71(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    if (data && typeof data == "object" && !Array.isArray(data)) {
			        for (const key0 in data) {
			            if (!(((((((key0 === "alignment") || (key0 === "verticalAlignment")) || (key0 === "width")) || (key0 === "wrapWord")) || (key0 === "truncate")) || (key0 === "paddingLeft")) || (key0 === "paddingRight"))) {
			                const err0 = {
			                    instancePath,
			                    schemaPath: "#/additionalProperties",
			                    keyword: "additionalProperties",
			                    params: {
			                        additionalProperty: key0
			                    },
			                    message: "must NOT have additional properties"
			                };
			                if (vErrors === null) {
			                    vErrors = [err0];
			                }
			                else {
			                    vErrors.push(err0);
			                }
			                errors++;
			            }
			        }
			        if (data.alignment !== undefined) {
			            if (!(validate72(data.alignment, {
			                instancePath: instancePath + "/alignment",
			                parentData: data,
			                parentDataProperty: "alignment",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate72.errors : vErrors.concat(validate72.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.verticalAlignment !== undefined) {
			            if (!(validate74(data.verticalAlignment, {
			                instancePath: instancePath + "/verticalAlignment",
			                parentData: data,
			                parentDataProperty: "verticalAlignment",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate74.errors : vErrors.concat(validate74.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.width !== undefined) {
			            let data2 = data.width;
			            if (!(((typeof data2 == "number") && (!(data2 % 1) && !isNaN(data2))) && (isFinite(data2)))) {
			                const err1 = {
			                    instancePath: instancePath + "/width",
			                    schemaPath: "#/properties/width/type",
			                    keyword: "type",
			                    params: {
			                        type: "integer"
			                    },
			                    message: "must be integer"
			                };
			                if (vErrors === null) {
			                    vErrors = [err1];
			                }
			                else {
			                    vErrors.push(err1);
			                }
			                errors++;
			            }
			            if ((typeof data2 == "number") && (isFinite(data2))) {
			                if (data2 < 1 || isNaN(data2)) {
			                    const err2 = {
			                        instancePath: instancePath + "/width",
			                        schemaPath: "#/properties/width/minimum",
			                        keyword: "minimum",
			                        params: {
			                            comparison: ">=",
			                            limit: 1
			                        },
			                        message: "must be >= 1"
			                    };
			                    if (vErrors === null) {
			                        vErrors = [err2];
			                    }
			                    else {
			                        vErrors.push(err2);
			                    }
			                    errors++;
			                }
			            }
			        }
			        if (data.wrapWord !== undefined) {
			            if (typeof data.wrapWord !== "boolean") {
			                const err3 = {
			                    instancePath: instancePath + "/wrapWord",
			                    schemaPath: "#/properties/wrapWord/type",
			                    keyword: "type",
			                    params: {
			                        type: "boolean"
			                    },
			                    message: "must be boolean"
			                };
			                if (vErrors === null) {
			                    vErrors = [err3];
			                }
			                else {
			                    vErrors.push(err3);
			                }
			                errors++;
			            }
			        }
			        if (data.truncate !== undefined) {
			            let data4 = data.truncate;
			            if (!(((typeof data4 == "number") && (!(data4 % 1) && !isNaN(data4))) && (isFinite(data4)))) {
			                const err4 = {
			                    instancePath: instancePath + "/truncate",
			                    schemaPath: "#/properties/truncate/type",
			                    keyword: "type",
			                    params: {
			                        type: "integer"
			                    },
			                    message: "must be integer"
			                };
			                if (vErrors === null) {
			                    vErrors = [err4];
			                }
			                else {
			                    vErrors.push(err4);
			                }
			                errors++;
			            }
			        }
			        if (data.paddingLeft !== undefined) {
			            let data5 = data.paddingLeft;
			            if (!(((typeof data5 == "number") && (!(data5 % 1) && !isNaN(data5))) && (isFinite(data5)))) {
			                const err5 = {
			                    instancePath: instancePath + "/paddingLeft",
			                    schemaPath: "#/properties/paddingLeft/type",
			                    keyword: "type",
			                    params: {
			                        type: "integer"
			                    },
			                    message: "must be integer"
			                };
			                if (vErrors === null) {
			                    vErrors = [err5];
			                }
			                else {
			                    vErrors.push(err5);
			                }
			                errors++;
			            }
			        }
			        if (data.paddingRight !== undefined) {
			            let data6 = data.paddingRight;
			            if (!(((typeof data6 == "number") && (!(data6 % 1) && !isNaN(data6))) && (isFinite(data6)))) {
			                const err6 = {
			                    instancePath: instancePath + "/paddingRight",
			                    schemaPath: "#/properties/paddingRight/type",
			                    keyword: "type",
			                    params: {
			                        type: "integer"
			                    },
			                    message: "must be integer"
			                };
			                if (vErrors === null) {
			                    vErrors = [err6];
			                }
			                else {
			                    vErrors.push(err6);
			                }
			                errors++;
			            }
			        }
			    }
			    else {
			        const err7 = {
			            instancePath,
			            schemaPath: "#/type",
			            keyword: "type",
			            params: {
			                type: "object"
			            },
			            message: "must be object"
			        };
			        if (vErrors === null) {
			            vErrors = [err7];
			        }
			        else {
			            vErrors.push(err7);
			        }
			        errors++;
			    }
			    validate71.errors = vErrors;
			    return errors === 0;
			}
			function validate70(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    const _errs0 = errors;
			    let valid0 = false;
			    let passing0 = null;
			    const _errs1 = errors;
			    if (data && typeof data == "object" && !Array.isArray(data)) {
			        for (const key0 in data) {
			            if (!(pattern0.test(key0))) {
			                const err0 = {
			                    instancePath,
			                    schemaPath: "#/oneOf/0/additionalProperties",
			                    keyword: "additionalProperties",
			                    params: {
			                        additionalProperty: key0
			                    },
			                    message: "must NOT have additional properties"
			                };
			                if (vErrors === null) {
			                    vErrors = [err0];
			                }
			                else {
			                    vErrors.push(err0);
			                }
			                errors++;
			            }
			        }
			        for (const key1 in data) {
			            if (pattern0.test(key1)) {
			                if (!(validate71(data[key1], {
			                    instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"),
			                    parentData: data,
			                    parentDataProperty: key1,
			                    rootData
			                }))) {
			                    vErrors = vErrors === null ? validate71.errors : vErrors.concat(validate71.errors);
			                    errors = vErrors.length;
			                }
			            }
			        }
			    }
			    else {
			        const err1 = {
			            instancePath,
			            schemaPath: "#/oneOf/0/type",
			            keyword: "type",
			            params: {
			                type: "object"
			            },
			            message: "must be object"
			        };
			        if (vErrors === null) {
			            vErrors = [err1];
			        }
			        else {
			            vErrors.push(err1);
			        }
			        errors++;
			    }
			    var _valid0 = _errs1 === errors;
			    if (_valid0) {
			        valid0 = true;
			        passing0 = 0;
			    }
			    const _errs5 = errors;
			    if (Array.isArray(data)) {
			        const len0 = data.length;
			        for (let i0 = 0; i0 < len0; i0++) {
			            if (!(validate71(data[i0], {
			                instancePath: instancePath + "/" + i0,
			                parentData: data,
			                parentDataProperty: i0,
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate71.errors : vErrors.concat(validate71.errors);
			                errors = vErrors.length;
			            }
			        }
			    }
			    else {
			        const err2 = {
			            instancePath,
			            schemaPath: "#/oneOf/1/type",
			            keyword: "type",
			            params: {
			                type: "array"
			            },
			            message: "must be array"
			        };
			        if (vErrors === null) {
			            vErrors = [err2];
			        }
			        else {
			            vErrors.push(err2);
			        }
			        errors++;
			    }
			    var _valid0 = _errs5 === errors;
			    if (_valid0 && valid0) {
			        valid0 = false;
			        passing0 = [passing0, 1];
			    }
			    else {
			        if (_valid0) {
			            valid0 = true;
			            passing0 = 1;
			        }
			    }
			    if (!valid0) {
			        const err3 = {
			            instancePath,
			            schemaPath: "#/oneOf",
			            keyword: "oneOf",
			            params: {
			                passingSchemas: passing0
			            },
			            message: "must match exactly one schema in oneOf"
			        };
			        if (vErrors === null) {
			            vErrors = [err3];
			        }
			        else {
			            vErrors.push(err3);
			        }
			        errors++;
			    }
			    else {
			        errors = _errs0;
			        if (vErrors !== null) {
			            if (_errs0) {
			                vErrors.length = _errs0;
			            }
			            else {
			                vErrors = null;
			            }
			        }
			    }
			    validate70.errors = vErrors;
			    return errors === 0;
			}
			function validate79(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    if (data && typeof data == "object" && !Array.isArray(data)) {
			        for (const key0 in data) {
			            if (!(((((((key0 === "alignment") || (key0 === "verticalAlignment")) || (key0 === "width")) || (key0 === "wrapWord")) || (key0 === "truncate")) || (key0 === "paddingLeft")) || (key0 === "paddingRight"))) {
			                const err0 = {
			                    instancePath,
			                    schemaPath: "#/additionalProperties",
			                    keyword: "additionalProperties",
			                    params: {
			                        additionalProperty: key0
			                    },
			                    message: "must NOT have additional properties"
			                };
			                if (vErrors === null) {
			                    vErrors = [err0];
			                }
			                else {
			                    vErrors.push(err0);
			                }
			                errors++;
			            }
			        }
			        if (data.alignment !== undefined) {
			            if (!(validate72(data.alignment, {
			                instancePath: instancePath + "/alignment",
			                parentData: data,
			                parentDataProperty: "alignment",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate72.errors : vErrors.concat(validate72.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.verticalAlignment !== undefined) {
			            if (!(validate74(data.verticalAlignment, {
			                instancePath: instancePath + "/verticalAlignment",
			                parentData: data,
			                parentDataProperty: "verticalAlignment",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate74.errors : vErrors.concat(validate74.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.width !== undefined) {
			            let data2 = data.width;
			            if (!(((typeof data2 == "number") && (!(data2 % 1) && !isNaN(data2))) && (isFinite(data2)))) {
			                const err1 = {
			                    instancePath: instancePath + "/width",
			                    schemaPath: "#/properties/width/type",
			                    keyword: "type",
			                    params: {
			                        type: "integer"
			                    },
			                    message: "must be integer"
			                };
			                if (vErrors === null) {
			                    vErrors = [err1];
			                }
			                else {
			                    vErrors.push(err1);
			                }
			                errors++;
			            }
			            if ((typeof data2 == "number") && (isFinite(data2))) {
			                if (data2 < 1 || isNaN(data2)) {
			                    const err2 = {
			                        instancePath: instancePath + "/width",
			                        schemaPath: "#/properties/width/minimum",
			                        keyword: "minimum",
			                        params: {
			                            comparison: ">=",
			                            limit: 1
			                        },
			                        message: "must be >= 1"
			                    };
			                    if (vErrors === null) {
			                        vErrors = [err2];
			                    }
			                    else {
			                        vErrors.push(err2);
			                    }
			                    errors++;
			                }
			            }
			        }
			        if (data.wrapWord !== undefined) {
			            if (typeof data.wrapWord !== "boolean") {
			                const err3 = {
			                    instancePath: instancePath + "/wrapWord",
			                    schemaPath: "#/properties/wrapWord/type",
			                    keyword: "type",
			                    params: {
			                        type: "boolean"
			                    },
			                    message: "must be boolean"
			                };
			                if (vErrors === null) {
			                    vErrors = [err3];
			                }
			                else {
			                    vErrors.push(err3);
			                }
			                errors++;
			            }
			        }
			        if (data.truncate !== undefined) {
			            let data4 = data.truncate;
			            if (!(((typeof data4 == "number") && (!(data4 % 1) && !isNaN(data4))) && (isFinite(data4)))) {
			                const err4 = {
			                    instancePath: instancePath + "/truncate",
			                    schemaPath: "#/properties/truncate/type",
			                    keyword: "type",
			                    params: {
			                        type: "integer"
			                    },
			                    message: "must be integer"
			                };
			                if (vErrors === null) {
			                    vErrors = [err4];
			                }
			                else {
			                    vErrors.push(err4);
			                }
			                errors++;
			            }
			        }
			        if (data.paddingLeft !== undefined) {
			            let data5 = data.paddingLeft;
			            if (!(((typeof data5 == "number") && (!(data5 % 1) && !isNaN(data5))) && (isFinite(data5)))) {
			                const err5 = {
			                    instancePath: instancePath + "/paddingLeft",
			                    schemaPath: "#/properties/paddingLeft/type",
			                    keyword: "type",
			                    params: {
			                        type: "integer"
			                    },
			                    message: "must be integer"
			                };
			                if (vErrors === null) {
			                    vErrors = [err5];
			                }
			                else {
			                    vErrors.push(err5);
			                }
			                errors++;
			            }
			        }
			        if (data.paddingRight !== undefined) {
			            let data6 = data.paddingRight;
			            if (!(((typeof data6 == "number") && (!(data6 % 1) && !isNaN(data6))) && (isFinite(data6)))) {
			                const err6 = {
			                    instancePath: instancePath + "/paddingRight",
			                    schemaPath: "#/properties/paddingRight/type",
			                    keyword: "type",
			                    params: {
			                        type: "integer"
			                    },
			                    message: "must be integer"
			                };
			                if (vErrors === null) {
			                    vErrors = [err6];
			                }
			                else {
			                    vErrors.push(err6);
			                }
			                errors++;
			            }
			        }
			    }
			    else {
			        const err7 = {
			            instancePath,
			            schemaPath: "#/type",
			            keyword: "type",
			            params: {
			                type: "object"
			            },
			            message: "must be object"
			        };
			        if (vErrors === null) {
			            vErrors = [err7];
			        }
			        else {
			            vErrors.push(err7);
			        }
			        errors++;
			    }
			    validate79.errors = vErrors;
			    return errors === 0;
			}
			function validate84(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    if (typeof data !== "string") {
			        const err0 = {
			            instancePath,
			            schemaPath: "#/type",
			            keyword: "type",
			            params: {
			                type: "string"
			            },
			            message: "must be string"
			        };
			        if (vErrors === null) {
			            vErrors = [err0];
			        }
			        else {
			            vErrors.push(err0);
			        }
			        errors++;
			    }
			    if (!(((data === "top") || (data === "middle")) || (data === "bottom"))) {
			        const err1 = {
			            instancePath,
			            schemaPath: "#/enum",
			            keyword: "enum",
			            params: {
			                allowedValues: schema21.enum
			            },
			            message: "must be equal to one of the allowed values"
			        };
			        if (vErrors === null) {
			            vErrors = [err1];
			        }
			        else {
			            vErrors.push(err1);
			        }
			        errors++;
			    }
			    validate84.errors = vErrors;
			    return errors === 0;
			}
			function validate43(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    if (data && typeof data == "object" && !Array.isArray(data)) {
			        for (const key0 in data) {
			            if (!((((((((key0 === "border") || (key0 === "header")) || (key0 === "columns")) || (key0 === "columnDefault")) || (key0 === "drawVerticalLine")) || (key0 === "drawHorizontalLine")) || (key0 === "singleLine")) || (key0 === "spanningCells"))) {
			                const err0 = {
			                    instancePath,
			                    schemaPath: "#/additionalProperties",
			                    keyword: "additionalProperties",
			                    params: {
			                        additionalProperty: key0
			                    },
			                    message: "must NOT have additional properties"
			                };
			                if (vErrors === null) {
			                    vErrors = [err0];
			                }
			                else {
			                    vErrors.push(err0);
			                }
			                errors++;
			            }
			        }
			        if (data.border !== undefined) {
			            if (!(validate45(data.border, {
			                instancePath: instancePath + "/border",
			                parentData: data,
			                parentDataProperty: "border",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate45.errors : vErrors.concat(validate45.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.header !== undefined) {
			            let data1 = data.header;
			            if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
			                if (data1.content === undefined) {
			                    const err1 = {
			                        instancePath: instancePath + "/header",
			                        schemaPath: "#/properties/header/required",
			                        keyword: "required",
			                        params: {
			                            missingProperty: "content"
			                        },
			                        message: "must have required property '" + "content" + "'"
			                    };
			                    if (vErrors === null) {
			                        vErrors = [err1];
			                    }
			                    else {
			                        vErrors.push(err1);
			                    }
			                    errors++;
			                }
			                for (const key1 in data1) {
			                    if (!((((((key1 === "content") || (key1 === "alignment")) || (key1 === "wrapWord")) || (key1 === "truncate")) || (key1 === "paddingLeft")) || (key1 === "paddingRight"))) {
			                        const err2 = {
			                            instancePath: instancePath + "/header",
			                            schemaPath: "#/properties/header/additionalProperties",
			                            keyword: "additionalProperties",
			                            params: {
			                                additionalProperty: key1
			                            },
			                            message: "must NOT have additional properties"
			                        };
			                        if (vErrors === null) {
			                            vErrors = [err2];
			                        }
			                        else {
			                            vErrors.push(err2);
			                        }
			                        errors++;
			                    }
			                }
			                if (data1.content !== undefined) {
			                    if (typeof data1.content !== "string") {
			                        const err3 = {
			                            instancePath: instancePath + "/header/content",
			                            schemaPath: "#/properties/header/properties/content/type",
			                            keyword: "type",
			                            params: {
			                                type: "string"
			                            },
			                            message: "must be string"
			                        };
			                        if (vErrors === null) {
			                            vErrors = [err3];
			                        }
			                        else {
			                            vErrors.push(err3);
			                        }
			                        errors++;
			                    }
			                }
			                if (data1.alignment !== undefined) {
			                    if (!(validate68(data1.alignment, {
			                        instancePath: instancePath + "/header/alignment",
			                        parentData: data1,
			                        parentDataProperty: "alignment",
			                        rootData
			                    }))) {
			                        vErrors = vErrors === null ? validate68.errors : vErrors.concat(validate68.errors);
			                        errors = vErrors.length;
			                    }
			                }
			                if (data1.wrapWord !== undefined) {
			                    if (typeof data1.wrapWord !== "boolean") {
			                        const err4 = {
			                            instancePath: instancePath + "/header/wrapWord",
			                            schemaPath: "#/properties/header/properties/wrapWord/type",
			                            keyword: "type",
			                            params: {
			                                type: "boolean"
			                            },
			                            message: "must be boolean"
			                        };
			                        if (vErrors === null) {
			                            vErrors = [err4];
			                        }
			                        else {
			                            vErrors.push(err4);
			                        }
			                        errors++;
			                    }
			                }
			                if (data1.truncate !== undefined) {
			                    let data5 = data1.truncate;
			                    if (!(((typeof data5 == "number") && (!(data5 % 1) && !isNaN(data5))) && (isFinite(data5)))) {
			                        const err5 = {
			                            instancePath: instancePath + "/header/truncate",
			                            schemaPath: "#/properties/header/properties/truncate/type",
			                            keyword: "type",
			                            params: {
			                                type: "integer"
			                            },
			                            message: "must be integer"
			                        };
			                        if (vErrors === null) {
			                            vErrors = [err5];
			                        }
			                        else {
			                            vErrors.push(err5);
			                        }
			                        errors++;
			                    }
			                }
			                if (data1.paddingLeft !== undefined) {
			                    let data6 = data1.paddingLeft;
			                    if (!(((typeof data6 == "number") && (!(data6 % 1) && !isNaN(data6))) && (isFinite(data6)))) {
			                        const err6 = {
			                            instancePath: instancePath + "/header/paddingLeft",
			                            schemaPath: "#/properties/header/properties/paddingLeft/type",
			                            keyword: "type",
			                            params: {
			                                type: "integer"
			                            },
			                            message: "must be integer"
			                        };
			                        if (vErrors === null) {
			                            vErrors = [err6];
			                        }
			                        else {
			                            vErrors.push(err6);
			                        }
			                        errors++;
			                    }
			                }
			                if (data1.paddingRight !== undefined) {
			                    let data7 = data1.paddingRight;
			                    if (!(((typeof data7 == "number") && (!(data7 % 1) && !isNaN(data7))) && (isFinite(data7)))) {
			                        const err7 = {
			                            instancePath: instancePath + "/header/paddingRight",
			                            schemaPath: "#/properties/header/properties/paddingRight/type",
			                            keyword: "type",
			                            params: {
			                                type: "integer"
			                            },
			                            message: "must be integer"
			                        };
			                        if (vErrors === null) {
			                            vErrors = [err7];
			                        }
			                        else {
			                            vErrors.push(err7);
			                        }
			                        errors++;
			                    }
			                }
			            }
			            else {
			                const err8 = {
			                    instancePath: instancePath + "/header",
			                    schemaPath: "#/properties/header/type",
			                    keyword: "type",
			                    params: {
			                        type: "object"
			                    },
			                    message: "must be object"
			                };
			                if (vErrors === null) {
			                    vErrors = [err8];
			                }
			                else {
			                    vErrors.push(err8);
			                }
			                errors++;
			            }
			        }
			        if (data.columns !== undefined) {
			            if (!(validate70(data.columns, {
			                instancePath: instancePath + "/columns",
			                parentData: data,
			                parentDataProperty: "columns",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate70.errors : vErrors.concat(validate70.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.columnDefault !== undefined) {
			            if (!(validate79(data.columnDefault, {
			                instancePath: instancePath + "/columnDefault",
			                parentData: data,
			                parentDataProperty: "columnDefault",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate79.errors : vErrors.concat(validate79.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.drawVerticalLine !== undefined) {
			            if (typeof data.drawVerticalLine != "function") {
			                const err9 = {
			                    instancePath: instancePath + "/drawVerticalLine",
			                    schemaPath: "#/properties/drawVerticalLine/typeof",
			                    keyword: "typeof",
			                    params: {},
			                    message: "must pass \"typeof\" keyword validation"
			                };
			                if (vErrors === null) {
			                    vErrors = [err9];
			                }
			                else {
			                    vErrors.push(err9);
			                }
			                errors++;
			            }
			        }
			        if (data.drawHorizontalLine !== undefined) {
			            if (typeof data.drawHorizontalLine != "function") {
			                const err10 = {
			                    instancePath: instancePath + "/drawHorizontalLine",
			                    schemaPath: "#/properties/drawHorizontalLine/typeof",
			                    keyword: "typeof",
			                    params: {},
			                    message: "must pass \"typeof\" keyword validation"
			                };
			                if (vErrors === null) {
			                    vErrors = [err10];
			                }
			                else {
			                    vErrors.push(err10);
			                }
			                errors++;
			            }
			        }
			        if (data.singleLine !== undefined) {
			            if (typeof data.singleLine != "boolean") {
			                const err11 = {
			                    instancePath: instancePath + "/singleLine",
			                    schemaPath: "#/properties/singleLine/typeof",
			                    keyword: "typeof",
			                    params: {},
			                    message: "must pass \"typeof\" keyword validation"
			                };
			                if (vErrors === null) {
			                    vErrors = [err11];
			                }
			                else {
			                    vErrors.push(err11);
			                }
			                errors++;
			            }
			        }
			        if (data.spanningCells !== undefined) {
			            let data13 = data.spanningCells;
			            if (Array.isArray(data13)) {
			                const len0 = data13.length;
			                for (let i0 = 0; i0 < len0; i0++) {
			                    let data14 = data13[i0];
			                    if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
			                        if (data14.row === undefined) {
			                            const err12 = {
			                                instancePath: instancePath + "/spanningCells/" + i0,
			                                schemaPath: "#/properties/spanningCells/items/required",
			                                keyword: "required",
			                                params: {
			                                    missingProperty: "row"
			                                },
			                                message: "must have required property '" + "row" + "'"
			                            };
			                            if (vErrors === null) {
			                                vErrors = [err12];
			                            }
			                            else {
			                                vErrors.push(err12);
			                            }
			                            errors++;
			                        }
			                        if (data14.col === undefined) {
			                            const err13 = {
			                                instancePath: instancePath + "/spanningCells/" + i0,
			                                schemaPath: "#/properties/spanningCells/items/required",
			                                keyword: "required",
			                                params: {
			                                    missingProperty: "col"
			                                },
			                                message: "must have required property '" + "col" + "'"
			                            };
			                            if (vErrors === null) {
			                                vErrors = [err13];
			                            }
			                            else {
			                                vErrors.push(err13);
			                            }
			                            errors++;
			                        }
			                        for (const key2 in data14) {
			                            if (!(func8.call(schema13.properties.spanningCells.items.properties, key2))) {
			                                const err14 = {
			                                    instancePath: instancePath + "/spanningCells/" + i0,
			                                    schemaPath: "#/properties/spanningCells/items/additionalProperties",
			                                    keyword: "additionalProperties",
			                                    params: {
			                                        additionalProperty: key2
			                                    },
			                                    message: "must NOT have additional properties"
			                                };
			                                if (vErrors === null) {
			                                    vErrors = [err14];
			                                }
			                                else {
			                                    vErrors.push(err14);
			                                }
			                                errors++;
			                            }
			                        }
			                        if (data14.col !== undefined) {
			                            let data15 = data14.col;
			                            if (!(((typeof data15 == "number") && (!(data15 % 1) && !isNaN(data15))) && (isFinite(data15)))) {
			                                const err15 = {
			                                    instancePath: instancePath + "/spanningCells/" + i0 + "/col",
			                                    schemaPath: "#/properties/spanningCells/items/properties/col/type",
			                                    keyword: "type",
			                                    params: {
			                                        type: "integer"
			                                    },
			                                    message: "must be integer"
			                                };
			                                if (vErrors === null) {
			                                    vErrors = [err15];
			                                }
			                                else {
			                                    vErrors.push(err15);
			                                }
			                                errors++;
			                            }
			                            if ((typeof data15 == "number") && (isFinite(data15))) {
			                                if (data15 < 0 || isNaN(data15)) {
			                                    const err16 = {
			                                        instancePath: instancePath + "/spanningCells/" + i0 + "/col",
			                                        schemaPath: "#/properties/spanningCells/items/properties/col/minimum",
			                                        keyword: "minimum",
			                                        params: {
			                                            comparison: ">=",
			                                            limit: 0
			                                        },
			                                        message: "must be >= 0"
			                                    };
			                                    if (vErrors === null) {
			                                        vErrors = [err16];
			                                    }
			                                    else {
			                                        vErrors.push(err16);
			                                    }
			                                    errors++;
			                                }
			                            }
			                        }
			                        if (data14.row !== undefined) {
			                            let data16 = data14.row;
			                            if (!(((typeof data16 == "number") && (!(data16 % 1) && !isNaN(data16))) && (isFinite(data16)))) {
			                                const err17 = {
			                                    instancePath: instancePath + "/spanningCells/" + i0 + "/row",
			                                    schemaPath: "#/properties/spanningCells/items/properties/row/type",
			                                    keyword: "type",
			                                    params: {
			                                        type: "integer"
			                                    },
			                                    message: "must be integer"
			                                };
			                                if (vErrors === null) {
			                                    vErrors = [err17];
			                                }
			                                else {
			                                    vErrors.push(err17);
			                                }
			                                errors++;
			                            }
			                            if ((typeof data16 == "number") && (isFinite(data16))) {
			                                if (data16 < 0 || isNaN(data16)) {
			                                    const err18 = {
			                                        instancePath: instancePath + "/spanningCells/" + i0 + "/row",
			                                        schemaPath: "#/properties/spanningCells/items/properties/row/minimum",
			                                        keyword: "minimum",
			                                        params: {
			                                            comparison: ">=",
			                                            limit: 0
			                                        },
			                                        message: "must be >= 0"
			                                    };
			                                    if (vErrors === null) {
			                                        vErrors = [err18];
			                                    }
			                                    else {
			                                        vErrors.push(err18);
			                                    }
			                                    errors++;
			                                }
			                            }
			                        }
			                        if (data14.colSpan !== undefined) {
			                            let data17 = data14.colSpan;
			                            if (!(((typeof data17 == "number") && (!(data17 % 1) && !isNaN(data17))) && (isFinite(data17)))) {
			                                const err19 = {
			                                    instancePath: instancePath + "/spanningCells/" + i0 + "/colSpan",
			                                    schemaPath: "#/properties/spanningCells/items/properties/colSpan/type",
			                                    keyword: "type",
			                                    params: {
			                                        type: "integer"
			                                    },
			                                    message: "must be integer"
			                                };
			                                if (vErrors === null) {
			                                    vErrors = [err19];
			                                }
			                                else {
			                                    vErrors.push(err19);
			                                }
			                                errors++;
			                            }
			                            if ((typeof data17 == "number") && (isFinite(data17))) {
			                                if (data17 < 1 || isNaN(data17)) {
			                                    const err20 = {
			                                        instancePath: instancePath + "/spanningCells/" + i0 + "/colSpan",
			                                        schemaPath: "#/properties/spanningCells/items/properties/colSpan/minimum",
			                                        keyword: "minimum",
			                                        params: {
			                                            comparison: ">=",
			                                            limit: 1
			                                        },
			                                        message: "must be >= 1"
			                                    };
			                                    if (vErrors === null) {
			                                        vErrors = [err20];
			                                    }
			                                    else {
			                                        vErrors.push(err20);
			                                    }
			                                    errors++;
			                                }
			                            }
			                        }
			                        if (data14.rowSpan !== undefined) {
			                            let data18 = data14.rowSpan;
			                            if (!(((typeof data18 == "number") && (!(data18 % 1) && !isNaN(data18))) && (isFinite(data18)))) {
			                                const err21 = {
			                                    instancePath: instancePath + "/spanningCells/" + i0 + "/rowSpan",
			                                    schemaPath: "#/properties/spanningCells/items/properties/rowSpan/type",
			                                    keyword: "type",
			                                    params: {
			                                        type: "integer"
			                                    },
			                                    message: "must be integer"
			                                };
			                                if (vErrors === null) {
			                                    vErrors = [err21];
			                                }
			                                else {
			                                    vErrors.push(err21);
			                                }
			                                errors++;
			                            }
			                            if ((typeof data18 == "number") && (isFinite(data18))) {
			                                if (data18 < 1 || isNaN(data18)) {
			                                    const err22 = {
			                                        instancePath: instancePath + "/spanningCells/" + i0 + "/rowSpan",
			                                        schemaPath: "#/properties/spanningCells/items/properties/rowSpan/minimum",
			                                        keyword: "minimum",
			                                        params: {
			                                            comparison: ">=",
			                                            limit: 1
			                                        },
			                                        message: "must be >= 1"
			                                    };
			                                    if (vErrors === null) {
			                                        vErrors = [err22];
			                                    }
			                                    else {
			                                        vErrors.push(err22);
			                                    }
			                                    errors++;
			                                }
			                            }
			                        }
			                        if (data14.alignment !== undefined) {
			                            if (!(validate68(data14.alignment, {
			                                instancePath: instancePath + "/spanningCells/" + i0 + "/alignment",
			                                parentData: data14,
			                                parentDataProperty: "alignment",
			                                rootData
			                            }))) {
			                                vErrors = vErrors === null ? validate68.errors : vErrors.concat(validate68.errors);
			                                errors = vErrors.length;
			                            }
			                        }
			                        if (data14.verticalAlignment !== undefined) {
			                            if (!(validate84(data14.verticalAlignment, {
			                                instancePath: instancePath + "/spanningCells/" + i0 + "/verticalAlignment",
			                                parentData: data14,
			                                parentDataProperty: "verticalAlignment",
			                                rootData
			                            }))) {
			                                vErrors = vErrors === null ? validate84.errors : vErrors.concat(validate84.errors);
			                                errors = vErrors.length;
			                            }
			                        }
			                        if (data14.wrapWord !== undefined) {
			                            if (typeof data14.wrapWord !== "boolean") {
			                                const err23 = {
			                                    instancePath: instancePath + "/spanningCells/" + i0 + "/wrapWord",
			                                    schemaPath: "#/properties/spanningCells/items/properties/wrapWord/type",
			                                    keyword: "type",
			                                    params: {
			                                        type: "boolean"
			                                    },
			                                    message: "must be boolean"
			                                };
			                                if (vErrors === null) {
			                                    vErrors = [err23];
			                                }
			                                else {
			                                    vErrors.push(err23);
			                                }
			                                errors++;
			                            }
			                        }
			                        if (data14.truncate !== undefined) {
			                            let data22 = data14.truncate;
			                            if (!(((typeof data22 == "number") && (!(data22 % 1) && !isNaN(data22))) && (isFinite(data22)))) {
			                                const err24 = {
			                                    instancePath: instancePath + "/spanningCells/" + i0 + "/truncate",
			                                    schemaPath: "#/properties/spanningCells/items/properties/truncate/type",
			                                    keyword: "type",
			                                    params: {
			                                        type: "integer"
			                                    },
			                                    message: "must be integer"
			                                };
			                                if (vErrors === null) {
			                                    vErrors = [err24];
			                                }
			                                else {
			                                    vErrors.push(err24);
			                                }
			                                errors++;
			                            }
			                        }
			                        if (data14.paddingLeft !== undefined) {
			                            let data23 = data14.paddingLeft;
			                            if (!(((typeof data23 == "number") && (!(data23 % 1) && !isNaN(data23))) && (isFinite(data23)))) {
			                                const err25 = {
			                                    instancePath: instancePath + "/spanningCells/" + i0 + "/paddingLeft",
			                                    schemaPath: "#/properties/spanningCells/items/properties/paddingLeft/type",
			                                    keyword: "type",
			                                    params: {
			                                        type: "integer"
			                                    },
			                                    message: "must be integer"
			                                };
			                                if (vErrors === null) {
			                                    vErrors = [err25];
			                                }
			                                else {
			                                    vErrors.push(err25);
			                                }
			                                errors++;
			                            }
			                        }
			                        if (data14.paddingRight !== undefined) {
			                            let data24 = data14.paddingRight;
			                            if (!(((typeof data24 == "number") && (!(data24 % 1) && !isNaN(data24))) && (isFinite(data24)))) {
			                                const err26 = {
			                                    instancePath: instancePath + "/spanningCells/" + i0 + "/paddingRight",
			                                    schemaPath: "#/properties/spanningCells/items/properties/paddingRight/type",
			                                    keyword: "type",
			                                    params: {
			                                        type: "integer"
			                                    },
			                                    message: "must be integer"
			                                };
			                                if (vErrors === null) {
			                                    vErrors = [err26];
			                                }
			                                else {
			                                    vErrors.push(err26);
			                                }
			                                errors++;
			                            }
			                        }
			                    }
			                    else {
			                        const err27 = {
			                            instancePath: instancePath + "/spanningCells/" + i0,
			                            schemaPath: "#/properties/spanningCells/items/type",
			                            keyword: "type",
			                            params: {
			                                type: "object"
			                            },
			                            message: "must be object"
			                        };
			                        if (vErrors === null) {
			                            vErrors = [err27];
			                        }
			                        else {
			                            vErrors.push(err27);
			                        }
			                        errors++;
			                    }
			                }
			            }
			            else {
			                const err28 = {
			                    instancePath: instancePath + "/spanningCells",
			                    schemaPath: "#/properties/spanningCells/type",
			                    keyword: "type",
			                    params: {
			                        type: "array"
			                    },
			                    message: "must be array"
			                };
			                if (vErrors === null) {
			                    vErrors = [err28];
			                }
			                else {
			                    vErrors.push(err28);
			                }
			                errors++;
			            }
			        }
			    }
			    else {
			        const err29 = {
			            instancePath,
			            schemaPath: "#/type",
			            keyword: "type",
			            params: {
			                type: "object"
			            },
			            message: "must be object"
			        };
			        if (vErrors === null) {
			            vErrors = [err29];
			        }
			        else {
			            vErrors.push(err29);
			        }
			        errors++;
			    }
			    validate43.errors = vErrors;
			    return errors === 0;
			}
			exports["streamConfig.json"] = validate86;
			function validate87(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    if (data && typeof data == "object" && !Array.isArray(data)) {
			        for (const key0 in data) {
			            if (!(func8.call(schema15.properties, key0))) {
			                const err0 = {
			                    instancePath,
			                    schemaPath: "#/additionalProperties",
			                    keyword: "additionalProperties",
			                    params: {
			                        additionalProperty: key0
			                    },
			                    message: "must NOT have additional properties"
			                };
			                if (vErrors === null) {
			                    vErrors = [err0];
			                }
			                else {
			                    vErrors.push(err0);
			                }
			                errors++;
			            }
			        }
			        if (data.topBody !== undefined) {
			            if (!(validate46(data.topBody, {
			                instancePath: instancePath + "/topBody",
			                parentData: data,
			                parentDataProperty: "topBody",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.topJoin !== undefined) {
			            if (!(validate46(data.topJoin, {
			                instancePath: instancePath + "/topJoin",
			                parentData: data,
			                parentDataProperty: "topJoin",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.topLeft !== undefined) {
			            if (!(validate46(data.topLeft, {
			                instancePath: instancePath + "/topLeft",
			                parentData: data,
			                parentDataProperty: "topLeft",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.topRight !== undefined) {
			            if (!(validate46(data.topRight, {
			                instancePath: instancePath + "/topRight",
			                parentData: data,
			                parentDataProperty: "topRight",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bottomBody !== undefined) {
			            if (!(validate46(data.bottomBody, {
			                instancePath: instancePath + "/bottomBody",
			                parentData: data,
			                parentDataProperty: "bottomBody",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bottomJoin !== undefined) {
			            if (!(validate46(data.bottomJoin, {
			                instancePath: instancePath + "/bottomJoin",
			                parentData: data,
			                parentDataProperty: "bottomJoin",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bottomLeft !== undefined) {
			            if (!(validate46(data.bottomLeft, {
			                instancePath: instancePath + "/bottomLeft",
			                parentData: data,
			                parentDataProperty: "bottomLeft",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bottomRight !== undefined) {
			            if (!(validate46(data.bottomRight, {
			                instancePath: instancePath + "/bottomRight",
			                parentData: data,
			                parentDataProperty: "bottomRight",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bodyLeft !== undefined) {
			            if (!(validate46(data.bodyLeft, {
			                instancePath: instancePath + "/bodyLeft",
			                parentData: data,
			                parentDataProperty: "bodyLeft",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bodyRight !== undefined) {
			            if (!(validate46(data.bodyRight, {
			                instancePath: instancePath + "/bodyRight",
			                parentData: data,
			                parentDataProperty: "bodyRight",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.bodyJoin !== undefined) {
			            if (!(validate46(data.bodyJoin, {
			                instancePath: instancePath + "/bodyJoin",
			                parentData: data,
			                parentDataProperty: "bodyJoin",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.headerJoin !== undefined) {
			            if (!(validate46(data.headerJoin, {
			                instancePath: instancePath + "/headerJoin",
			                parentData: data,
			                parentDataProperty: "headerJoin",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinBody !== undefined) {
			            if (!(validate46(data.joinBody, {
			                instancePath: instancePath + "/joinBody",
			                parentData: data,
			                parentDataProperty: "joinBody",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinLeft !== undefined) {
			            if (!(validate46(data.joinLeft, {
			                instancePath: instancePath + "/joinLeft",
			                parentData: data,
			                parentDataProperty: "joinLeft",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinRight !== undefined) {
			            if (!(validate46(data.joinRight, {
			                instancePath: instancePath + "/joinRight",
			                parentData: data,
			                parentDataProperty: "joinRight",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinJoin !== undefined) {
			            if (!(validate46(data.joinJoin, {
			                instancePath: instancePath + "/joinJoin",
			                parentData: data,
			                parentDataProperty: "joinJoin",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinMiddleUp !== undefined) {
			            if (!(validate46(data.joinMiddleUp, {
			                instancePath: instancePath + "/joinMiddleUp",
			                parentData: data,
			                parentDataProperty: "joinMiddleUp",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinMiddleDown !== undefined) {
			            if (!(validate46(data.joinMiddleDown, {
			                instancePath: instancePath + "/joinMiddleDown",
			                parentData: data,
			                parentDataProperty: "joinMiddleDown",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinMiddleLeft !== undefined) {
			            if (!(validate46(data.joinMiddleLeft, {
			                instancePath: instancePath + "/joinMiddleLeft",
			                parentData: data,
			                parentDataProperty: "joinMiddleLeft",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.joinMiddleRight !== undefined) {
			            if (!(validate46(data.joinMiddleRight, {
			                instancePath: instancePath + "/joinMiddleRight",
			                parentData: data,
			                parentDataProperty: "joinMiddleRight",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
			                errors = vErrors.length;
			            }
			        }
			    }
			    else {
			        const err1 = {
			            instancePath,
			            schemaPath: "#/type",
			            keyword: "type",
			            params: {
			                type: "object"
			            },
			            message: "must be object"
			        };
			        if (vErrors === null) {
			            vErrors = [err1];
			        }
			        else {
			            vErrors.push(err1);
			        }
			        errors++;
			    }
			    validate87.errors = vErrors;
			    return errors === 0;
			}
			function validate109(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    const _errs0 = errors;
			    let valid0 = false;
			    let passing0 = null;
			    const _errs1 = errors;
			    if (data && typeof data == "object" && !Array.isArray(data)) {
			        for (const key0 in data) {
			            if (!(pattern0.test(key0))) {
			                const err0 = {
			                    instancePath,
			                    schemaPath: "#/oneOf/0/additionalProperties",
			                    keyword: "additionalProperties",
			                    params: {
			                        additionalProperty: key0
			                    },
			                    message: "must NOT have additional properties"
			                };
			                if (vErrors === null) {
			                    vErrors = [err0];
			                }
			                else {
			                    vErrors.push(err0);
			                }
			                errors++;
			            }
			        }
			        for (const key1 in data) {
			            if (pattern0.test(key1)) {
			                if (!(validate71(data[key1], {
			                    instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"),
			                    parentData: data,
			                    parentDataProperty: key1,
			                    rootData
			                }))) {
			                    vErrors = vErrors === null ? validate71.errors : vErrors.concat(validate71.errors);
			                    errors = vErrors.length;
			                }
			            }
			        }
			    }
			    else {
			        const err1 = {
			            instancePath,
			            schemaPath: "#/oneOf/0/type",
			            keyword: "type",
			            params: {
			                type: "object"
			            },
			            message: "must be object"
			        };
			        if (vErrors === null) {
			            vErrors = [err1];
			        }
			        else {
			            vErrors.push(err1);
			        }
			        errors++;
			    }
			    var _valid0 = _errs1 === errors;
			    if (_valid0) {
			        valid0 = true;
			        passing0 = 0;
			    }
			    const _errs5 = errors;
			    if (Array.isArray(data)) {
			        const len0 = data.length;
			        for (let i0 = 0; i0 < len0; i0++) {
			            if (!(validate71(data[i0], {
			                instancePath: instancePath + "/" + i0,
			                parentData: data,
			                parentDataProperty: i0,
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate71.errors : vErrors.concat(validate71.errors);
			                errors = vErrors.length;
			            }
			        }
			    }
			    else {
			        const err2 = {
			            instancePath,
			            schemaPath: "#/oneOf/1/type",
			            keyword: "type",
			            params: {
			                type: "array"
			            },
			            message: "must be array"
			        };
			        if (vErrors === null) {
			            vErrors = [err2];
			        }
			        else {
			            vErrors.push(err2);
			        }
			        errors++;
			    }
			    var _valid0 = _errs5 === errors;
			    if (_valid0 && valid0) {
			        valid0 = false;
			        passing0 = [passing0, 1];
			    }
			    else {
			        if (_valid0) {
			            valid0 = true;
			            passing0 = 1;
			        }
			    }
			    if (!valid0) {
			        const err3 = {
			            instancePath,
			            schemaPath: "#/oneOf",
			            keyword: "oneOf",
			            params: {
			                passingSchemas: passing0
			            },
			            message: "must match exactly one schema in oneOf"
			        };
			        if (vErrors === null) {
			            vErrors = [err3];
			        }
			        else {
			            vErrors.push(err3);
			        }
			        errors++;
			    }
			    else {
			        errors = _errs0;
			        if (vErrors !== null) {
			            if (_errs0) {
			                vErrors.length = _errs0;
			            }
			            else {
			                vErrors = null;
			            }
			        }
			    }
			    validate109.errors = vErrors;
			    return errors === 0;
			}
			function validate113(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    if (data && typeof data == "object" && !Array.isArray(data)) {
			        for (const key0 in data) {
			            if (!(((((((key0 === "alignment") || (key0 === "verticalAlignment")) || (key0 === "width")) || (key0 === "wrapWord")) || (key0 === "truncate")) || (key0 === "paddingLeft")) || (key0 === "paddingRight"))) {
			                const err0 = {
			                    instancePath,
			                    schemaPath: "#/additionalProperties",
			                    keyword: "additionalProperties",
			                    params: {
			                        additionalProperty: key0
			                    },
			                    message: "must NOT have additional properties"
			                };
			                if (vErrors === null) {
			                    vErrors = [err0];
			                }
			                else {
			                    vErrors.push(err0);
			                }
			                errors++;
			            }
			        }
			        if (data.alignment !== undefined) {
			            if (!(validate72(data.alignment, {
			                instancePath: instancePath + "/alignment",
			                parentData: data,
			                parentDataProperty: "alignment",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate72.errors : vErrors.concat(validate72.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.verticalAlignment !== undefined) {
			            if (!(validate74(data.verticalAlignment, {
			                instancePath: instancePath + "/verticalAlignment",
			                parentData: data,
			                parentDataProperty: "verticalAlignment",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate74.errors : vErrors.concat(validate74.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.width !== undefined) {
			            let data2 = data.width;
			            if (!(((typeof data2 == "number") && (!(data2 % 1) && !isNaN(data2))) && (isFinite(data2)))) {
			                const err1 = {
			                    instancePath: instancePath + "/width",
			                    schemaPath: "#/properties/width/type",
			                    keyword: "type",
			                    params: {
			                        type: "integer"
			                    },
			                    message: "must be integer"
			                };
			                if (vErrors === null) {
			                    vErrors = [err1];
			                }
			                else {
			                    vErrors.push(err1);
			                }
			                errors++;
			            }
			            if ((typeof data2 == "number") && (isFinite(data2))) {
			                if (data2 < 1 || isNaN(data2)) {
			                    const err2 = {
			                        instancePath: instancePath + "/width",
			                        schemaPath: "#/properties/width/minimum",
			                        keyword: "minimum",
			                        params: {
			                            comparison: ">=",
			                            limit: 1
			                        },
			                        message: "must be >= 1"
			                    };
			                    if (vErrors === null) {
			                        vErrors = [err2];
			                    }
			                    else {
			                        vErrors.push(err2);
			                    }
			                    errors++;
			                }
			            }
			        }
			        if (data.wrapWord !== undefined) {
			            if (typeof data.wrapWord !== "boolean") {
			                const err3 = {
			                    instancePath: instancePath + "/wrapWord",
			                    schemaPath: "#/properties/wrapWord/type",
			                    keyword: "type",
			                    params: {
			                        type: "boolean"
			                    },
			                    message: "must be boolean"
			                };
			                if (vErrors === null) {
			                    vErrors = [err3];
			                }
			                else {
			                    vErrors.push(err3);
			                }
			                errors++;
			            }
			        }
			        if (data.truncate !== undefined) {
			            let data4 = data.truncate;
			            if (!(((typeof data4 == "number") && (!(data4 % 1) && !isNaN(data4))) && (isFinite(data4)))) {
			                const err4 = {
			                    instancePath: instancePath + "/truncate",
			                    schemaPath: "#/properties/truncate/type",
			                    keyword: "type",
			                    params: {
			                        type: "integer"
			                    },
			                    message: "must be integer"
			                };
			                if (vErrors === null) {
			                    vErrors = [err4];
			                }
			                else {
			                    vErrors.push(err4);
			                }
			                errors++;
			            }
			        }
			        if (data.paddingLeft !== undefined) {
			            let data5 = data.paddingLeft;
			            if (!(((typeof data5 == "number") && (!(data5 % 1) && !isNaN(data5))) && (isFinite(data5)))) {
			                const err5 = {
			                    instancePath: instancePath + "/paddingLeft",
			                    schemaPath: "#/properties/paddingLeft/type",
			                    keyword: "type",
			                    params: {
			                        type: "integer"
			                    },
			                    message: "must be integer"
			                };
			                if (vErrors === null) {
			                    vErrors = [err5];
			                }
			                else {
			                    vErrors.push(err5);
			                }
			                errors++;
			            }
			        }
			        if (data.paddingRight !== undefined) {
			            let data6 = data.paddingRight;
			            if (!(((typeof data6 == "number") && (!(data6 % 1) && !isNaN(data6))) && (isFinite(data6)))) {
			                const err6 = {
			                    instancePath: instancePath + "/paddingRight",
			                    schemaPath: "#/properties/paddingRight/type",
			                    keyword: "type",
			                    params: {
			                        type: "integer"
			                    },
			                    message: "must be integer"
			                };
			                if (vErrors === null) {
			                    vErrors = [err6];
			                }
			                else {
			                    vErrors.push(err6);
			                }
			                errors++;
			            }
			        }
			    }
			    else {
			        const err7 = {
			            instancePath,
			            schemaPath: "#/type",
			            keyword: "type",
			            params: {
			                type: "object"
			            },
			            message: "must be object"
			        };
			        if (vErrors === null) {
			            vErrors = [err7];
			        }
			        else {
			            vErrors.push(err7);
			        }
			        errors++;
			    }
			    validate113.errors = vErrors;
			    return errors === 0;
			}
			function validate86(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
			    let vErrors = null;
			    let errors = 0;
			    if (data && typeof data == "object" && !Array.isArray(data)) {
			        if (data.columnDefault === undefined) {
			            const err0 = {
			                instancePath,
			                schemaPath: "#/required",
			                keyword: "required",
			                params: {
			                    missingProperty: "columnDefault"
			                },
			                message: "must have required property '" + "columnDefault" + "'"
			            };
			            if (vErrors === null) {
			                vErrors = [err0];
			            }
			            else {
			                vErrors.push(err0);
			            }
			            errors++;
			        }
			        if (data.columnCount === undefined) {
			            const err1 = {
			                instancePath,
			                schemaPath: "#/required",
			                keyword: "required",
			                params: {
			                    missingProperty: "columnCount"
			                },
			                message: "must have required property '" + "columnCount" + "'"
			            };
			            if (vErrors === null) {
			                vErrors = [err1];
			            }
			            else {
			                vErrors.push(err1);
			            }
			            errors++;
			        }
			        for (const key0 in data) {
			            if (!(((((key0 === "border") || (key0 === "columns")) || (key0 === "columnDefault")) || (key0 === "columnCount")) || (key0 === "drawVerticalLine"))) {
			                const err2 = {
			                    instancePath,
			                    schemaPath: "#/additionalProperties",
			                    keyword: "additionalProperties",
			                    params: {
			                        additionalProperty: key0
			                    },
			                    message: "must NOT have additional properties"
			                };
			                if (vErrors === null) {
			                    vErrors = [err2];
			                }
			                else {
			                    vErrors.push(err2);
			                }
			                errors++;
			            }
			        }
			        if (data.border !== undefined) {
			            if (!(validate87(data.border, {
			                instancePath: instancePath + "/border",
			                parentData: data,
			                parentDataProperty: "border",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate87.errors : vErrors.concat(validate87.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.columns !== undefined) {
			            if (!(validate109(data.columns, {
			                instancePath: instancePath + "/columns",
			                parentData: data,
			                parentDataProperty: "columns",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate109.errors : vErrors.concat(validate109.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.columnDefault !== undefined) {
			            if (!(validate113(data.columnDefault, {
			                instancePath: instancePath + "/columnDefault",
			                parentData: data,
			                parentDataProperty: "columnDefault",
			                rootData
			            }))) {
			                vErrors = vErrors === null ? validate113.errors : vErrors.concat(validate113.errors);
			                errors = vErrors.length;
			            }
			        }
			        if (data.columnCount !== undefined) {
			            let data3 = data.columnCount;
			            if (!(((typeof data3 == "number") && (!(data3 % 1) && !isNaN(data3))) && (isFinite(data3)))) {
			                const err3 = {
			                    instancePath: instancePath + "/columnCount",
			                    schemaPath: "#/properties/columnCount/type",
			                    keyword: "type",
			                    params: {
			                        type: "integer"
			                    },
			                    message: "must be integer"
			                };
			                if (vErrors === null) {
			                    vErrors = [err3];
			                }
			                else {
			                    vErrors.push(err3);
			                }
			                errors++;
			            }
			            if ((typeof data3 == "number") && (isFinite(data3))) {
			                if (data3 < 1 || isNaN(data3)) {
			                    const err4 = {
			                        instancePath: instancePath + "/columnCount",
			                        schemaPath: "#/properties/columnCount/minimum",
			                        keyword: "minimum",
			                        params: {
			                            comparison: ">=",
			                            limit: 1
			                        },
			                        message: "must be >= 1"
			                    };
			                    if (vErrors === null) {
			                        vErrors = [err4];
			                    }
			                    else {
			                        vErrors.push(err4);
			                    }
			                    errors++;
			                }
			            }
			        }
			        if (data.drawVerticalLine !== undefined) {
			            if (typeof data.drawVerticalLine != "function") {
			                const err5 = {
			                    instancePath: instancePath + "/drawVerticalLine",
			                    schemaPath: "#/properties/drawVerticalLine/typeof",
			                    keyword: "typeof",
			                    params: {},
			                    message: "must pass \"typeof\" keyword validation"
			                };
			                if (vErrors === null) {
			                    vErrors = [err5];
			                }
			                else {
			                    vErrors.push(err5);
			                }
			                errors++;
			            }
			        }
			    }
			    else {
			        const err6 = {
			            instancePath,
			            schemaPath: "#/type",
			            keyword: "type",
			            params: {
			                type: "object"
			            },
			            message: "must be object"
			        };
			        if (vErrors === null) {
			            vErrors = [err6];
			        }
			        else {
			            vErrors.push(err6);
			        }
			        errors++;
			    }
			    validate86.errors = vErrors;
			    return errors === 0;
			}
			
		} (validators));
		return validators;
	}

	var hasRequiredValidateConfig;

	function requireValidateConfig () {
		if (hasRequiredValidateConfig) return validateConfig;
		hasRequiredValidateConfig = 1;
		var __importDefault = (validateConfig && validateConfig.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(validateConfig, "__esModule", { value: true });
		validateConfig.validateConfig = void 0;
		const validators_1 = __importDefault(/*@__PURE__*/ requireValidators());
		const validateConfig$1 = (schemaId, config) => {
		    const validate = validators_1.default[schemaId];
		    if (!validate(config) && validate.errors) {
		        // eslint-disable-next-line promise/prefer-await-to-callbacks
		        const errors = validate.errors.map((error) => {
		            return {
		                message: error.message,
		                params: error.params,
		                schemaPath: error.schemaPath,
		            };
		        });
		        /* eslint-disable no-console */
		        console.log('config', config);
		        console.log('errors', errors);
		        /* eslint-enable no-console */
		        throw new Error('Invalid config.');
		    }
		};
		validateConfig.validateConfig = validateConfig$1;
		
		return validateConfig;
	}

	var hasRequiredMakeStreamConfig;

	function requireMakeStreamConfig () {
		if (hasRequiredMakeStreamConfig) return makeStreamConfig;
		hasRequiredMakeStreamConfig = 1;
		Object.defineProperty(makeStreamConfig, "__esModule", { value: true });
		makeStreamConfig.makeStreamConfig = void 0;
		const utils_1 = /*@__PURE__*/ requireUtils();
		const validateConfig_1 = /*@__PURE__*/ requireValidateConfig();
		/**
		 * Creates a configuration for every column using default
		 * values for the missing configuration properties.
		 */
		const makeColumnsConfig = (columnCount, columns = {}, columnDefault) => {
		    return Array.from({ length: columnCount }).map((_, index) => {
		        return {
		            alignment: 'left',
		            paddingLeft: 1,
		            paddingRight: 1,
		            truncate: Number.POSITIVE_INFINITY,
		            verticalAlignment: 'top',
		            wrapWord: false,
		            ...columnDefault,
		            ...columns[index],
		        };
		    });
		};
		/**
		 * Makes a new configuration object out of the userConfig object
		 * using default values for the missing configuration properties.
		 */
		const makeStreamConfig$1 = (config) => {
		    (0, validateConfig_1.validateConfig)('streamConfig.json', config);
		    if (config.columnDefault.width === undefined) {
		        throw new Error('Must provide config.columnDefault.width when creating a stream.');
		    }
		    return {
		        drawVerticalLine: () => {
		            return true;
		        },
		        ...config,
		        border: (0, utils_1.makeBorderConfig)(config.border),
		        columns: makeColumnsConfig(config.columnCount, config.columns, config.columnDefault),
		    };
		};
		makeStreamConfig.makeStreamConfig = makeStreamConfig$1;
		
		return makeStreamConfig;
	}

	var mapDataUsingRowHeights = {};

	var hasRequiredMapDataUsingRowHeights;

	function requireMapDataUsingRowHeights () {
		if (hasRequiredMapDataUsingRowHeights) return mapDataUsingRowHeights;
		hasRequiredMapDataUsingRowHeights = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.mapDataUsingRowHeights = exports.padCellVertically = void 0;
			const utils_1 = /*@__PURE__*/ requireUtils();
			const wrapCell_1 = /*@__PURE__*/ requireWrapCell();
			const createEmptyStrings = (length) => {
			    return new Array(length).fill('');
			};
			const padCellVertically = (lines, rowHeight, verticalAlignment) => {
			    const availableLines = rowHeight - lines.length;
			    if (verticalAlignment === 'top') {
			        return [...lines, ...createEmptyStrings(availableLines)];
			    }
			    if (verticalAlignment === 'bottom') {
			        return [...createEmptyStrings(availableLines), ...lines];
			    }
			    return [
			        ...createEmptyStrings(Math.floor(availableLines / 2)),
			        ...lines,
			        ...createEmptyStrings(Math.ceil(availableLines / 2)),
			    ];
			};
			exports.padCellVertically = padCellVertically;
			const mapDataUsingRowHeights = (unmappedRows, rowHeights, config) => {
			    const nColumns = unmappedRows[0].length;
			    const mappedRows = unmappedRows.map((unmappedRow, unmappedRowIndex) => {
			        const outputRowHeight = rowHeights[unmappedRowIndex];
			        const outputRow = Array.from({ length: outputRowHeight }, () => {
			            return new Array(nColumns).fill('');
			        });
			        unmappedRow.forEach((cell, cellIndex) => {
			            var _a;
			            const containingRange = (_a = config.spanningCellManager) === null || _a === void 0 ? void 0 : _a.getContainingRange({ col: cellIndex,
			                row: unmappedRowIndex });
			            if (containingRange) {
			                containingRange.extractCellContent(unmappedRowIndex).forEach((cellLine, cellLineIndex) => {
			                    outputRow[cellLineIndex][cellIndex] = cellLine;
			                });
			                return;
			            }
			            const cellLines = (0, wrapCell_1.wrapCell)(cell, config.columns[cellIndex].width, config.columns[cellIndex].wrapWord);
			            const paddedCellLines = (0, exports.padCellVertically)(cellLines, outputRowHeight, config.columns[cellIndex].verticalAlignment);
			            paddedCellLines.forEach((cellLine, cellLineIndex) => {
			                outputRow[cellLineIndex][cellIndex] = cellLine;
			            });
			        });
			        return outputRow;
			    });
			    return (0, utils_1.flatten)(mappedRows);
			};
			exports.mapDataUsingRowHeights = mapDataUsingRowHeights;
			
		} (mapDataUsingRowHeights));
		return mapDataUsingRowHeights;
	}

	var padTableData = {};

	var hasRequiredPadTableData;

	function requirePadTableData () {
		if (hasRequiredPadTableData) return padTableData;
		hasRequiredPadTableData = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.padTableData = exports.padString = void 0;
			const padString = (input, paddingLeft, paddingRight) => {
			    return ' '.repeat(paddingLeft) + input + ' '.repeat(paddingRight);
			};
			exports.padString = padString;
			const padTableData = (rows, config) => {
			    return rows.map((cells, rowIndex) => {
			        return cells.map((cell, cellIndex) => {
			            var _a;
			            const containingRange = (_a = config.spanningCellManager) === null || _a === void 0 ? void 0 : _a.getContainingRange({ col: cellIndex,
			                row: rowIndex }, { mapped: true });
			            if (containingRange) {
			                return cell;
			            }
			            const { paddingLeft, paddingRight } = config.columns[cellIndex];
			            return (0, exports.padString)(cell, paddingLeft, paddingRight);
			        });
			    });
			};
			exports.padTableData = padTableData;
			
		} (padTableData));
		return padTableData;
	}

	var stringifyTableData = {};

	var hasRequiredStringifyTableData;

	function requireStringifyTableData () {
		if (hasRequiredStringifyTableData) return stringifyTableData;
		hasRequiredStringifyTableData = 1;
		Object.defineProperty(stringifyTableData, "__esModule", { value: true });
		stringifyTableData.stringifyTableData = void 0;
		const utils_1 = /*@__PURE__*/ requireUtils();
		const stringifyTableData$1 = (rows) => {
		    return rows.map((cells) => {
		        return cells.map((cell) => {
		            return (0, utils_1.normalizeString)(String(cell));
		        });
		    });
		};
		stringifyTableData.stringifyTableData = stringifyTableData$1;
		
		return stringifyTableData;
	}

	var truncateTableData = {};

	var lodash_truncate = {exports: {}};

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	lodash_truncate.exports;

	var hasRequiredLodash_truncate;

	function requireLodash_truncate () {
		if (hasRequiredLodash_truncate) return lodash_truncate.exports;
		hasRequiredLodash_truncate = 1;
		(function (module, exports) {
			/** Used as default options for `_.truncate`. */
			var DEFAULT_TRUNC_LENGTH = 30,
			    DEFAULT_TRUNC_OMISSION = '...';

			/** Used as references for various `Number` constants. */
			var INFINITY = 1 / 0,
			    MAX_INTEGER = 1.7976931348623157e+308,
			    NAN = 0 / 0;

			/** `Object#toString` result references. */
			var regexpTag = '[object RegExp]',
			    symbolTag = '[object Symbol]';

			/** Used to match leading and trailing whitespace. */
			var reTrim = /^\s+|\s+$/g;

			/** Used to match `RegExp` flags from their coerced string values. */
			var reFlags = /\w*$/;

			/** Used to detect bad signed hexadecimal string values. */
			var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

			/** Used to detect binary string values. */
			var reIsBinary = /^0b[01]+$/i;

			/** Used to detect octal string values. */
			var reIsOctal = /^0o[0-7]+$/i;

			/** Used to compose unicode character classes. */
			var rsAstralRange = '\\ud800-\\udfff',
			    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
			    rsComboSymbolsRange = '\\u20d0-\\u20f0',
			    rsVarRange = '\\ufe0e\\ufe0f';

			/** Used to compose unicode capture groups. */
			var rsAstral = '[' + rsAstralRange + ']',
			    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
			    rsFitz = '\\ud83c[\\udffb-\\udfff]',
			    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
			    rsNonAstral = '[^' + rsAstralRange + ']',
			    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
			    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
			    rsZWJ = '\\u200d';

			/** Used to compose unicode regexes. */
			var reOptMod = rsModifier + '?',
			    rsOptVar = '[' + rsVarRange + ']?',
			    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
			    rsSeq = rsOptVar + reOptMod + rsOptJoin,
			    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

			/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
			var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

			/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
			var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

			/** Built-in method references without a dependency on `root`. */
			var freeParseInt = parseInt;

			/** Detect free variable `global` from Node.js. */
			var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

			/** Detect free variable `self`. */
			var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

			/** Used as a reference to the global object. */
			var root = freeGlobal || freeSelf || Function('return this')();

			/** Detect free variable `exports`. */
			var freeExports = exports && !exports.nodeType && exports;

			/** Detect free variable `module`. */
			var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

			/** Detect the popular CommonJS extension `module.exports`. */
			var moduleExports = freeModule && freeModule.exports === freeExports;

			/** Detect free variable `process` from Node.js. */
			var freeProcess = moduleExports && freeGlobal.process;

			/** Used to access faster Node.js helpers. */
			var nodeUtil = (function() {
			  try {
			    return freeProcess && freeProcess.binding('util');
			  } catch (e) {}
			}());

			/* Node.js helper references. */
			var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

			/**
			 * Gets the size of an ASCII `string`.
			 *
			 * @private
			 * @param {string} string The string inspect.
			 * @returns {number} Returns the string size.
			 */
			var asciiSize = baseProperty('length');

			/**
			 * Converts an ASCII `string` to an array.
			 *
			 * @private
			 * @param {string} string The string to convert.
			 * @returns {Array} Returns the converted array.
			 */
			function asciiToArray(string) {
			  return string.split('');
			}

			/**
			 * The base implementation of `_.property` without support for deep paths.
			 *
			 * @private
			 * @param {string} key The key of the property to get.
			 * @returns {Function} Returns the new accessor function.
			 */
			function baseProperty(key) {
			  return function(object) {
			    return object == null ? undefined : object[key];
			  };
			}

			/**
			 * The base implementation of `_.unary` without support for storing metadata.
			 *
			 * @private
			 * @param {Function} func The function to cap arguments for.
			 * @returns {Function} Returns the new capped function.
			 */
			function baseUnary(func) {
			  return function(value) {
			    return func(value);
			  };
			}

			/**
			 * Checks if `string` contains Unicode symbols.
			 *
			 * @private
			 * @param {string} string The string to inspect.
			 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
			 */
			function hasUnicode(string) {
			  return reHasUnicode.test(string);
			}

			/**
			 * Gets the number of symbols in `string`.
			 *
			 * @private
			 * @param {string} string The string to inspect.
			 * @returns {number} Returns the string size.
			 */
			function stringSize(string) {
			  return hasUnicode(string)
			    ? unicodeSize(string)
			    : asciiSize(string);
			}

			/**
			 * Converts `string` to an array.
			 *
			 * @private
			 * @param {string} string The string to convert.
			 * @returns {Array} Returns the converted array.
			 */
			function stringToArray(string) {
			  return hasUnicode(string)
			    ? unicodeToArray(string)
			    : asciiToArray(string);
			}

			/**
			 * Gets the size of a Unicode `string`.
			 *
			 * @private
			 * @param {string} string The string inspect.
			 * @returns {number} Returns the string size.
			 */
			function unicodeSize(string) {
			  var result = reUnicode.lastIndex = 0;
			  while (reUnicode.test(string)) {
			    result++;
			  }
			  return result;
			}

			/**
			 * Converts a Unicode `string` to an array.
			 *
			 * @private
			 * @param {string} string The string to convert.
			 * @returns {Array} Returns the converted array.
			 */
			function unicodeToArray(string) {
			  return string.match(reUnicode) || [];
			}

			/** Used for built-in method references. */
			var objectProto = Object.prototype;

			/**
			 * Used to resolve the
			 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
			 * of values.
			 */
			var objectToString = objectProto.toString;

			/** Built-in value references. */
			var Symbol = root.Symbol;

			/** Used to convert symbols to primitives and strings. */
			var symbolProto = Symbol ? Symbol.prototype : undefined,
			    symbolToString = symbolProto ? symbolProto.toString : undefined;

			/**
			 * The base implementation of `_.isRegExp` without Node.js optimizations.
			 *
			 * @private
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
			 */
			function baseIsRegExp(value) {
			  return isObject(value) && objectToString.call(value) == regexpTag;
			}

			/**
			 * The base implementation of `_.slice` without an iteratee call guard.
			 *
			 * @private
			 * @param {Array} array The array to slice.
			 * @param {number} [start=0] The start position.
			 * @param {number} [end=array.length] The end position.
			 * @returns {Array} Returns the slice of `array`.
			 */
			function baseSlice(array, start, end) {
			  var index = -1,
			      length = array.length;

			  if (start < 0) {
			    start = -start > length ? 0 : (length + start);
			  }
			  end = end > length ? length : end;
			  if (end < 0) {
			    end += length;
			  }
			  length = start > end ? 0 : ((end - start) >>> 0);
			  start >>>= 0;

			  var result = Array(length);
			  while (++index < length) {
			    result[index] = array[index + start];
			  }
			  return result;
			}

			/**
			 * The base implementation of `_.toString` which doesn't convert nullish
			 * values to empty strings.
			 *
			 * @private
			 * @param {*} value The value to process.
			 * @returns {string} Returns the string.
			 */
			function baseToString(value) {
			  // Exit early for strings to avoid a performance hit in some environments.
			  if (typeof value == 'string') {
			    return value;
			  }
			  if (isSymbol(value)) {
			    return symbolToString ? symbolToString.call(value) : '';
			  }
			  var result = (value + '');
			  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
			}

			/**
			 * Casts `array` to a slice if it's needed.
			 *
			 * @private
			 * @param {Array} array The array to inspect.
			 * @param {number} start The start position.
			 * @param {number} [end=array.length] The end position.
			 * @returns {Array} Returns the cast slice.
			 */
			function castSlice(array, start, end) {
			  var length = array.length;
			  end = end === undefined ? length : end;
			  return (!start && end >= length) ? array : baseSlice(array, start, end);
			}

			/**
			 * Checks if `value` is the
			 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
			 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
			 *
			 * @static
			 * @memberOf _
			 * @since 0.1.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
			 * @example
			 *
			 * _.isObject({});
			 * // => true
			 *
			 * _.isObject([1, 2, 3]);
			 * // => true
			 *
			 * _.isObject(_.noop);
			 * // => true
			 *
			 * _.isObject(null);
			 * // => false
			 */
			function isObject(value) {
			  var type = typeof value;
			  return !!value && (type == 'object' || type == 'function');
			}

			/**
			 * Checks if `value` is object-like. A value is object-like if it's not `null`
			 * and has a `typeof` result of "object".
			 *
			 * @static
			 * @memberOf _
			 * @since 4.0.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
			 * @example
			 *
			 * _.isObjectLike({});
			 * // => true
			 *
			 * _.isObjectLike([1, 2, 3]);
			 * // => true
			 *
			 * _.isObjectLike(_.noop);
			 * // => false
			 *
			 * _.isObjectLike(null);
			 * // => false
			 */
			function isObjectLike(value) {
			  return !!value && typeof value == 'object';
			}

			/**
			 * Checks if `value` is classified as a `RegExp` object.
			 *
			 * @static
			 * @memberOf _
			 * @since 0.1.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
			 * @example
			 *
			 * _.isRegExp(/abc/);
			 * // => true
			 *
			 * _.isRegExp('/abc/');
			 * // => false
			 */
			var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

			/**
			 * Checks if `value` is classified as a `Symbol` primitive or object.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.0.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
			 * @example
			 *
			 * _.isSymbol(Symbol.iterator);
			 * // => true
			 *
			 * _.isSymbol('abc');
			 * // => false
			 */
			function isSymbol(value) {
			  return typeof value == 'symbol' ||
			    (isObjectLike(value) && objectToString.call(value) == symbolTag);
			}

			/**
			 * Converts `value` to a finite number.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.12.0
			 * @category Lang
			 * @param {*} value The value to convert.
			 * @returns {number} Returns the converted number.
			 * @example
			 *
			 * _.toFinite(3.2);
			 * // => 3.2
			 *
			 * _.toFinite(Number.MIN_VALUE);
			 * // => 5e-324
			 *
			 * _.toFinite(Infinity);
			 * // => 1.7976931348623157e+308
			 *
			 * _.toFinite('3.2');
			 * // => 3.2
			 */
			function toFinite(value) {
			  if (!value) {
			    return value === 0 ? value : 0;
			  }
			  value = toNumber(value);
			  if (value === INFINITY || value === -INFINITY) {
			    var sign = (value < 0 ? -1 : 1);
			    return sign * MAX_INTEGER;
			  }
			  return value === value ? value : 0;
			}

			/**
			 * Converts `value` to an integer.
			 *
			 * **Note:** This method is loosely based on
			 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
			 *
			 * @static
			 * @memberOf _
			 * @since 4.0.0
			 * @category Lang
			 * @param {*} value The value to convert.
			 * @returns {number} Returns the converted integer.
			 * @example
			 *
			 * _.toInteger(3.2);
			 * // => 3
			 *
			 * _.toInteger(Number.MIN_VALUE);
			 * // => 0
			 *
			 * _.toInteger(Infinity);
			 * // => 1.7976931348623157e+308
			 *
			 * _.toInteger('3.2');
			 * // => 3
			 */
			function toInteger(value) {
			  var result = toFinite(value),
			      remainder = result % 1;

			  return result === result ? (remainder ? result - remainder : result) : 0;
			}

			/**
			 * Converts `value` to a number.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.0.0
			 * @category Lang
			 * @param {*} value The value to process.
			 * @returns {number} Returns the number.
			 * @example
			 *
			 * _.toNumber(3.2);
			 * // => 3.2
			 *
			 * _.toNumber(Number.MIN_VALUE);
			 * // => 5e-324
			 *
			 * _.toNumber(Infinity);
			 * // => Infinity
			 *
			 * _.toNumber('3.2');
			 * // => 3.2
			 */
			function toNumber(value) {
			  if (typeof value == 'number') {
			    return value;
			  }
			  if (isSymbol(value)) {
			    return NAN;
			  }
			  if (isObject(value)) {
			    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
			    value = isObject(other) ? (other + '') : other;
			  }
			  if (typeof value != 'string') {
			    return value === 0 ? value : +value;
			  }
			  value = value.replace(reTrim, '');
			  var isBinary = reIsBinary.test(value);
			  return (isBinary || reIsOctal.test(value))
			    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
			    : (reIsBadHex.test(value) ? NAN : +value);
			}

			/**
			 * Converts `value` to a string. An empty string is returned for `null`
			 * and `undefined` values. The sign of `-0` is preserved.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.0.0
			 * @category Lang
			 * @param {*} value The value to process.
			 * @returns {string} Returns the string.
			 * @example
			 *
			 * _.toString(null);
			 * // => ''
			 *
			 * _.toString(-0);
			 * // => '-0'
			 *
			 * _.toString([1, 2, 3]);
			 * // => '1,2,3'
			 */
			function toString(value) {
			  return value == null ? '' : baseToString(value);
			}

			/**
			 * Truncates `string` if it's longer than the given maximum string length.
			 * The last characters of the truncated string are replaced with the omission
			 * string which defaults to "...".
			 *
			 * @static
			 * @memberOf _
			 * @since 4.0.0
			 * @category String
			 * @param {string} [string=''] The string to truncate.
			 * @param {Object} [options={}] The options object.
			 * @param {number} [options.length=30] The maximum string length.
			 * @param {string} [options.omission='...'] The string to indicate text is omitted.
			 * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
			 * @returns {string} Returns the truncated string.
			 * @example
			 *
			 * _.truncate('hi-diddly-ho there, neighborino');
			 * // => 'hi-diddly-ho there, neighbo...'
			 *
			 * _.truncate('hi-diddly-ho there, neighborino', {
			 *   'length': 24,
			 *   'separator': ' '
			 * });
			 * // => 'hi-diddly-ho there,...'
			 *
			 * _.truncate('hi-diddly-ho there, neighborino', {
			 *   'length': 24,
			 *   'separator': /,? +/
			 * });
			 * // => 'hi-diddly-ho there...'
			 *
			 * _.truncate('hi-diddly-ho there, neighborino', {
			 *   'omission': ' [...]'
			 * });
			 * // => 'hi-diddly-ho there, neig [...]'
			 */
			function truncate(string, options) {
			  var length = DEFAULT_TRUNC_LENGTH,
			      omission = DEFAULT_TRUNC_OMISSION;

			  if (isObject(options)) {
			    var separator = 'separator' in options ? options.separator : separator;
			    length = 'length' in options ? toInteger(options.length) : length;
			    omission = 'omission' in options ? baseToString(options.omission) : omission;
			  }
			  string = toString(string);

			  var strLength = string.length;
			  if (hasUnicode(string)) {
			    var strSymbols = stringToArray(string);
			    strLength = strSymbols.length;
			  }
			  if (length >= strLength) {
			    return string;
			  }
			  var end = length - stringSize(omission);
			  if (end < 1) {
			    return omission;
			  }
			  var result = strSymbols
			    ? castSlice(strSymbols, 0, end).join('')
			    : string.slice(0, end);

			  if (separator === undefined) {
			    return result + omission;
			  }
			  if (strSymbols) {
			    end += (result.length - end);
			  }
			  if (isRegExp(separator)) {
			    if (string.slice(end).search(separator)) {
			      var match,
			          substring = result;

			      if (!separator.global) {
			        separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
			      }
			      separator.lastIndex = 0;
			      while ((match = separator.exec(substring))) {
			        var newEnd = match.index;
			      }
			      result = result.slice(0, newEnd === undefined ? end : newEnd);
			    }
			  } else if (string.indexOf(baseToString(separator), end) != end) {
			    var index = result.lastIndexOf(separator);
			    if (index > -1) {
			      result = result.slice(0, index);
			    }
			  }
			  return result + omission;
			}

			module.exports = truncate; 
		} (lodash_truncate, lodash_truncate.exports));
		return lodash_truncate.exports;
	}

	var hasRequiredTruncateTableData;

	function requireTruncateTableData () {
		if (hasRequiredTruncateTableData) return truncateTableData;
		hasRequiredTruncateTableData = 1;
		(function (exports) {
			var __importDefault = (truncateTableData && truncateTableData.__importDefault) || function (mod) {
			    return (mod && mod.__esModule) ? mod : { "default": mod };
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.truncateTableData = exports.truncateString = void 0;
			const lodash_truncate_1 = __importDefault(requireLodash_truncate());
			const truncateString = (input, length) => {
			    return (0, lodash_truncate_1.default)(input, { length,
			        omission: '…' });
			};
			exports.truncateString = truncateString;
			/**
			 * @todo Make it work with ASCII content.
			 */
			const truncateTableData$1 = (rows, truncates) => {
			    return rows.map((cells) => {
			        return cells.map((cell, cellIndex) => {
			            return (0, exports.truncateString)(cell, truncates[cellIndex]);
			        });
			    });
			};
			exports.truncateTableData = truncateTableData$1;
			
		} (truncateTableData));
		return truncateTableData;
	}

	var hasRequiredCreateStream;

	function requireCreateStream () {
		if (hasRequiredCreateStream) return createStream;
		hasRequiredCreateStream = 1;
		Object.defineProperty(createStream, "__esModule", { value: true });
		createStream.createStream = void 0;
		const alignTableData_1 = /*@__PURE__*/ requireAlignTableData();
		const calculateRowHeights_1 = /*@__PURE__*/ requireCalculateRowHeights();
		const drawBorder_1 = /*@__PURE__*/ requireDrawBorder();
		const drawRow_1 = /*@__PURE__*/ requireDrawRow();
		const makeStreamConfig_1 = /*@__PURE__*/ requireMakeStreamConfig();
		const mapDataUsingRowHeights_1 = /*@__PURE__*/ requireMapDataUsingRowHeights();
		const padTableData_1 = /*@__PURE__*/ requirePadTableData();
		const stringifyTableData_1 = /*@__PURE__*/ requireStringifyTableData();
		const truncateTableData_1 = /*@__PURE__*/ requireTruncateTableData();
		const utils_1 = /*@__PURE__*/ requireUtils();
		const prepareData = (data, config) => {
		    let rows = (0, stringifyTableData_1.stringifyTableData)(data);
		    rows = (0, truncateTableData_1.truncateTableData)(rows, (0, utils_1.extractTruncates)(config));
		    const rowHeights = (0, calculateRowHeights_1.calculateRowHeights)(rows, config);
		    rows = (0, mapDataUsingRowHeights_1.mapDataUsingRowHeights)(rows, rowHeights, config);
		    rows = (0, alignTableData_1.alignTableData)(rows, config);
		    rows = (0, padTableData_1.padTableData)(rows, config);
		    return rows;
		};
		const create = (row, columnWidths, config) => {
		    const rows = prepareData([row], config);
		    const body = rows.map((literalRow) => {
		        return (0, drawRow_1.drawRow)(literalRow, config);
		    }).join('');
		    let output;
		    output = '';
		    output += (0, drawBorder_1.drawBorderTop)(columnWidths, config);
		    output += body;
		    output += (0, drawBorder_1.drawBorderBottom)(columnWidths, config);
		    output = output.trimEnd();
		    browser$1.stdout.write(output);
		};
		const append = (row, columnWidths, config) => {
		    const rows = prepareData([row], config);
		    const body = rows.map((literalRow) => {
		        return (0, drawRow_1.drawRow)(literalRow, config);
		    }).join('');
		    let output = '';
		    const bottom = (0, drawBorder_1.drawBorderBottom)(columnWidths, config);
		    if (bottom !== '\n') {
		        output = '\r\u001B[K';
		    }
		    output += (0, drawBorder_1.drawBorderJoin)(columnWidths, config);
		    output += body;
		    output += bottom;
		    output = output.trimEnd();
		    browser$1.stdout.write(output);
		};
		const createStream$1 = (userConfig) => {
		    const config = (0, makeStreamConfig_1.makeStreamConfig)(userConfig);
		    const columnWidths = Object.values(config.columns).map((column) => {
		        return column.width + column.paddingLeft + column.paddingRight;
		    });
		    let empty = true;
		    return {
		        write: (row) => {
		            if (row.length !== config.columnCount) {
		                throw new Error('Row cell count does not match the config.columnCount.');
		            }
		            if (empty) {
		                empty = false;
		                create(row, columnWidths, config);
		            }
		            else {
		                append(row, columnWidths, config);
		            }
		        },
		    };
		};
		createStream.createStream = createStream$1;
		
		return createStream;
	}

	var table = {};

	var calculateOutputColumnWidths = {};

	var hasRequiredCalculateOutputColumnWidths;

	function requireCalculateOutputColumnWidths () {
		if (hasRequiredCalculateOutputColumnWidths) return calculateOutputColumnWidths;
		hasRequiredCalculateOutputColumnWidths = 1;
		Object.defineProperty(calculateOutputColumnWidths, "__esModule", { value: true });
		calculateOutputColumnWidths.calculateOutputColumnWidths = void 0;
		const calculateOutputColumnWidths$1 = (config) => {
		    return config.columns.map((col) => {
		        return col.paddingLeft + col.width + col.paddingRight;
		    });
		};
		calculateOutputColumnWidths.calculateOutputColumnWidths = calculateOutputColumnWidths$1;
		
		return calculateOutputColumnWidths;
	}

	var drawTable = {};

	var hasRequiredDrawTable;

	function requireDrawTable () {
		if (hasRequiredDrawTable) return drawTable;
		hasRequiredDrawTable = 1;
		Object.defineProperty(drawTable, "__esModule", { value: true });
		drawTable.drawTable = void 0;
		const drawBorder_1 = /*@__PURE__*/ requireDrawBorder();
		const drawContent_1 = /*@__PURE__*/ requireDrawContent();
		const drawRow_1 = /*@__PURE__*/ requireDrawRow();
		const utils_1 = /*@__PURE__*/ requireUtils();
		const drawTable$1 = (rows, outputColumnWidths, rowHeights, config) => {
		    const { drawHorizontalLine, singleLine, } = config;
		    const contents = (0, utils_1.groupBySizes)(rows, rowHeights).map((group, groupIndex) => {
		        return group.map((row) => {
		            return (0, drawRow_1.drawRow)(row, { ...config,
		                rowIndex: groupIndex });
		        }).join('');
		    });
		    return (0, drawContent_1.drawContent)({ contents,
		        drawSeparator: (index, size) => {
		            // Top/bottom border
		            if (index === 0 || index === size) {
		                return drawHorizontalLine(index, size);
		            }
		            return !singleLine && drawHorizontalLine(index, size);
		        },
		        elementType: 'row',
		        rowIndex: -1,
		        separatorGetter: (0, drawBorder_1.createTableBorderGetter)(outputColumnWidths, { ...config,
		            rowCount: contents.length }),
		        spanningCellManager: config.spanningCellManager });
		};
		drawTable.drawTable = drawTable$1;
		
		return drawTable;
	}

	var injectHeaderConfig = {};

	var hasRequiredInjectHeaderConfig;

	function requireInjectHeaderConfig () {
		if (hasRequiredInjectHeaderConfig) return injectHeaderConfig;
		hasRequiredInjectHeaderConfig = 1;
		Object.defineProperty(injectHeaderConfig, "__esModule", { value: true });
		injectHeaderConfig.injectHeaderConfig = void 0;
		const injectHeaderConfig$1 = (rows, config) => {
		    var _a;
		    let spanningCellConfig = (_a = config.spanningCells) !== null && _a !== void 0 ? _a : [];
		    const headerConfig = config.header;
		    const adjustedRows = [...rows];
		    if (headerConfig) {
		        spanningCellConfig = spanningCellConfig.map(({ row, ...rest }) => {
		            return { ...rest,
		                row: row + 1 };
		        });
		        const { content, ...headerStyles } = headerConfig;
		        spanningCellConfig.unshift({ alignment: 'center',
		            col: 0,
		            colSpan: rows[0].length,
		            paddingLeft: 1,
		            paddingRight: 1,
		            row: 0,
		            wrapWord: false,
		            ...headerStyles });
		        adjustedRows.unshift([content, ...Array.from({ length: rows[0].length - 1 }).fill('')]);
		    }
		    return [adjustedRows,
		        spanningCellConfig];
		};
		injectHeaderConfig.injectHeaderConfig = injectHeaderConfig$1;
		
		return injectHeaderConfig;
	}

	var makeTableConfig = {};

	var calculateMaximumColumnWidths = {};

	var hasRequiredCalculateMaximumColumnWidths;

	function requireCalculateMaximumColumnWidths () {
		if (hasRequiredCalculateMaximumColumnWidths) return calculateMaximumColumnWidths;
		hasRequiredCalculateMaximumColumnWidths = 1;
		(function (exports) {
			var __importDefault = (calculateMaximumColumnWidths && calculateMaximumColumnWidths.__importDefault) || function (mod) {
			    return (mod && mod.__esModule) ? mod : { "default": mod };
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.calculateMaximumColumnWidths = exports.calculateMaximumCellWidth = void 0;
			const string_width_1 = __importDefault(requireStringWidth());
			const utils_1 = /*@__PURE__*/ requireUtils();
			const calculateMaximumCellWidth = (cell) => {
			    return Math.max(...cell.split('\n').map(string_width_1.default));
			};
			exports.calculateMaximumCellWidth = calculateMaximumCellWidth;
			/**
			 * Produces an array of values that describe the largest value length (width) in every column.
			 */
			const calculateMaximumColumnWidths$1 = (rows, spanningCellConfigs = []) => {
			    const columnWidths = new Array(rows[0].length).fill(0);
			    const rangeCoordinates = spanningCellConfigs.map(utils_1.calculateRangeCoordinate);
			    const isSpanningCell = (rowIndex, columnIndex) => {
			        return rangeCoordinates.some((rangeCoordinate) => {
			            return (0, utils_1.isCellInRange)({ col: columnIndex,
			                row: rowIndex }, rangeCoordinate);
			        });
			    };
			    rows.forEach((row, rowIndex) => {
			        row.forEach((cell, cellIndex) => {
			            if (isSpanningCell(rowIndex, cellIndex)) {
			                return;
			            }
			            columnWidths[cellIndex] = Math.max(columnWidths[cellIndex], (0, exports.calculateMaximumCellWidth)(cell));
			        });
			    });
			    return columnWidths;
			};
			exports.calculateMaximumColumnWidths = calculateMaximumColumnWidths$1;
			
		} (calculateMaximumColumnWidths));
		return calculateMaximumColumnWidths;
	}

	var spanningCellManager = {};

	var alignSpanningCell = {};

	var hasRequiredAlignSpanningCell;

	function requireAlignSpanningCell () {
		if (hasRequiredAlignSpanningCell) return alignSpanningCell;
		hasRequiredAlignSpanningCell = 1;
		var __importDefault = (alignSpanningCell && alignSpanningCell.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(alignSpanningCell, "__esModule", { value: true });
		alignSpanningCell.alignVerticalRangeContent = alignSpanningCell.wrapRangeContent = void 0;
		const string_width_1 = __importDefault(requireStringWidth());
		const alignString_1 = /*@__PURE__*/ requireAlignString();
		const mapDataUsingRowHeights_1 = /*@__PURE__*/ requireMapDataUsingRowHeights();
		const padTableData_1 = /*@__PURE__*/ requirePadTableData();
		const truncateTableData_1 = /*@__PURE__*/ requireTruncateTableData();
		const utils_1 = /*@__PURE__*/ requireUtils();
		const wrapCell_1 = /*@__PURE__*/ requireWrapCell();
		/**
		 * Fill content into all cells in range in order to calculate total height
		 */
		const wrapRangeContent = (rangeConfig, rangeWidth, context) => {
		    const { topLeft, paddingRight, paddingLeft, truncate, wrapWord, alignment } = rangeConfig;
		    const originalContent = context.rows[topLeft.row][topLeft.col];
		    const contentWidth = rangeWidth - paddingLeft - paddingRight;
		    return (0, wrapCell_1.wrapCell)((0, truncateTableData_1.truncateString)(originalContent, truncate), contentWidth, wrapWord).map((line) => {
		        const alignedLine = (0, alignString_1.alignString)(line, contentWidth, alignment);
		        return (0, padTableData_1.padString)(alignedLine, paddingLeft, paddingRight);
		    });
		};
		alignSpanningCell.wrapRangeContent = wrapRangeContent;
		const alignVerticalRangeContent = (range, content, context) => {
		    const { rows, drawHorizontalLine, rowHeights } = context;
		    const { topLeft, bottomRight, verticalAlignment } = range;
		    // They are empty before calculateRowHeights function run
		    if (rowHeights.length === 0) {
		        return [];
		    }
		    const totalCellHeight = (0, utils_1.sumArray)(rowHeights.slice(topLeft.row, bottomRight.row + 1));
		    const totalBorderHeight = bottomRight.row - topLeft.row;
		    const hiddenHorizontalBorderCount = (0, utils_1.sequence)(topLeft.row + 1, bottomRight.row).filter((horizontalBorderIndex) => {
		        return !drawHorizontalLine(horizontalBorderIndex, rows.length);
		    }).length;
		    const availableRangeHeight = totalCellHeight + totalBorderHeight - hiddenHorizontalBorderCount;
		    return (0, mapDataUsingRowHeights_1.padCellVertically)(content, availableRangeHeight, verticalAlignment).map((line) => {
		        if (line.length === 0) {
		            return ' '.repeat((0, string_width_1.default)(content[0]));
		        }
		        return line;
		    });
		};
		alignSpanningCell.alignVerticalRangeContent = alignVerticalRangeContent;
		
		return alignSpanningCell;
	}

	var calculateSpanningCellWidth = {};

	var hasRequiredCalculateSpanningCellWidth;

	function requireCalculateSpanningCellWidth () {
		if (hasRequiredCalculateSpanningCellWidth) return calculateSpanningCellWidth;
		hasRequiredCalculateSpanningCellWidth = 1;
		Object.defineProperty(calculateSpanningCellWidth, "__esModule", { value: true });
		calculateSpanningCellWidth.calculateSpanningCellWidth = void 0;
		const utils_1 = /*@__PURE__*/ requireUtils();
		const calculateSpanningCellWidth$1 = (rangeConfig, dependencies) => {
		    const { columnsConfig, drawVerticalLine } = dependencies;
		    const { topLeft, bottomRight } = rangeConfig;
		    const totalWidth = (0, utils_1.sumArray)(columnsConfig.slice(topLeft.col, bottomRight.col + 1).map(({ width }) => {
		        return width;
		    }));
		    const totalPadding = topLeft.col === bottomRight.col ?
		        columnsConfig[topLeft.col].paddingRight +
		            columnsConfig[bottomRight.col].paddingLeft :
		        (0, utils_1.sumArray)(columnsConfig
		            .slice(topLeft.col, bottomRight.col + 1)
		            .map(({ paddingLeft, paddingRight }) => {
		            return paddingLeft + paddingRight;
		        }));
		    const totalBorderWidths = bottomRight.col - topLeft.col;
		    const totalHiddenVerticalBorders = (0, utils_1.sequence)(topLeft.col + 1, bottomRight.col).filter((verticalBorderIndex) => {
		        return !drawVerticalLine(verticalBorderIndex, columnsConfig.length);
		    }).length;
		    return totalWidth + totalPadding + totalBorderWidths - totalHiddenVerticalBorders;
		};
		calculateSpanningCellWidth.calculateSpanningCellWidth = calculateSpanningCellWidth$1;
		
		return calculateSpanningCellWidth;
	}

	var makeRangeConfig = {};

	var hasRequiredMakeRangeConfig;

	function requireMakeRangeConfig () {
		if (hasRequiredMakeRangeConfig) return makeRangeConfig;
		hasRequiredMakeRangeConfig = 1;
		Object.defineProperty(makeRangeConfig, "__esModule", { value: true });
		makeRangeConfig.makeRangeConfig = void 0;
		const utils_1 = /*@__PURE__*/ requireUtils();
		const makeRangeConfig$1 = (spanningCellConfig, columnsConfig) => {
		    var _a;
		    const { topLeft, bottomRight } = (0, utils_1.calculateRangeCoordinate)(spanningCellConfig);
		    const cellConfig = {
		        ...columnsConfig[topLeft.col],
		        ...spanningCellConfig,
		        paddingRight: (_a = spanningCellConfig.paddingRight) !== null && _a !== void 0 ? _a : columnsConfig[bottomRight.col].paddingRight,
		    };
		    return { ...cellConfig,
		        bottomRight,
		        topLeft };
		};
		makeRangeConfig.makeRangeConfig = makeRangeConfig$1;
		
		return makeRangeConfig;
	}

	var hasRequiredSpanningCellManager;

	function requireSpanningCellManager () {
		if (hasRequiredSpanningCellManager) return spanningCellManager;
		hasRequiredSpanningCellManager = 1;
		Object.defineProperty(spanningCellManager, "__esModule", { value: true });
		spanningCellManager.createSpanningCellManager = void 0;
		const alignSpanningCell_1 = /*@__PURE__*/ requireAlignSpanningCell();
		const calculateSpanningCellWidth_1 = /*@__PURE__*/ requireCalculateSpanningCellWidth();
		const makeRangeConfig_1 = /*@__PURE__*/ requireMakeRangeConfig();
		const utils_1 = /*@__PURE__*/ requireUtils();
		const findRangeConfig = (cell, rangeConfigs) => {
		    return rangeConfigs.find((rangeCoordinate) => {
		        return (0, utils_1.isCellInRange)(cell, rangeCoordinate);
		    });
		};
		const getContainingRange = (rangeConfig, context) => {
		    const width = (0, calculateSpanningCellWidth_1.calculateSpanningCellWidth)(rangeConfig, context);
		    const wrappedContent = (0, alignSpanningCell_1.wrapRangeContent)(rangeConfig, width, context);
		    const alignedContent = (0, alignSpanningCell_1.alignVerticalRangeContent)(rangeConfig, wrappedContent, context);
		    const getCellContent = (rowIndex) => {
		        const { topLeft } = rangeConfig;
		        const { drawHorizontalLine, rowHeights } = context;
		        const totalWithinHorizontalBorderHeight = rowIndex - topLeft.row;
		        const totalHiddenHorizontalBorderHeight = (0, utils_1.sequence)(topLeft.row + 1, rowIndex).filter((index) => {
		            /* istanbul ignore next */
		            return !(drawHorizontalLine === null || drawHorizontalLine === void 0 ? void 0 : drawHorizontalLine(index, rowHeights.length));
		        }).length;
		        const offset = (0, utils_1.sumArray)(rowHeights.slice(topLeft.row, rowIndex)) + totalWithinHorizontalBorderHeight - totalHiddenHorizontalBorderHeight;
		        return alignedContent.slice(offset, offset + rowHeights[rowIndex]);
		    };
		    const getBorderContent = (borderIndex) => {
		        const { topLeft } = rangeConfig;
		        const offset = (0, utils_1.sumArray)(context.rowHeights.slice(topLeft.row, borderIndex)) + (borderIndex - topLeft.row - 1);
		        return alignedContent[offset];
		    };
		    return {
		        ...rangeConfig,
		        extractBorderContent: getBorderContent,
		        extractCellContent: getCellContent,
		        height: wrappedContent.length,
		        width,
		    };
		};
		const inSameRange = (cell1, cell2, ranges) => {
		    const range1 = findRangeConfig(cell1, ranges);
		    const range2 = findRangeConfig(cell2, ranges);
		    if (range1 && range2) {
		        return (0, utils_1.areCellEqual)(range1.topLeft, range2.topLeft);
		    }
		    return false;
		};
		const hashRange = (range) => {
		    const { row, col } = range.topLeft;
		    return `${row}/${col}`;
		};
		const createSpanningCellManager = (parameters) => {
		    const { spanningCellConfigs, columnsConfig } = parameters;
		    const ranges = spanningCellConfigs.map((config) => {
		        return (0, makeRangeConfig_1.makeRangeConfig)(config, columnsConfig);
		    });
		    const rangeCache = {};
		    let rowHeights = [];
		    let rowIndexMapping = [];
		    return { getContainingRange: (cell, options) => {
		            var _a;
		            const originalRow = (options === null || options === void 0 ? void 0 : options.mapped) ? rowIndexMapping[cell.row] : cell.row;
		            const range = findRangeConfig({ ...cell,
		                row: originalRow }, ranges);
		            if (!range) {
		                return undefined;
		            }
		            if (rowHeights.length === 0) {
		                return getContainingRange(range, { ...parameters,
		                    rowHeights });
		            }
		            const hash = hashRange(range);
		            (_a = rangeCache[hash]) !== null && _a !== void 0 ? _a : (rangeCache[hash] = getContainingRange(range, { ...parameters,
		                rowHeights }));
		            return rangeCache[hash];
		        },
		        inSameRange: (cell1, cell2) => {
		            return inSameRange(cell1, cell2, ranges);
		        },
		        rowHeights,
		        rowIndexMapping,
		        setRowHeights: (_rowHeights) => {
		            rowHeights = _rowHeights;
		        },
		        setRowIndexMapping: (mappedRowHeights) => {
		            rowIndexMapping = (0, utils_1.flatten)(mappedRowHeights.map((height, index) => {
		                return Array.from({ length: height }, () => {
		                    return index;
		                });
		            }));
		        } };
		};
		spanningCellManager.createSpanningCellManager = createSpanningCellManager;
		
		return spanningCellManager;
	}

	var validateSpanningCellConfig = {};

	var hasRequiredValidateSpanningCellConfig;

	function requireValidateSpanningCellConfig () {
		if (hasRequiredValidateSpanningCellConfig) return validateSpanningCellConfig;
		hasRequiredValidateSpanningCellConfig = 1;
		Object.defineProperty(validateSpanningCellConfig, "__esModule", { value: true });
		validateSpanningCellConfig.validateSpanningCellConfig = void 0;
		const utils_1 = /*@__PURE__*/ requireUtils();
		const inRange = (start, end, value) => {
		    return start <= value && value <= end;
		};
		const validateSpanningCellConfig$1 = (rows, configs) => {
		    const [nRow, nCol] = [rows.length, rows[0].length];
		    configs.forEach((config, configIndex) => {
		        const { colSpan, rowSpan } = config;
		        if (colSpan === undefined && rowSpan === undefined) {
		            throw new Error(`Expect at least colSpan or rowSpan is provided in config.spanningCells[${configIndex}]`);
		        }
		        if (colSpan !== undefined && colSpan < 1) {
		            throw new Error(`Expect colSpan is not equal zero, instead got: ${colSpan} in config.spanningCells[${configIndex}]`);
		        }
		        if (rowSpan !== undefined && rowSpan < 1) {
		            throw new Error(`Expect rowSpan is not equal zero, instead got: ${rowSpan} in config.spanningCells[${configIndex}]`);
		        }
		    });
		    const rangeCoordinates = configs.map(utils_1.calculateRangeCoordinate);
		    rangeCoordinates.forEach(({ topLeft, bottomRight }, rangeIndex) => {
		        if (!inRange(0, nCol - 1, topLeft.col) ||
		            !inRange(0, nRow - 1, topLeft.row) ||
		            !inRange(0, nCol - 1, bottomRight.col) ||
		            !inRange(0, nRow - 1, bottomRight.row)) {
		            throw new Error(`Some cells in config.spanningCells[${rangeIndex}] are out of the table`);
		        }
		    });
		    const configOccupy = Array.from({ length: nRow }, () => {
		        return Array.from({ length: nCol });
		    });
		    rangeCoordinates.forEach(({ topLeft, bottomRight }, rangeIndex) => {
		        (0, utils_1.sequence)(topLeft.row, bottomRight.row).forEach((row) => {
		            (0, utils_1.sequence)(topLeft.col, bottomRight.col).forEach((col) => {
		                if (configOccupy[row][col] !== undefined) {
		                    throw new Error(`Spanning cells in config.spanningCells[${configOccupy[row][col]}] and config.spanningCells[${rangeIndex}] are overlap each other`);
		                }
		                configOccupy[row][col] = rangeIndex;
		            });
		        });
		    });
		};
		validateSpanningCellConfig.validateSpanningCellConfig = validateSpanningCellConfig$1;
		
		return validateSpanningCellConfig;
	}

	var hasRequiredMakeTableConfig;

	function requireMakeTableConfig () {
		if (hasRequiredMakeTableConfig) return makeTableConfig;
		hasRequiredMakeTableConfig = 1;
		Object.defineProperty(makeTableConfig, "__esModule", { value: true });
		makeTableConfig.makeTableConfig = void 0;
		const calculateMaximumColumnWidths_1 = /*@__PURE__*/ requireCalculateMaximumColumnWidths();
		const spanningCellManager_1 = /*@__PURE__*/ requireSpanningCellManager();
		const utils_1 = /*@__PURE__*/ requireUtils();
		const validateConfig_1 = /*@__PURE__*/ requireValidateConfig();
		const validateSpanningCellConfig_1 = /*@__PURE__*/ requireValidateSpanningCellConfig();
		/**
		 * Creates a configuration for every column using default
		 * values for the missing configuration properties.
		 */
		const makeColumnsConfig = (rows, columns, columnDefault, spanningCellConfigs) => {
		    const columnWidths = (0, calculateMaximumColumnWidths_1.calculateMaximumColumnWidths)(rows, spanningCellConfigs);
		    return rows[0].map((_, columnIndex) => {
		        return {
		            alignment: 'left',
		            paddingLeft: 1,
		            paddingRight: 1,
		            truncate: Number.POSITIVE_INFINITY,
		            verticalAlignment: 'top',
		            width: columnWidths[columnIndex],
		            wrapWord: false,
		            ...columnDefault,
		            ...columns === null || columns === void 0 ? void 0 : columns[columnIndex],
		        };
		    });
		};
		/**
		 * Makes a new configuration object out of the userConfig object
		 * using default values for the missing configuration properties.
		 */
		const makeTableConfig$1 = (rows, config = {}, injectedSpanningCellConfig) => {
		    var _a, _b, _c, _d, _e;
		    (0, validateConfig_1.validateConfig)('config.json', config);
		    (0, validateSpanningCellConfig_1.validateSpanningCellConfig)(rows, (_a = config.spanningCells) !== null && _a !== void 0 ? _a : []);
		    const spanningCellConfigs = (_b = injectedSpanningCellConfig !== null && injectedSpanningCellConfig !== void 0 ? injectedSpanningCellConfig : config.spanningCells) !== null && _b !== void 0 ? _b : [];
		    const columnsConfig = makeColumnsConfig(rows, config.columns, config.columnDefault, spanningCellConfigs);
		    const drawVerticalLine = (_c = config.drawVerticalLine) !== null && _c !== void 0 ? _c : (() => {
		        return true;
		    });
		    const drawHorizontalLine = (_d = config.drawHorizontalLine) !== null && _d !== void 0 ? _d : (() => {
		        return true;
		    });
		    return {
		        ...config,
		        border: (0, utils_1.makeBorderConfig)(config.border),
		        columns: columnsConfig,
		        drawHorizontalLine,
		        drawVerticalLine,
		        singleLine: (_e = config.singleLine) !== null && _e !== void 0 ? _e : false,
		        spanningCellManager: (0, spanningCellManager_1.createSpanningCellManager)({
		            columnsConfig,
		            drawHorizontalLine,
		            drawVerticalLine,
		            rows,
		            spanningCellConfigs,
		        }),
		    };
		};
		makeTableConfig.makeTableConfig = makeTableConfig$1;
		
		return makeTableConfig;
	}

	var validateTableData = {};

	var hasRequiredValidateTableData;

	function requireValidateTableData () {
		if (hasRequiredValidateTableData) return validateTableData;
		hasRequiredValidateTableData = 1;
		Object.defineProperty(validateTableData, "__esModule", { value: true });
		validateTableData.validateTableData = void 0;
		const utils_1 = /*@__PURE__*/ requireUtils();
		const validateTableData$1 = (rows) => {
		    if (!Array.isArray(rows)) {
		        throw new TypeError('Table data must be an array.');
		    }
		    if (rows.length === 0) {
		        throw new Error('Table must define at least one row.');
		    }
		    if (rows[0].length === 0) {
		        throw new Error('Table must define at least one column.');
		    }
		    const columnNumber = rows[0].length;
		    for (const row of rows) {
		        if (!Array.isArray(row)) {
		            throw new TypeError('Table row data must be an array.');
		        }
		        if (row.length !== columnNumber) {
		            throw new Error('Table must have a consistent number of cells.');
		        }
		        for (const cell of row) {
		            // eslint-disable-next-line no-control-regex
		            if (/[\u0001-\u0006\u0008\u0009\u000B-\u001A]/.test((0, utils_1.normalizeString)(String(cell)))) {
		                throw new Error('Table data must not contain control characters.');
		            }
		        }
		    }
		};
		validateTableData.validateTableData = validateTableData$1;
		
		return validateTableData;
	}

	var hasRequiredTable;

	function requireTable () {
		if (hasRequiredTable) return table;
		hasRequiredTable = 1;
		Object.defineProperty(table, "__esModule", { value: true });
		table.table = void 0;
		const alignTableData_1 = /*@__PURE__*/ requireAlignTableData();
		const calculateOutputColumnWidths_1 = /*@__PURE__*/ requireCalculateOutputColumnWidths();
		const calculateRowHeights_1 = /*@__PURE__*/ requireCalculateRowHeights();
		const drawTable_1 = /*@__PURE__*/ requireDrawTable();
		const injectHeaderConfig_1 = /*@__PURE__*/ requireInjectHeaderConfig();
		const makeTableConfig_1 = /*@__PURE__*/ requireMakeTableConfig();
		const mapDataUsingRowHeights_1 = /*@__PURE__*/ requireMapDataUsingRowHeights();
		const padTableData_1 = /*@__PURE__*/ requirePadTableData();
		const stringifyTableData_1 = /*@__PURE__*/ requireStringifyTableData();
		const truncateTableData_1 = /*@__PURE__*/ requireTruncateTableData();
		const utils_1 = /*@__PURE__*/ requireUtils();
		const validateTableData_1 = /*@__PURE__*/ requireValidateTableData();
		const table$1 = (data, userConfig = {}) => {
		    (0, validateTableData_1.validateTableData)(data);
		    let rows = (0, stringifyTableData_1.stringifyTableData)(data);
		    const [injectedRows, injectedSpanningCellConfig] = (0, injectHeaderConfig_1.injectHeaderConfig)(rows, userConfig);
		    const config = (0, makeTableConfig_1.makeTableConfig)(injectedRows, userConfig, injectedSpanningCellConfig);
		    rows = (0, truncateTableData_1.truncateTableData)(injectedRows, (0, utils_1.extractTruncates)(config));
		    const rowHeights = (0, calculateRowHeights_1.calculateRowHeights)(rows, config);
		    config.spanningCellManager.setRowHeights(rowHeights);
		    config.spanningCellManager.setRowIndexMapping(rowHeights);
		    rows = (0, mapDataUsingRowHeights_1.mapDataUsingRowHeights)(rows, rowHeights, config);
		    rows = (0, alignTableData_1.alignTableData)(rows, config);
		    rows = (0, padTableData_1.padTableData)(rows, config);
		    const outputColumnWidths = (0, calculateOutputColumnWidths_1.calculateOutputColumnWidths)(config);
		    return (0, drawTable_1.drawTable)(rows, outputColumnWidths, rowHeights, config);
		};
		table.table = table$1;
		
		return table;
	}

	var api = {};

	var hasRequiredApi;

	function requireApi () {
		if (hasRequiredApi) return api;
		hasRequiredApi = 1;
		Object.defineProperty(api, "__esModule", { value: true });
		
		return api;
	}

	var hasRequiredSrc;

	function requireSrc () {
		if (hasRequiredSrc) return src;
		hasRequiredSrc = 1;
		(function (exports) {
			var __createBinding = (src && src.__createBinding) || (Object.create ? (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
			}) : (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    o[k2] = m[k];
			}));
			var __exportStar = (src && src.__exportStar) || function(m, exports) {
			    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.getBorderCharacters = exports.createStream = exports.table = void 0;
			const createStream_1 = /*@__PURE__*/ requireCreateStream();
			Object.defineProperty(exports, "createStream", { enumerable: true, get: function () { return createStream_1.createStream; } });
			const getBorderCharacters_1 = /*@__PURE__*/ requireGetBorderCharacters();
			Object.defineProperty(exports, "getBorderCharacters", { enumerable: true, get: function () { return getBorderCharacters_1.getBorderCharacters; } });
			const table_1 = /*@__PURE__*/ requireTable();
			Object.defineProperty(exports, "table", { enumerable: true, get: function () { return table_1.table; } });
			__exportStar(/*@__PURE__*/ requireApi(), exports);
			
		} (src));
		return src;
	}

	var srcExports = /*@__PURE__*/ requireSrc();

	function ansiRegex({onlyFirst = false} = {}) {
		// Valid string terminator sequences are BEL, ESC\, and 0x9c
		const ST = '(?:\\u0007|\\u001B\\u005C|\\u009C)';

		// OSC sequences only: ESC ] ... ST (non-greedy until the first ST)
		const osc = `(?:\\u001B\\][\\s\\S]*?${ST})`;

		// CSI and related: ESC/C1, optional intermediates, optional params (supports ; and :) then final byte
		const csi = '[\\u001B\\u009B][[\\]()#;?]*(?:\\d{1,4}(?:[;:]\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]';

		const pattern = `${osc}|${csi}`;

		return new RegExp(pattern, onlyFirst ? undefined : 'g');
	}

	const regex = ansiRegex();

	function stripAnsi(string) {
		if (typeof string !== 'string') {
			throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
		}

		// Even though the regex is global, we don't need to reset the `.lastIndex`
		// because unlike `.exec()` and `.test()`, `.replace()` does it automatically
		// and doing it manually has a performance penalty.
		return string.replace(regex, '');
	}

	// Generated code.

	function isAmbiguous(x) {
		return x === 0xA1
			|| x === 0xA4
			|| x === 0xA7
			|| x === 0xA8
			|| x === 0xAA
			|| x === 0xAD
			|| x === 0xAE
			|| x >= 0xB0 && x <= 0xB4
			|| x >= 0xB6 && x <= 0xBA
			|| x >= 0xBC && x <= 0xBF
			|| x === 0xC6
			|| x === 0xD0
			|| x === 0xD7
			|| x === 0xD8
			|| x >= 0xDE && x <= 0xE1
			|| x === 0xE6
			|| x >= 0xE8 && x <= 0xEA
			|| x === 0xEC
			|| x === 0xED
			|| x === 0xF0
			|| x === 0xF2
			|| x === 0xF3
			|| x >= 0xF7 && x <= 0xFA
			|| x === 0xFC
			|| x === 0xFE
			|| x === 0x101
			|| x === 0x111
			|| x === 0x113
			|| x === 0x11B
			|| x === 0x126
			|| x === 0x127
			|| x === 0x12B
			|| x >= 0x131 && x <= 0x133
			|| x === 0x138
			|| x >= 0x13F && x <= 0x142
			|| x === 0x144
			|| x >= 0x148 && x <= 0x14B
			|| x === 0x14D
			|| x === 0x152
			|| x === 0x153
			|| x === 0x166
			|| x === 0x167
			|| x === 0x16B
			|| x === 0x1CE
			|| x === 0x1D0
			|| x === 0x1D2
			|| x === 0x1D4
			|| x === 0x1D6
			|| x === 0x1D8
			|| x === 0x1DA
			|| x === 0x1DC
			|| x === 0x251
			|| x === 0x261
			|| x === 0x2C4
			|| x === 0x2C7
			|| x >= 0x2C9 && x <= 0x2CB
			|| x === 0x2CD
			|| x === 0x2D0
			|| x >= 0x2D8 && x <= 0x2DB
			|| x === 0x2DD
			|| x === 0x2DF
			|| x >= 0x300 && x <= 0x36F
			|| x >= 0x391 && x <= 0x3A1
			|| x >= 0x3A3 && x <= 0x3A9
			|| x >= 0x3B1 && x <= 0x3C1
			|| x >= 0x3C3 && x <= 0x3C9
			|| x === 0x401
			|| x >= 0x410 && x <= 0x44F
			|| x === 0x451
			|| x === 0x2010
			|| x >= 0x2013 && x <= 0x2016
			|| x === 0x2018
			|| x === 0x2019
			|| x === 0x201C
			|| x === 0x201D
			|| x >= 0x2020 && x <= 0x2022
			|| x >= 0x2024 && x <= 0x2027
			|| x === 0x2030
			|| x === 0x2032
			|| x === 0x2033
			|| x === 0x2035
			|| x === 0x203B
			|| x === 0x203E
			|| x === 0x2074
			|| x === 0x207F
			|| x >= 0x2081 && x <= 0x2084
			|| x === 0x20AC
			|| x === 0x2103
			|| x === 0x2105
			|| x === 0x2109
			|| x === 0x2113
			|| x === 0x2116
			|| x === 0x2121
			|| x === 0x2122
			|| x === 0x2126
			|| x === 0x212B
			|| x === 0x2153
			|| x === 0x2154
			|| x >= 0x215B && x <= 0x215E
			|| x >= 0x2160 && x <= 0x216B
			|| x >= 0x2170 && x <= 0x2179
			|| x === 0x2189
			|| x >= 0x2190 && x <= 0x2199
			|| x === 0x21B8
			|| x === 0x21B9
			|| x === 0x21D2
			|| x === 0x21D4
			|| x === 0x21E7
			|| x === 0x2200
			|| x === 0x2202
			|| x === 0x2203
			|| x === 0x2207
			|| x === 0x2208
			|| x === 0x220B
			|| x === 0x220F
			|| x === 0x2211
			|| x === 0x2215
			|| x === 0x221A
			|| x >= 0x221D && x <= 0x2220
			|| x === 0x2223
			|| x === 0x2225
			|| x >= 0x2227 && x <= 0x222C
			|| x === 0x222E
			|| x >= 0x2234 && x <= 0x2237
			|| x === 0x223C
			|| x === 0x223D
			|| x === 0x2248
			|| x === 0x224C
			|| x === 0x2252
			|| x === 0x2260
			|| x === 0x2261
			|| x >= 0x2264 && x <= 0x2267
			|| x === 0x226A
			|| x === 0x226B
			|| x === 0x226E
			|| x === 0x226F
			|| x === 0x2282
			|| x === 0x2283
			|| x === 0x2286
			|| x === 0x2287
			|| x === 0x2295
			|| x === 0x2299
			|| x === 0x22A5
			|| x === 0x22BF
			|| x === 0x2312
			|| x >= 0x2460 && x <= 0x24E9
			|| x >= 0x24EB && x <= 0x254B
			|| x >= 0x2550 && x <= 0x2573
			|| x >= 0x2580 && x <= 0x258F
			|| x >= 0x2592 && x <= 0x2595
			|| x === 0x25A0
			|| x === 0x25A1
			|| x >= 0x25A3 && x <= 0x25A9
			|| x === 0x25B2
			|| x === 0x25B3
			|| x === 0x25B6
			|| x === 0x25B7
			|| x === 0x25BC
			|| x === 0x25BD
			|| x === 0x25C0
			|| x === 0x25C1
			|| x >= 0x25C6 && x <= 0x25C8
			|| x === 0x25CB
			|| x >= 0x25CE && x <= 0x25D1
			|| x >= 0x25E2 && x <= 0x25E5
			|| x === 0x25EF
			|| x === 0x2605
			|| x === 0x2606
			|| x === 0x2609
			|| x === 0x260E
			|| x === 0x260F
			|| x === 0x261C
			|| x === 0x261E
			|| x === 0x2640
			|| x === 0x2642
			|| x === 0x2660
			|| x === 0x2661
			|| x >= 0x2663 && x <= 0x2665
			|| x >= 0x2667 && x <= 0x266A
			|| x === 0x266C
			|| x === 0x266D
			|| x === 0x266F
			|| x === 0x269E
			|| x === 0x269F
			|| x === 0x26BF
			|| x >= 0x26C6 && x <= 0x26CD
			|| x >= 0x26CF && x <= 0x26D3
			|| x >= 0x26D5 && x <= 0x26E1
			|| x === 0x26E3
			|| x === 0x26E8
			|| x === 0x26E9
			|| x >= 0x26EB && x <= 0x26F1
			|| x === 0x26F4
			|| x >= 0x26F6 && x <= 0x26F9
			|| x === 0x26FB
			|| x === 0x26FC
			|| x === 0x26FE
			|| x === 0x26FF
			|| x === 0x273D
			|| x >= 0x2776 && x <= 0x277F
			|| x >= 0x2B56 && x <= 0x2B59
			|| x >= 0x3248 && x <= 0x324F
			|| x >= 0xE000 && x <= 0xF8FF
			|| x >= 0xFE00 && x <= 0xFE0F
			|| x === 0xFFFD
			|| x >= 0x1F100 && x <= 0x1F10A
			|| x >= 0x1F110 && x <= 0x1F12D
			|| x >= 0x1F130 && x <= 0x1F169
			|| x >= 0x1F170 && x <= 0x1F18D
			|| x === 0x1F18F
			|| x === 0x1F190
			|| x >= 0x1F19B && x <= 0x1F1AC
			|| x >= 0xE0100 && x <= 0xE01EF
			|| x >= 0xF0000 && x <= 0xFFFFD
			|| x >= 0x100000 && x <= 0x10FFFD;
	}

	function isFullWidth(x) {
		return x === 0x3000
			|| x >= 0xFF01 && x <= 0xFF60
			|| x >= 0xFFE0 && x <= 0xFFE6;
	}

	function isWide(x) {
		return x >= 0x1100 && x <= 0x115F
			|| x === 0x231A
			|| x === 0x231B
			|| x === 0x2329
			|| x === 0x232A
			|| x >= 0x23E9 && x <= 0x23EC
			|| x === 0x23F0
			|| x === 0x23F3
			|| x === 0x25FD
			|| x === 0x25FE
			|| x === 0x2614
			|| x === 0x2615
			|| x >= 0x2630 && x <= 0x2637
			|| x >= 0x2648 && x <= 0x2653
			|| x === 0x267F
			|| x >= 0x268A && x <= 0x268F
			|| x === 0x2693
			|| x === 0x26A1
			|| x === 0x26AA
			|| x === 0x26AB
			|| x === 0x26BD
			|| x === 0x26BE
			|| x === 0x26C4
			|| x === 0x26C5
			|| x === 0x26CE
			|| x === 0x26D4
			|| x === 0x26EA
			|| x === 0x26F2
			|| x === 0x26F3
			|| x === 0x26F5
			|| x === 0x26FA
			|| x === 0x26FD
			|| x === 0x2705
			|| x === 0x270A
			|| x === 0x270B
			|| x === 0x2728
			|| x === 0x274C
			|| x === 0x274E
			|| x >= 0x2753 && x <= 0x2755
			|| x === 0x2757
			|| x >= 0x2795 && x <= 0x2797
			|| x === 0x27B0
			|| x === 0x27BF
			|| x === 0x2B1B
			|| x === 0x2B1C
			|| x === 0x2B50
			|| x === 0x2B55
			|| x >= 0x2E80 && x <= 0x2E99
			|| x >= 0x2E9B && x <= 0x2EF3
			|| x >= 0x2F00 && x <= 0x2FD5
			|| x >= 0x2FF0 && x <= 0x2FFF
			|| x >= 0x3001 && x <= 0x303E
			|| x >= 0x3041 && x <= 0x3096
			|| x >= 0x3099 && x <= 0x30FF
			|| x >= 0x3105 && x <= 0x312F
			|| x >= 0x3131 && x <= 0x318E
			|| x >= 0x3190 && x <= 0x31E5
			|| x >= 0x31EF && x <= 0x321E
			|| x >= 0x3220 && x <= 0x3247
			|| x >= 0x3250 && x <= 0xA48C
			|| x >= 0xA490 && x <= 0xA4C6
			|| x >= 0xA960 && x <= 0xA97C
			|| x >= 0xAC00 && x <= 0xD7A3
			|| x >= 0xF900 && x <= 0xFAFF
			|| x >= 0xFE10 && x <= 0xFE19
			|| x >= 0xFE30 && x <= 0xFE52
			|| x >= 0xFE54 && x <= 0xFE66
			|| x >= 0xFE68 && x <= 0xFE6B
			|| x >= 0x16FE0 && x <= 0x16FE4
			|| x >= 0x16FF0 && x <= 0x16FF6
			|| x >= 0x17000 && x <= 0x18CD5
			|| x >= 0x18CFF && x <= 0x18D1E
			|| x >= 0x18D80 && x <= 0x18DF2
			|| x >= 0x1AFF0 && x <= 0x1AFF3
			|| x >= 0x1AFF5 && x <= 0x1AFFB
			|| x === 0x1AFFD
			|| x === 0x1AFFE
			|| x >= 0x1B000 && x <= 0x1B122
			|| x === 0x1B132
			|| x >= 0x1B150 && x <= 0x1B152
			|| x === 0x1B155
			|| x >= 0x1B164 && x <= 0x1B167
			|| x >= 0x1B170 && x <= 0x1B2FB
			|| x >= 0x1D300 && x <= 0x1D356
			|| x >= 0x1D360 && x <= 0x1D376
			|| x === 0x1F004
			|| x === 0x1F0CF
			|| x === 0x1F18E
			|| x >= 0x1F191 && x <= 0x1F19A
			|| x >= 0x1F200 && x <= 0x1F202
			|| x >= 0x1F210 && x <= 0x1F23B
			|| x >= 0x1F240 && x <= 0x1F248
			|| x === 0x1F250
			|| x === 0x1F251
			|| x >= 0x1F260 && x <= 0x1F265
			|| x >= 0x1F300 && x <= 0x1F320
			|| x >= 0x1F32D && x <= 0x1F335
			|| x >= 0x1F337 && x <= 0x1F37C
			|| x >= 0x1F37E && x <= 0x1F393
			|| x >= 0x1F3A0 && x <= 0x1F3CA
			|| x >= 0x1F3CF && x <= 0x1F3D3
			|| x >= 0x1F3E0 && x <= 0x1F3F0
			|| x === 0x1F3F4
			|| x >= 0x1F3F8 && x <= 0x1F43E
			|| x === 0x1F440
			|| x >= 0x1F442 && x <= 0x1F4FC
			|| x >= 0x1F4FF && x <= 0x1F53D
			|| x >= 0x1F54B && x <= 0x1F54E
			|| x >= 0x1F550 && x <= 0x1F567
			|| x === 0x1F57A
			|| x === 0x1F595
			|| x === 0x1F596
			|| x === 0x1F5A4
			|| x >= 0x1F5FB && x <= 0x1F64F
			|| x >= 0x1F680 && x <= 0x1F6C5
			|| x === 0x1F6CC
			|| x >= 0x1F6D0 && x <= 0x1F6D2
			|| x >= 0x1F6D5 && x <= 0x1F6D8
			|| x >= 0x1F6DC && x <= 0x1F6DF
			|| x === 0x1F6EB
			|| x === 0x1F6EC
			|| x >= 0x1F6F4 && x <= 0x1F6FC
			|| x >= 0x1F7E0 && x <= 0x1F7EB
			|| x === 0x1F7F0
			|| x >= 0x1F90C && x <= 0x1F93A
			|| x >= 0x1F93C && x <= 0x1F945
			|| x >= 0x1F947 && x <= 0x1F9FF
			|| x >= 0x1FA70 && x <= 0x1FA7C
			|| x >= 0x1FA80 && x <= 0x1FA8A
			|| x >= 0x1FA8E && x <= 0x1FAC6
			|| x === 0x1FAC8
			|| x >= 0x1FACD && x <= 0x1FADC
			|| x >= 0x1FADF && x <= 0x1FAEA
			|| x >= 0x1FAEF && x <= 0x1FAF8
			|| x >= 0x20000 && x <= 0x2FFFD
			|| x >= 0x30000 && x <= 0x3FFFD;
	}

	function validate(codePoint) {
		if (!Number.isSafeInteger(codePoint)) {
			throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
		}
	}

	function eastAsianWidth(codePoint, {ambiguousAsWide = false} = {}) {
		validate(codePoint);

		if (
			isFullWidth(codePoint)
			|| isWide(codePoint)
			|| (ambiguousAsWide && isAmbiguous(codePoint))
		) {
			return 2;
		}

		return 1;
	}

	/**
	Logic:
	- Segment graphemes to match how terminals render clusters.
	- Width rules:
		1. Skip non-printing clusters (Default_Ignorable, Control, pure Mark, lone Surrogates). Tabs are ignored by design.
		2. RGI emoji clusters (\p{RGI_Emoji}) are double-width.
		3. Otherwise use East Asian Width of the cluster’s first visible code point, and add widths for trailing Halfwidth/Fullwidth Forms within the same cluster (e.g., dakuten/handakuten/prolonged sound mark).
	*/

	const segmenter = new Intl.Segmenter();

	// Whole-cluster zero-width
	const zeroWidthClusterRegex = /^(?:\p{Default_Ignorable_Code_Point}|\p{Control}|\p{Mark}|\p{Surrogate})+$/v;

	// Pick the base scalar if the cluster starts with Prepend/Format/Marks
	const leadingNonPrintingRegex = /^[\p{Default_Ignorable_Code_Point}\p{Control}\p{Format}\p{Mark}\p{Surrogate}]+/v;

	// RGI emoji sequences
	const rgiEmojiRegex = /^\p{RGI_Emoji}$/v;

	function baseVisible(segment) {
		return segment.replace(leadingNonPrintingRegex, '');
	}

	function isZeroWidthCluster(segment) {
		return zeroWidthClusterRegex.test(segment);
	}

	function trailingHalfwidthWidth(segment, eastAsianWidthOptions) {
		let extra = 0;
		if (segment.length > 1) {
			for (const char of segment.slice(1)) {
				if (char >= '\uFF00' && char <= '\uFFEF') {
					extra += eastAsianWidth(char.codePointAt(0), eastAsianWidthOptions);
				}
			}
		}

		return extra;
	}

	function stringWidth(input, options = {}) {
		if (typeof input !== 'string' || input.length === 0) {
			return 0;
		}

		const {
			ambiguousIsNarrow = true,
			countAnsiEscapeCodes = false,
		} = options;

		let string = input;

		if (!countAnsiEscapeCodes) {
			string = stripAnsi(string);
		}

		if (string.length === 0) {
			return 0;
		}

		let width = 0;
		const eastAsianWidthOptions = {ambiguousAsWide: !ambiguousIsNarrow};

		for (const {segment} of segmenter.segment(string)) {
			// Zero-width / non-printing clusters
			if (isZeroWidthCluster(segment)) {
				continue;
			}

			// Emoji width logic
			if (rgiEmojiRegex.test(segment)) {
				width += 2;
				continue;
			}

			// Everything else: EAW of the cluster’s first visible scalar
			const codePoint = baseVisible(segment).codePointAt(0);
			width += eastAsianWidth(codePoint, eastAsianWidthOptions);

			// Add width for trailing Halfwidth and Fullwidth Forms (e.g., ﾞ, ﾟ, ｰ)
			width += trailingHalfwidthWidth(segment, eastAsianWidthOptions);
		}

		return width;
	}

	/**
	 * @typedef {import('monaco-editor').editor.IEditorOptions} IEditorOptions
	 * @typedef {import('monaco-editor').editor.IGlobalEditorOptions} IGlobalEditorOptions
	 * @typedef {import('monaco-editor').editor.IStandaloneCodeEditor} IStandaloneCodeEditor
	 */

	/**
	 * usage: 
	 * ```js
	 * import MonacoLoader from '../utils/MonacoLoader.js'
	 * import MonacoUtil from '../utils/MonacoUtil.js'
	 *
	 * let monaco = await MonacoLoader.load()
	 * let monacoUtil = new MonacoUtil(monaco)
	 * monacoUtil.addLogTheme()
	 * monacoUtil.enableTimeFormatProvider()
	 *
	 * monacoUtil.enableDragDrop(editorRoot, editor)
	 * monacoUtil.addActions(editor)
	 * monacoUtil.addAppActions(editor)
	 * monacoUtil.initStore(editor, () => {
	 *
	 * }, (cfgs) => {
	 *
	 * })
	 *
	 *```
	 */
	class MonacoUtil {

	    /**
	     * @param {import('monaco-editor')} monaco 
	     */
	    constructor(monaco) {
	        /** @type{import('monaco-editor')} */
	        this.monaco = monaco;
	        this.rawMobileConfig = {
	            glyphMargin: false,
	            lineNumbersMinChars: 5,
	            lineDecorationsWidth: 10,
	        };
	    }

	    updateRawMobileConfig(editor) {
	        this.rawMobileConfig.glyphMargin = editor.getOption(this.monaco.editor.EditorOption.glyphMargin);
	        this.rawMobileConfig.lineNumbersMinChars = editor.getOption(this.monaco.editor.EditorOption.lineNumbersMinChars);
	        this.rawMobileConfig.lineDecorationsWidth = editor.getOption(this.monaco.editor.EditorOption.lineDecorationsWidth);
	        editor.updateOptions({ domReadOnly: true, });
	    }

	    addActions(editor) {
	        this.updateRawMobileConfig(editor);
	        setUpActions(this.monaco, editor, this.rawMobileConfig);
	    }

	    addAppActions(editor) {
	        setUpAppActions(this.monaco, editor);
	    }

	    addLogTheme() {
	        setUpLogTheme(this.monaco);
	    }

	    enableTimeFormatProvider() {
	        addTimeFormatProvider(this.monaco);
	    }

	    enableDragDrop(root, editor) {
	        setUpDragDrop(root, editor);
	    }

	    /**
	     * @param {import('monaco-editor').editor.IStandaloneCodeEditor} editor 
	     * @param {()=>Promise<{}>} loader 
	     * @param {(options)=>void} onSave 
	     */
	    async initStore(editor, loader, onSave) {
	        /** @type{IEditorOptions&IGlobalEditorOptions&{language?:string}} */
	        let cfg = await loader() || {};
	        if (cfg.language !== undefined) {
	            this.monaco.editor.setModelLanguage(editor.getModel(), cfg.language);
	        }
	        editor.updateOptions(cfg);

	        editor.onDidChangeModelLanguage(e => {
	            cfg.language = e.newLanguage;
	            onSave(cfg);
	        });

	        editor.onDidChangeConfiguration(e => {
	            console.log('onDidChangeConfiguration', e);
	            cfg.readOnly = editor.getOption(this.monaco.editor.EditorOption.readOnly);
	            cfg.fontSize = editor.getOption(this.monaco.editor.EditorOption.fontSize);
	            cfg.wordWrap = editor.getOption(this.monaco.editor.EditorOption.wordWrap);
	            onSave(cfg);
	        });

	    }

	    /**
	     * @param {import('monaco-editor').editor.ICodeEditor} editor 
	     * @param {EditOptions} option 
	     * @param {EditCallback} cb 
	     */
	    static editText(editor, option, cb) {
	        editText(editor, option, cb);
	    }
	}


	/**
	 * @typedef {(text:String)=>Promise<String>|string} EditCallback
	 */
	/**
	 * @typedef {Object} EditOptions
	 * @property {boolean} [append]
	 * @property {boolean} [insert]
	 * @property {boolean} [noChange]
	 * @property {boolean} [replace]
	 * @property {boolean} [handleEmptySelection]
	 */

	/**
	* @param {import('monaco-editor').editor.ICodeEditor} editor 
	* @param {EditOptions} option 
	* @param {EditCallback} cb 
	*/
	async function editText(editor, option, cb) {
	    try {
	        let operations = [];
	        let model = editor.getModel();
	        let selection = editor.getSelection();
	        let selections = editor.getSelections();
	        if (!option.handleEmptySelection && selection.isEmpty() || option.replace) {
	            let lineCount = model.getLineCount();
	            let maxColumn = model.getLineMaxColumn(lineCount);
	            selections = [selection.setStartPosition(0, 0).setEndPosition(lineCount, maxColumn)];
	            if (option.insert) {
	                selections = [selection];
	            }
	        }
	        for (let i = 0; i < selections.length; i++) {
	            const selection = selections[i];
	            let text = model.getValueInRange(selection);
	            let result = await cb(text);
	            console.log('result:', result);
	            let range = selection;
	            if (option.append) {
	                range = range.setStartPosition(selection.endLineNumber, selection.endColumn);
	            }
	            operations.push({
	                range: range,
	                text: result
	            });
	        }
	        if (!option.noChange) {
	            editor.executeEdits('action', operations);
	        }
	    } catch (error) {
	        window.dispatchEvent(new ErrorEvent('error', error));
	        console.error(error);
	    }
	}

	/**
	 * @param {string} value
	 */
	function convertLineToNumber(value) {
	    let match = value.match(/(\d+\.?\d*e-\d+)|(\d+\.?\d*e\d+)|(\d*\.\d+)|(\d+)/g) || [];
	    let nums = match.map((/** @type {string} */ o) => parseFloat(o));
	    return nums[0] ?? Infinity
	}

	/**
	 * @param {import('monaco-editor')} monaco 
	 * @param {import('monaco-editor').editor.IStandaloneCodeEditor} editor 
	 */
	function setUpActions(monaco, editor, rawConfig) {

	    /** @type{import('monaco-editor').editor.IActionDescriptor[]} */
	    let actions = [
	        {
	            id: 'y-wrap-id',
	            label: 'Toggle Soft Wrap',
	            keybindings: [
	                monaco.KeyMod.Alt | monaco.KeyCode.KeyZ,
	            ],
	            precondition: null,
	            keybindingContext: null,
	            contextMenuGroupId: 'navigation',
	            contextMenuOrder: 1.5,
	            run: function (ed) {
	                let optionValue = ed.getOption(monaco.editor.EditorOption.wordWrap);
	                if (optionValue == 'on') {
	                    ed.updateOptions({ wordWrap: "off" });
	                } else {
	                    ed.updateOptions({ wordWrap: "on" });
	                }
	            }
	        },
	        {
	            id: 'y-zoom-out',
	            label: 'Zoom Out',
	            keybindings: [
	                monaco.KeyMod.Alt | monaco.KeyCode.BracketLeft,
	            ],
	            precondition: null,
	            keybindingContext: null,
	            contextMenuGroupId: 'navigation',
	            contextMenuOrder: 1.5,
	            run: function (ed) {
	                let optionValue = ed.getOption(monaco.editor.EditorOption.fontSize);
	                optionValue--;
	                ed.updateOptions({ fontSize: optionValue });
	            }
	        },
	        {
	            id: 'y-zoom-in',
	            label: 'Zoom In',
	            keybindings: [
	                monaco.KeyMod.Alt | monaco.KeyCode.BracketRight,
	            ],
	            precondition: null,
	            keybindingContext: null,
	            contextMenuGroupId: 'navigation',
	            contextMenuOrder: 1.5,
	            run: function (ed) {
	                let optionValue = ed.getOption(monaco.editor.EditorOption.fontSize);
	                optionValue++;
	                ed.updateOptions({ fontSize: optionValue });
	            }
	        },
	        {
	            id: 'y-toggle-readonly',
	            label: 'Toggle readOnly',
	            keybindings: [
	                monaco.KeyMod.Alt | monaco.KeyCode.Backslash,
	            ],
	            precondition: null,
	            keybindingContext: null,
	            contextMenuGroupId: 'navigation',
	            contextMenuOrder: 1.5,
	            run: function (ed) {
	                let optionValue = ed.getOption(monaco.editor.EditorOption.readOnly);
	                optionValue = !optionValue;
	                ed.updateOptions({ readOnly: optionValue });
	            }
	        },
	        {
	            id: 'y-toggle-mobile',
	            label: 'Toggle Mobile',
	            keybindings: [],
	            precondition: null,
	            keybindingContext: null,
	            contextMenuGroupId: 'navigation',
	            contextMenuOrder: 1.6,
	            run: function (ed) {
	                let lineDecorationsWidth = ed.getOption(monaco.editor.EditorOption.lineDecorationsWidth);
	                if (lineDecorationsWidth) {
	                    editor.updateOptions({
	                        lineDecorationsWidth: 0,
	                        glyphMargin: false,
	                        lineNumbersMinChars: 0,
	                    });
	                } else {
	                    editor.updateOptions({
	                        glyphMargin: rawConfig.glyphMargin,
	                        lineNumbersMinChars: rawConfig.lineNumbersMinChars,
	                        lineDecorationsWidth: rawConfig.lineDecorationsWidth,
	                    });
	                }
	            }
	        },
	        {
	            id: 'y-toggle-folding',
	            label: 'Toggle Folding',
	            keybindings: [],
	            precondition: null,
	            keybindingContext: null,
	            contextMenuGroupId: 'navigation',
	            contextMenuOrder: 1.6,
	            run: function (ed) {
	                let folding = ed.getOption(monaco.editor.EditorOption.folding);
	                editor.updateOptions({ folding: !folding, });
	            }
	        },
	        {
	            id: 'y-toggle-foldingControls',
	            label: 'Toggle FoldingControls',
	            keybindings: [],
	            precondition: null,
	            keybindingContext: null,
	            contextMenuGroupId: 'navigation',
	            contextMenuOrder: 1.6,
	            run: function (ed) {
	                let showFoldingControls = ed.getOption(monaco.editor.EditorOption.showFoldingControls);
	                if (showFoldingControls == 'never') {
	                    editor.updateOptions({ showFoldingControls: 'mouseover', });
	                } else {
	                    editor.updateOptions({ showFoldingControls: 'never', });
	                }
	            }
	        },
	        {
	            id: 'y-toggle-minmap',
	            label: 'Toggle Minmap',
	            keybindings: [],
	            precondition: null,
	            keybindingContext: null,
	            contextMenuGroupId: 'navigation',
	            contextMenuOrder: 1.6,
	            run: function (ed) {
	                let minimap = ed.getOption(monaco.editor.EditorOption.minimap);
	                minimap = { ...minimap, enabled: !minimap.enabled };
	                ed.updateOptions({ minimap: minimap, });
	            }
	        },
	        {
	            id: 'y-remove-empty',
	            label: 'Line Remove Empty',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return text.split('\n').filter(o => o.trim()).join('\n')
	                });
	            }
	        },
	        {
	            id: 'y-remove-duplicate',
	            label: 'Line Remove Duplicate',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    if (!text.endsWith('\n')) text += '\n';
	                    return [...new Set(text.split('\n'))].join('\n')
	                });
	            }
	        },
	        {
	            id: 'y-group-duplicate',
	            label: 'Line Group Duplicate',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    let map = {};
	                    let lines = text.split('\n');
	                    let arr = [];
	                    for (const line of lines) {
	                        if (map[line]) {
	                            map[line].count++;
	                        } else {
	                            map[line] = { count: 1, line: line };
	                            arr.push(map[line]);
	                        }
	                    }
	                    return arr.map(o => `${o.count.toString().padStart(5)}  ${o.line}`).join('\n')
	                });
	            }
	        },
	        {
	            id: 'y-group-time',
	            label: 'Line Group Time',
	            run: async function (ed) {

	                let params = await ViewDialogNoCode.getDialogParams(null, {
	                    title: 'duration',
	                    forms: [
	                        { type: 'br' },
	                        { type: 'br' },
	                        { type: 'input', key: 'duration', value: '300', label: 'duration', focus: true, icon: 'schedule', width: '90%' },
	                        { type: 'br' },
	                        { type: 'br' },
	                    ],
	                });
	                if (!params) {
	                    return
	                }
	                let duration = parseInt(params.duration);

	                function parseTime(str) {
	                    let m = str.match(/\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d\.\d\d\d/);
	                    console.log(m);
	                    if (m) {
	                        return dayjs(m[0]).toDate().getTime()
	                    }
	                    m = str.match(/\d\d-\d\d-\d\d \d\d:\d\d:\d\d\.\d\d\d/);
	                    console.log(m);
	                    if (m) {
	                        return dayjs(`20${m[0]}`).toDate().getTime()
	                    }
	                    return 0
	                }
	                editText(ed, {}, (text) => {
	                    let lines = text.split('\n');
	                    let arr = [];
	                    let lastTime = 0;
	                    for (const line of lines) {
	                        let time = parseTime(line);
	                        console.log(`time : ${time} lastTime:${lastTime} duration:${time - lastTime}`);
	                        if (time - lastTime > duration) {
	                            arr.push(`\n\n    ######## wait duration : ${time - lastTime}`);
	                        }
	                        if (time > 0) {
	                            lastTime = time;
	                        }
	                        arr.push(line);
	                    }
	                    return arr.join('\n')
	                });
	            }
	        },
	        {
	            id: 'y-pack-time',
	            label: 'Line Pack Time',
	            run: async function (ed) {

	                let params = await ViewDialogNoCode.getDialogParams(null, {
	                    title: 'duration',
	                    forms: [
	                        { type: 'br' },
	                        { type: 'br' },
	                        { type: 'input', key: 'duration', value: '300', label: 'duration', focus: true, icon: 'schedule', width: '90%' },
	                        { type: 'br' },
	                        { type: 'br' },
	                    ],
	                });
	                if (!params) {
	                    return
	                }
	                let duration = parseInt(params.duration);

	                function parseTime(str) {
	                    let m = str.match(/\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d\.\d\d\d/);
	                    console.log(m);
	                    if (m) {
	                        return dayjs(m[0]).toDate().getTime()
	                    }
	                    m = str.match(/\d\d-\d\d-\d\d \d\d:\d\d:\d\d\.\d\d\d/);
	                    console.log(m);
	                    if (m) {
	                        return dayjs(`20${m[0]}`).toDate().getTime()
	                    }
	                    return 0
	                }
	                editText(ed, {}, (text) => {
	                    let lines = text.split('\n');
	                    let arr = [];
	                    let lastTime = 0;
	                    let time = 0;
	                    let count = 0;
	                    for (const line of lines) {
	                        time = parseTime(line);
	                        console.log(`time : ${time} lastTime:${lastTime} duration:${time - lastTime}`);
	                        if (time <= 0) {
	                            continue
	                        }
	                        count++;
	                        if (time - lastTime > duration) {
	                            arr.push(`${Formatter.dateStr(lastTime)} ~ ${Formatter.dateStr(time)} ·: ${count}`);
	                            lastTime = time;
	                            count = 0;
	                        }
	                    }
	                    if (count > 0) {
	                        arr.push(`${Formatter.dateStr(lastTime)} ~ ${Formatter.dateStr(time)} ·: ${count}`);
	                    }
	                    return arr.join('\n')
	                });
	            }
	        },
	        {
	            id: 'y-sort-num',
	            label: 'Line Sort Number',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    let lines = text.split('\n');
	                    lines.sort((l, h) => convertLineToNumber(l) - convertLineToNumber(h));
	                    return lines.join('\n')
	                });
	                ed.setSelection({ startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0, });
	            }
	        },
	        {
	            id: 'y-line-reverse',
	            label: 'Line Reverse',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    let lines = text.split('\n');
	                    return lines.reverse().join('\n')
	                });
	            }
	        },
	        {
	            id: 'y-trim',
	            label: 'Line trim',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return text.split('\n').map(o => o.trim()).join('\n')
	                });
	            }
	        },
	        {
	            id: 'y-line-repeat',
	            label: 'Line Repeat',
	            run: async function (ed) {
	                editText(ed, {}, async (text) => {
	                    let params = await ViewDialogNoCode.getDialogParams(null, {
	                        title: 'count',
	                        forms: [
	                            { type: 'br' },
	                            { type: 'br' },
	                            { type: 'input', key: 'count', value: '3', label: 'count', focus: true, icon: 'exposure', width: '90%' },
	                            { type: 'br' },
	                            { type: 'br' },
	                        ],
	                    });
	                    if (!params) {
	                        return
	                    }
	                    let count = parseInt(params.count);
	                    return text.repeat(count)
	                });
	            }
	        },
	        {
	            id: 'y-comment-align',
	            label: 'Comment Align',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    let maxLength = 0;
	                    let lines = text.split('\n');
	                    lines.forEach(function (item) {
	                        item = item.replace('//', '#sp#//');
	                        let items = item.split('#sp#');
	                        if (items.length == 2) {
	                            maxLength = Math.max(maxLength, items[0].length);
	                        }
	                    });
	                    let newLines = [];
	                    let m = /http.?:\/\//;
	                    lines.forEach(function (item) {
	                        if (!m.test(item)) {
	                            item = item.replace('//', '#sp#//');
	                        }
	                        let items = item.split('#sp#//');
	                        let newLine = items[0];
	                        if (items.length == 2) {
	                            if (items[0].trim().length == 0) {
	                                newLine += '// ' + items[1].trim();
	                            } else {
	                                let space = maxLength - items[0].length;
	                                newLine += ' '.repeat(space) + '// ' + items[1].trim();
	                            }
	                        }
	                        newLines.push(newLine);
	                    });
	                    return newLines.join('\n')
	                });
	            }
	        },
	        {
	            id: 'y-cursor-align',
	            label: 'Cursor Align',
	            run: async function (ed) {
	                let editor = ed;
	                let selections = editor.getSelections();
	                console.log(selections);
	                let maxStringWidth = 0;
	                let insertSpaces = [];
	                let model = editor.getModel();
	                for (let i = 0; i < selections.length; i++) {
	                    const selection = selections[i];
	                    let text = model.getValueInRange(selection.setStartPosition(selection.startLineNumber, 0));
	                    let width = stringWidth(text);
	                    maxStringWidth = Math.max(maxStringWidth, width);
	                    insertSpaces[i] = width;
	                }
	                maxStringWidth++;
	                for (let i = 0; i < insertSpaces.length; i++) {
	                    const insertSpace = insertSpaces[i];
	                    insertSpaces[i] = maxStringWidth - insertSpace;
	                }
	                let index = 0;
	                editText(ed, { append: true, handleEmptySelection: true }, () => {
	                    return ' '.repeat(insertSpaces[index++])
	                });
	            }
	        },
	        {
	            id: 'y-format-multi-line-comment',
	            label: 'Format Multi Line Comment',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return text.replace(/(^|\n)(.*?\/\*[\s\S]*?\*\/)/g, (a, b, c) => {
	                        /** @type{string[]} */
	                        let lines = c.split('\n');
	                        if (lines.length < 2) {
	                            return a
	                        }
	                        let results = [];
	                        let indent = ' ';
	                        for (let i = 0; i < lines.length; i++) {
	                            const line = lines[i];
	                            if (i == 0 && line.trim().startsWith('/**')) {
	                                indent = ' '.repeat(line.indexOf('/**') + 1);
	                                results.push(line);
	                                continue
	                            }
	                            if (i == lines.length - 1 && line.trim() == '*/') {
	                                results.push(`${indent}${line.trimStart()}`);
	                                continue
	                            }
	                            results.push(line.replace(/\s*\* ?/, `${indent}* `));
	                        }
	                        return a.replace(c, results.join('\n'))
	                    })
	                });
	            }
	        },
	        {
	            id: 'y-format-json',
	            label: 'Format JSON',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return vkbeautify.json(text)
	                });
	            }
	        },
	        {
	            id: 'y-json-ascii-table',
	            label: 'JSON Ascii Table',
	            async run(ed) {
	                editText(ed, { append: true }, async (text) => {
	                    let list = await evalParser(text);
	                    return asciitable(list)
	                });
	            }
	        },
	        {
	            id: 'y-min-json',
	            label: 'Min JSON',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return vkbeautify.jsonmin(text)
	                });
	            }
	        },
	        {
	            id: 'y-format-xml',
	            label: 'Format XML',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return vkbeautify.xml(text)
	                });
	            }
	        },
	        {
	            id: 'y-min-xml',
	            label: 'Min XML',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return vkbeautify.xmlmin(text)
	                });
	            }
	        },
	        {
	            id: 'y-format-css',
	            label: 'Format CSS',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return vkbeautify.css(text)
	                });
	            }
	        },
	        {
	            id: 'y-min-css',
	            label: 'Min CSS',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return vkbeautify.cssmin(text)
	                });
	            }
	        },
	        {
	            id: 'y-format-js',
	            label: 'Format JS',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return js_beautify(text)
	                });
	            }
	        },
	        {
	            id: 'y-format-sql',
	            label: 'Format SQL',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return vkbeautify.sql(text)
	                });
	            }
	        },
	        {
	            id: 'y-min-sql',
	            label: 'Min SQL',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return vkbeautify.sqlmin(text)
	                });
	            }
	        },
	        {
	            id: 'y-format-time',
	            label: 'Format Time',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return text.replace(/(\d{11,13})|(\d{10})/g, function (val) {
	                        let date = parseInt(val);
	                        // java中的Integer.MAX_VALUE
	                        if (date == 2147483647) { return val }
	                        if (val.length == 10) {
	                            if (val.startsWith('19')) { return val }
	                            if (val.startsWith('20')) { return val }
	                            date *= 1000;
	                        }
	                        return dayjs(date).format('YYYY-MM-DD HH:mm:ss.SSS')
	                    })
	                });
	            }
	        },
	        {
	            id: 'y-parse-time',
	            label: 'Parse Time',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    let textTrim = text.trim();
	                    let millis = new Date(textTrim).getTime();
	                    if (!isNaN(millis)) {
	                        return '' + millis
	                    }
	                    return text
	                });
	            }
	        },
	        {
	            id: 'y-format-bytes',
	            label: 'Format bytes',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return text.replace(/(\d+)/g, (val) => {
	                        let size = parseInt(val);
	                        return String(formatByteSize(size))
	                    })
	                });
	            }
	        },
	        {
	            id: 'y-codec-parseJSON',
	            label: 'parse JSON',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return JSON.parse(text)
	                });
	            }
	        },
	        {
	            id: 'y-codec-deepParseJSON',
	            label: 'deep parse JSON',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return Formatter.jsonFormat(Formatter.jsonDeepParse(text))
	                });
	            }
	        },
	        {
	            id: 'y-codec-rearrange-json-key',
	            label: 'rearrange JSON key',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return Formatter.jsonFormat(rearrangeJsonKey(JSON.parse(text)))
	                });
	            }
	        },
	        {
	            id: 'y-codec-stringify',
	            label: 'stringify',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return JSON.stringify(text)
	                });
	            }
	        },
	        {
	            id: 'y-codec-encodeUri',
	            label: 'encodeUri',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return encodeURIComponent(text)
	                });
	            }
	        },
	        {
	            id: 'y-codec-encodeBase64',
	            label: 'encodeBase64',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return base64encode(textEncode(text))
	                });
	            }
	        },
	        {
	            id: 'y-codec-encodeHex',
	            label: 'encodeHex',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return hexEncode(textEncode(text))
	                });
	            }
	        },
	        {
	            id: 'y-codec-encodeNative',
	            label: 'encodeNative',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return native2ascii(text)
	                });
	            }
	        },
	        {
	            id: 'y-codec-encodeUnicode',
	            label: 'encodeUnicode',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return toUnicode(text)
	                });
	            }
	        },
	        {
	            id: 'y-codec-encodeEscape',
	            label: 'encodeEscape',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return escape(text)
	                });
	            }
	        },
	        {
	            id: 'y-codec-decodeUri',
	            label: 'decodeUri',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return decodeURIComponent(text)
	                });
	            }
	        },
	        {
	            id: 'y-codec-decodeBase64',
	            label: 'decodeBase64',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return textDecode(base64decode(text))
	                });
	            }
	        },
	        {
	            id: 'y-codec-decodeHex',
	            label: 'decodeHex',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return textDecode(hexDecode(text))
	                });
	            }
	        },
	        {
	            id: 'y-codec-decodeNative',
	            label: 'decodeNative',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return ascii2native(text)
	                });
	            }
	        },
	        {
	            id: 'y-codec-decodeUnicode',
	            label: 'decodeUnicode',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return fromUnicode(text)
	                });
	            }
	        },
	        {
	            id: 'y-codec-decodeUnescape',
	            label: 'decodeUnescape',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return unescape(text)
	                });
	            }
	        },
	        {
	            id: 'y-codec-decode-html-entry',
	            label: 'decode html entry',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    let div = document.createElement('div');
	                    div.innerHTML = text;
	                    return div.textContent
	                });
	            }
	        },
	        {
	            id: 'y-codec-guid',
	            label: 'guid',
	            run: async function (ed) {
	                editText(ed, { insert: true, handleEmptySelection: true }, (text) => {
	                    let buffer = new Uint8Array(16);
	                    crypto.getRandomValues(buffer);
	                    return [...buffer].map((item) => (item > 15 ? '' : '0') + item.toString(16)).join('')
	                });
	            }
	        },
	        {
	            id: 'y-codec-md5',
	            label: 'md5',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return cryptoJsExports.MD5(text).toString()
	                });
	            }
	        },
	        {
	            id: 'y-codec-sha1',
	            label: 'sha1',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return cryptoJsExports.SHA1(text).toString()
	                });
	            }
	        },
	        {
	            id: 'y-codec-sha256',
	            label: 'sha256',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return cryptoJsExports.SHA256(text).toString()
	                });
	            }
	        },
	        {
	            id: 'y-codec-sha512',
	            label: 'sha512',
	            run: async function (ed) {
	                editText(ed, {}, (text) => {
	                    return cryptoJsExports.SHA512(text).toString()
	                });
	            }
	        },
	        {
	            id: 'y-codec-eval',
	            label: 'eval',
	            run: async function (ed) {
	                editText(ed, { append: true }, (text) => {
	                    text = text.replace(/=\s*$/, '');
	                    return String(`${window['eval'](text)}`)
	                });
	            }
	        },
	        {
	            id: 'y-group-sort_num-reverse',
	            label: 'Group SortNum Reverse',
	            /**
	             * @param {import('monaco-editor').editor.IStandaloneCodeEditor} ed 
	             */
	            run: async function (ed) {
	                await ed.getAction('y-group-duplicate').run();
	                await ed.getAction('y-sort-num').run();
	                await ed.getAction('y-line-reverse').run();
	            }
	        },
	        {
	            id: "y-random-number",
	            label: "random number",
	            run: async function (ed) {
	                editText(ed, { insert: true, handleEmptySelection: true, }, async () => {
	                    return `${Math.random()}`.replace('0.', '')
	                });
	            },
	        },
	        {
	            id: "y-random-hex",
	            label: "random hex",
	            run: async function (ed) {
	                editText(ed, { insert: true, handleEmptySelection: true, }, async () => {
	                    let buffer = new Uint8Array(4);
	                    crypto.getRandomValues(buffer);
	                    return hexEncode(buffer)
	                });
	            },
	        },
	        {
	            id: "y-sequence-number-1",
	            label: "sequence number 1",
	            run: async function (ed) {
	                let seq = 1;
	                editText(ed, { insert: true }, async () => {
	                    return `${seq++}`
	                });
	            },
	        },
	        {
	            id: "y-sequence-number-一",
	            label: "sequence number 一",
	            run: async function (ed) {
	                let seq = 1;
	                editText(ed, { insert: true }, async () => {
	                    return Nzh.cn.encodeS(seq++)
	                });
	            },
	        },
	        {
	            id: "y-sequence-number-壹",
	            label: "sequence number 壹",
	            run: async function (ed) {
	                let seq = 1;
	                editText(ed, { insert: true }, async () => {
	                    return Nzh.cn.encodeB(seq++)
	                });
	            },
	        },
	        {
	            id: "y-xing-ming",
	            label: "xing ming",
	            run: async function (ed) {
	                let g = new NameGenerate();
	                editText(ed, { insert: true }, async () => {
	                    return g.get()
	                });
	            },
	        },
	        buildSequenceNum("a", 0),
	        buildSequenceNum("A", 0),
	        buildSequenceNum("①", 0),
	        buildSequenceNum("Ⅰ", 0),
	        buildSequenceNum("ⅰ", 0),
	        buildSequenceNum("㍘", 0),
	        buildSequenceNum("㎀", 0),
	        buildSequenceNum("㏠", 0),
	        buildSequenceNum("😀", 0),
	        buildSequenceNum("👩", 0),
	        buildSequenceNum("💪", 0),
	        buildSequenceNum("🎈", 0),
	        buildSequenceNum("🍕", 0),
	        buildSequenceNum("🚗", 0),
	        buildSequenceNum("❤", 0),
	        buildSequenceNum("☮", 0),
	        buildSequenceNum("0️⃣", 0),
	        buildSequenceNum("🔴", 0),
	        buildSequenceNum("🟥", 0),
	        buildSequenceNum("🔶", 0),
	        buildSequenceNum("🕐", 0),
	        ...buildChangeLanguageActions(monaco),
	        {
	            id: "y-qr-code",
	            label: "QRCode",
	            run: async function (ed) {
	                editText(ed, {}, async (text) => {
	                    new DialogQRCode({ target: document.body, props: { message: text } });
	                    return text
	                });
	            },
	        },
	        {
	            id: "y-full-space",
	            label: "full space",
	            run: async function (ed) {
	                editText(ed, {}, async (text) => {
	                    return ' '.repeat(text.length)
	                });
	            },
	        },
	        {
	            id: "y-cursors-drop",
	            label: "cursors drop",
	            /** @param {import('monaco-editor').editor.IStandaloneCodeEditor} ed */
	            run: async function (ed) {
	                let selections = ed.getSelections();
	                let tmp = [];
	                for (let i = 0; i < selections.length; i += 2) {
	                    const element = selections[i];
	                    tmp.push(element);
	                }
	                ed.setSelections(tmp);
	            },
	        },
	        {
	            id: "y-numbers-summation",
	            label: "numbers summation 求和",
	            /** @param {import('monaco-editor').editor.IStandaloneCodeEditor} ed */
	            run: async function (ed) {
	                editText(ed, { append: true }, async (text) => {
	                    let match = text.split(/[ ,;\r\n\t"]/) || [];
	                    let numbers = match.map((o) => parseFloat(o)).filter((o) => !isNaN(o));
	                    return `summation: ${numbers.reduce((p, c) => p + c, 0)}`
	                });
	            },
	        },
	        {
	            id: "y-numbers-average",
	            label: "numbers average 求平均值",
	            /** @param {import('monaco-editor').editor.IStandaloneCodeEditor} ed */
	            run: async function (ed) {
	                editText(ed, { append: true }, async (text) => {
	                    let match = text.split(/[ ,;\r\n\t"]/) || [];
	                    let numbers = match.map((o) => parseFloat(o)).filter((o) => !isNaN(o));
	                    return `average: ${numbers.reduce((p, c) => p + c, 0) / numbers.length}`
	                });
	            },
	        },
	        {
	            id: "y-translate-to-en",
	            label: "translate to en",
	            /** @param {import('monaco-editor').editor.IStandaloneCodeEditor} ed */
	            run: async function (ed) {
	                editText(ed, {}, async (text) => {
	                    let translate = await loadTranslate();
	                    let result = await translate('', 'en', [text]);
	                    return result[0].TranslatedText
	                });
	            },
	        },
	        {
	            id: "y-translate-to-zh",
	            label: "translate to zh",
	            /** @param {import('monaco-editor').editor.IStandaloneCodeEditor} ed */
	            run: async function (ed) {
	                editText(ed, {}, async (text) => {
	                    let translate = await loadTranslate();
	                    let result = await translate('', 'zh-CHS', [text]);
	                    return result[0].TranslatedText
	                });
	            },
	        },
	        {
	            id: "y-lorem",
	            label: "lorem",
	            run: async function (/**@type{IStandaloneCodeEditor}*/ed) {
	                editText(ed, { insert: true }, async () => {
	                    return `Lorem ipsum dolor sit amet consectetur adipisicing elit. Deserunt nulla quisquam blanditiis fugit quia beatae, ducimus in provident commodi similique, necessitatibus quae exercitationem doloribus hic impedit maxime voluptate velit consequuntur?`
	                });
	            }
	        },
	    ];

	    for (const action of actions) {
	        editor.addAction(action);
	    }
	}

	/**
	 * @param {import('monaco-editor')} monaco 
	 */
	function buildChangeLanguageActions(monaco) {
	    return monaco.languages.getLanguages().map(lang => {
	        return {
	            id: `y-language-${lang.id}`,
	            label: `language ${lang.id} ${lang.aliases?.join(' ')}`,
	            run: async function (ed) {
	                monaco.editor.setModelLanguage(ed.getModel(), lang.id);
	            }
	        }
	    })
	}

	function buildSequenceNum(char, start) {
	    return {
	        id: `y-sequence-number-${char}`,
	        label: `sequence number ${char}`,
	        run: async function (ed) {
	            let seq = start;
	            let codes = [];
	            let endCode = char.charCodeAt(0);
	            for (let i = 0; i < char.length; i++) {
	                const charCode = char.charCodeAt(i);
	                codes.push(charCode);
	                endCode = charCode;
	            }
	            codes.pop();
	            editText(ed, { insert: true }, async () => {
	                return String.fromCharCode(...codes, endCode + seq++)
	            });
	        },
	    }
	}

	/**
	 * @param {import('monaco-editor')} monaco 
	 * @param {import('monaco-editor').editor.IStandaloneCodeEditor} editor 
	 */
	function setUpAppActions(monaco, editor) {
	    let actions = [

	    ];

	    for (const action of actions) {
	        editor.addAction(action);
	    }
	}

	let hasAddTimeFormatProvider = false;

	/**
	 * @typedef {import('monaco-editor').editor.ITextModel} ITextModel
	 * @typedef {import('monaco-editor').Position} Position
	 */

	/**
	 * @param {import('monaco-editor')} monaco 
	 */
	function addTimeFormatProvider(monaco) {
	    if (hasAddTimeFormatProvider) return
	    hasAddTimeFormatProvider = true;

	    const timeFormatProvider = {
	        provideHover(/**@type{ITextModel}*/document, /**@type{Position}*/position) {
	            let text = document.getValueInRange(new monaco.Range(position.lineNumber, position.column - 12, position.lineNumber, position.column + 12));
	            let match = text.match(/(\d{13})|(\d{10})/);
	            if (match) {
	                let timeStr = match[0];
	                let startColumn = position.column - 12 + text.indexOf(timeStr);
	                let endColumn = startColumn + timeStr.length;
	                return {
	                    contents: [{ value: Formatter.formatTimeInString(timeStr) }],
	                    range: new monaco.Range(position.lineNumber, startColumn, position.lineNumber, endColumn)
	                }
	            } else {
	                return null
	            }
	        }
	    };

	    monaco.languages.getLanguages().forEach(lang => {
	        monaco.languages.registerHoverProvider(lang.id, timeFormatProvider);
	    });
	}

	let hasSetLogTheme = false;

	function setUpLogTheme(monaco) {
	    if (hasSetLogTheme) return
	    hasSetLogTheme = true;
	    monaco.languages.register({ id: 'log', aliases: ['log'] });
	    monaco.languages.setMonarchTokensProvider('log', {
	        tokenizer: {
	            root: [
	                [/\[ERROR\]/, "log-error"],
	                [/^\tat .*/, "log-error"],
	                [/\[INFO \]/, "log-info"],
	                [/\[WARN \]/, "log-warn"],
	                [/URL:.* /, "log-url"],
	                // 20-04-22 10:38:05.501
	                [/\d\d-\d\d-\d\d \d\d:\d\d:\d\d\.\d+/, "log-date"],
	                [/TAG - StudyV6View/, "log-study-v6"],
	                [/JSInterfaceV6 /, "log-JSInterfaceV6"],
	                [/TAG - AsecSession/, "log-AsecSession"],
	                [/JS-LOG:.*/, "log-js-log"],
	                [/LogMgr - upload task onSuccess/, "log-task-upload-success"],
	            ]
	        }
	    });
	    monaco.editor.defineTheme('EditorTheme', {
	        base: 'vs',
	        inherit: true,
	        rules: [
	            { token: 'log-info', foreground: '008000' },
	            { token: 'log-error', foreground: 'ff0000', fontStyle: 'bold' },
	            { token: 'log-notice', foreground: 'FFA500' },
	            { token: 'log-warn', foreground: '888800' },
	            { token: 'log-date', foreground: '993300' },
	            { token: 'log-url', foreground: '0000ff' },
	            { token: 'log-study-v6', foreground: '8e24aa' },
	            { token: 'log-JSInterfaceV6', foreground: '304ffe' },
	            { token: 'log-AsecSession', foreground: 'ad1457', fontStyle: 'bold' },
	            { token: 'log-js-log', foreground: '6200ea', fontStyle: 'bold' },
	            { token: 'log-task-upload-success', foreground: 'f50057', fontStyle: 'bold' },
	        ],
	        colors: {
	            'editor.foreground': '#000000'
	        }
	    });
	}

	function setUpDragDrop(root, editor) {
	    const ignore = (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	    };
	    root.ondragenter = ignore;
	    root.ondragover = ignore;
	    root.ondragleave = ignore;
	    root.ondrop = async (e) => {
	        if (e.dataTransfer.types[0] == 'Files') {
	            if (e.dataTransfer.files.length == 0) {
	                return
	            }
	            ignore(e);
	            let file = e.dataTransfer.files[0];
	            let info = await LocalFileReader.readFile(file);
	            let d = new TextDecoder();
	            let string = d.decode(info.buffer);
	            editText(editor, { append: true }, () => {
	                return string
	            });
	        }
	        if (e.dataTransfer.types[0] == 'text/plain') {
	            ignore(e);
	            let data = e.dataTransfer.getData('text/plain');
	            editText(editor, { append: true }, () => {
	                return data
	            });
	        }
	    };
	}

	/**
	 * @param {string} ascii
	 * ascii2native
	 */
	function ascii2native(ascii) {
	    let code, i, j, len, native, words;
	    words = ascii.split(/[\\%]u/);
	    native = words[0];
	    for (i = j = 0, len = words.length; j < len; i = ++j) {
	        code = words[i];
	        if (!(i !== 0)) {
	            continue
	        }
	        native += String.fromCharCode(parseInt("0x" + (code.substr(0, 4))));
	        if (code.length > 4) {
	            native += code.substring(4, code.length);
	        }
	    }
	    return native
	}

	/**
	 * @param {string} native
	 */
	function native2ascii(native) {
	    let ascii, charAscii, chars, code, i, j, len;
	    chars = native.split('');
	    ascii = '';
	    for (i = j = 0, len = chars.length; j < len; i = ++j) {
	        code = Number(chars[i].charCodeAt(0));
	        if (code > 127) {
	            charAscii = code.toString(16);
	            charAscii = new String('0000').substr(charAscii.length, 4) + charAscii;
	            ascii += '\\u' + charAscii;
	        } else {
	            ascii += chars[i];
	        }
	    }
	    return ascii
	}

	/**
	 * @param {string} str
	 */
	function toUnicode(str) {
	    let codes = [];
	    for (let i = 0; i < str.length; i++) {
	        codes.push(("000" + str.charCodeAt(i).toString(16)).slice(-4));
	    }
	    return "\\u" + codes.join("\\u")
	}

	function fromUnicode(str) {
	    return unescape(str.replace(/\\/g, "%"))
	}

	async function loadTranslate() {
	    if (!window['mstranslate']) {
	        await new Promise((resolve, reject) => {
	            let script = document.createElement('script');
	            script.src = 'https://yuanliwei.github.io/lib.translate.js';
	            script.onerror = reject;
	            script.onload = resolve;
	            document.head.append(script);
	        });
	    }
	    return window['mstranslate']
	}

	/**
	 * @param {number} size
	 */
	function formatByteSize(size) {
	    if (!size) return ''
	    if (size < 0) { return '0B'.padStart(8, ' ') }
	    let companys = 'B KB MB GB TB'.split(' ');
	    let cur = size;
	    while (cur >= 1024) {
	        companys.shift();
	        cur /= 1024;
	    }
	    return Number(cur.toFixed(2)) + companys[0]
	}

	/** @type{import('table').TableUserConfig} */
	const tableConfig = {
	    border: {
	        topBody: `─`,
	        topJoin: `┬`,
	        topLeft: `┌`,
	        topRight: `┐`,

	        bottomBody: `─`,
	        bottomJoin: `┴`,
	        bottomLeft: `└`,
	        bottomRight: `┘`,

	        bodyLeft: `│`,
	        bodyRight: `│`,
	        bodyJoin: `│`,

	        joinBody: `─`,
	        joinLeft: `├`,
	        joinRight: `┤`,
	        joinJoin: `┼`
	    }};

	/**
	 * @param {object[]} list
	 */
	function asciitable(list) {
	    // 处理空值情况
	    if (!list || list.length === 0) return ""

	    let cleanlist = list.map(o => {
	        let a = { ...o };
	        let keys = Object.keys(a);
	        for (const k of keys) {
	            let v = a[k];
	            if (typeof v == 'string') {
	                a[k] = v.replace(/[\x00-\x1F\x7F]/g, ' ');
	            }
	        }
	        return a
	    });
	    list = cleanlist;

	    // 自动检测数据结构
	    const isObjectArray = list.every(item =>
	        typeof item === "object" && !Array.isArray(item)
	    );

	    // 构建表头和行数据
	    let headers, rows;
	    if (isObjectArray) {
	        headers = Object.keys(list[0]);
	        rows = list.map(obj => headers.map(header => obj[header]));
	    } else {
	        headers = Array.from({ length: list[0].length }, (_, i) => i.toString());
	        rows = list;
	    }

	    // 生成表格配置
	    const config = {
	        border: tableConfig.border,
	        columns: headers.reduce((acc, _) => {
	            acc.push({ alignment: "left" });
	            return acc
	        }, []),
	        drawHorizontalLine: (/** @type {number} */ lineIndex, /** @type {number} */ rowCount) =>
	            lineIndex <= 1 || lineIndex === rowCount
	    };

	    return srcExports.table([headers, ...rows], config)
	}

	injectStyle(" .setting-container.svelte-161ctoi {z-index: 2;position: fixed;bottom: 50px;right: 50px;width: 50px;user-select: none;height: 50px;background-color: var(--color-alpha-background);text-align: center;opacity: 0.2;font-size: 2.5em;line-height: 50px;border-radius: 50px;cursor: pointer;color: antiquewhite;transition: all ease-in-out 0.8s;}.setting-container.svelte-161ctoi:hover {opacity: 1;}ul.setting-button-group.svelte-161ctoi {position: fixed;bottom: 60px;user-select: none;right: 40px;background-color: white;padding: 10px 0;z-index: 4;border-radius: 0.3em;display: none;box-shadow: 5px 10px 15px 6px rgba(0, 0, 0, 0.2);}li.svelte-161ctoi {list-style: none;font-size: 1.4em;padding: 0.5em 2em;transition: all ease-in-out 0.3s;animation: fadein 0.3s linear 1;background-color: rgba(255, 255, 255, 0);}li.svelte-161ctoi:hover {background-color: bisque;}li.svelte-161ctoi:active {background-color: #340c92;}.setting-container.svelte-161ctoi:hover ~ ul.setting-button-group:where(.svelte-161ctoi), ul.setting-button-group.svelte-161ctoi:hover {display: block;}");

	var root = from_html(`<div class="setting-container svelte-161ctoi"><span>⁝</span></div> <ul class="setting-button-group svelte-161ctoi"><li role="presentation" class="svelte-161ctoi">保 存</li> <li role="presentation" class="svelte-161ctoi">导 入</li> <li role="presentation" class="svelte-161ctoi">导 出</li> <li role="presentation" class="svelte-161ctoi">取 消</li></ul>`, 1);

	function SourceEditorMenu($$anchor, $$props) {
		push($$props, false);

		let actionSave = prop($$props, 'actionSave', 8, () => {});
		let actionCancel = prop($$props, 'actionCancel', 8, () => {});
		let actionImport = prop($$props, 'actionImport', 8, () => {});
		let actionExport = prop($$props, 'actionExport', 8, () => {});

		onMount(async () => {});
		init();

		var fragment = root();
		var ul = sibling(first_child(fragment), 2);
		var li = child(ul);

		li.__click = [
			function (...$$args) {
				actionSave()?.apply(this, $$args);
			}
		];

		var li_1 = sibling(li, 2);

		li_1.__click = [
			function (...$$args) {
				actionImport()?.apply(this, $$args);
			}
		];

		var li_2 = sibling(li_1, 2);

		li_2.__click = [
			function (...$$args) {
				actionExport()?.apply(this, $$args);
			}
		];

		var li_3 = sibling(li_2, 2);

		li_3.__click = [
			function (...$$args) {
				actionCancel()?.apply(this, $$args);
			}
		];
		append($$anchor, fragment);
		pop();
	}

	delegate(['click']);

	var app_d_ts = "declare const Base64: {\n    /**\n     * converts a Uint8Array to a Base64 string.\n     * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5\n     * @returns {string} Base64 string\n     */\n    fromUint8Array: (u8a: Uint8Array, urlsafe?: boolean) => string;\n    /**\n     * converts a Base64 string to a Uint8Array.\n     */\n    toUint8Array: (a: string) => Uint8Array;\n}\n\ndeclare class GiteeRepoStore {\n    constructor(options: { token: string, owner: string, repo: string, path: string });\n    load(): Promise<string>;\n    save(body: string): Promise<void>;\n    create(content: string): Promise<void>;\n}\n\ndeclare class NameGenerate {\n    get(): string;\n}\n\ndeclare class IndexedDBStore {\n    static get(key: string): Promise<any>;\n    static put(key: string, file: any): Promise<void>;\n    static delete(key: string): Promise<void>;\n\n}\n\ndeclare class Utils {\n    Base64: typeof Base64;\n    GiteeRepoStore: typeof GiteeRepoStore;\n    IndexedDBStore: typeof IndexedDBStore;\n    serialize:{\n        parse:(str:string)=>object;\n        stringify:(obj:object)=>string;\n    };\n    getStyle: (regexp: any) => Object;\n    copyToClipboard: (text: any) => Object;\n    md5: (data: any) => Promise<Object>;\n    convertToPinyin: (str: any) => Promise<Object>;\n    loadCryptoJS: () => Promise<Object>;\n    loadPako: () => Promise<Object>;\n    loadEditor: () => Promise<Object>;\n    loadPinyin: () => Promise<Object>;\n    loadMaterialComponents: () => Promise<Object>;\n}\n\ndeclare class View {\n    toast: (message: string) => Object;\n    showLoading: () => Object;\n    setBackgroundImage: (url: string) => Object;\n    showEditor: (root: HTMLElement, source: string, callback: () => void) => Promise<Object>;\n    showConfigEditor: () => Promise<Object>;\n    showContextMenu: (anchor: HTMLElement, item: Object) => Promise<Object>;\n}\n\ndeclare class SvelteStore {\n    set: (new_value: any) => Object;\n    update: (fn: () => void) => Object;\n    subscribe: () => Object;\n}\n\ninterface InitNode {\n    type: 'init';\n    run: () => void\n}\n\ninterface ActionNode {\n    type: 'action';\n    name: string;\n    action: () => void\n}\n\ninterface LinkNode {\n    type: 'link';\n    name: string;\n    url: string;\n}\n\ninterface SearchEngineNode {\n    type: 'search-engine';\n    name: string;\n    url: string;\n}\n\ndeclare type ItemNode = InitNode | ActionNode | LinkNode | SearchEngineNode\n\ndeclare class Store {\n    picStore: PicStore;\n    getCfg: (key: string) => Object;\n    putCfg: (key: string, value: any) => Object;\n    searchFilter: SvelteStore;\n    isSearchState: SvelteStore;\n    isFindState: SvelteStore;\n    searchEngineIndex: SvelteStore;\n    currentItems: SvelteStore;\n    dataItems: SvelteStore;\n    hasDeleteItems: SvelteStore;\n    dataVersion: SvelteStore;\n    getFireMap: () => Promise<Object>;\n    updateFireMap: (id: string) => Promise<Object>;\n    saveDataItems: (v: any) => Promise<Object>;\n    loadCleanCopyDataItems: () => Promise<Object>;\n    shareSource: (source: any) => Promise<Object>;\n    shareNodes: (nodes: ItemNode[]) => Promise<Object>;\n    exportImage: () => Promise<Object>;\n    exportImageFromSource: (source: any) => Promise<Object>;\n    decodeBase64String: (b64: string) => Promise<Object>;\n    isValidNode: (node: ItemNode) => Object;\n    cleanNodes: (nodes: ItemNode[]) => Promise<Object>;\n    parseSource: (source: string) => Object;\n    importSource: (str: string) => Promise<Object>;\n    importNodes: (nodes: ItemNode[]) => Promise<Object>;\n    clearNodes: () => Promise<Object>;\n}\n\ndeclare class App {\n    utils: Utils;\n    view: View;\n    store: Store;\n    click: (node: ItemNode) => Object\n}\n\ndeclare const app: App;\n";

	class SourceEditor {

	    /**
	     * @param {{
	     *      source:string,
	     *      callback:(source:string)=>void,
	     *      showLoading:()=>()=>void,
	     *      shareSource:(source:string)=>void,
	     *      exportImageFromSource:(source:string)=>void,
	     *      readSourceFromImage:()=>Promise<string>,
	     *      toast:(message:string)=>void,
	     *      root:HTMLElement,
	     * }} params 
	     */
	    constructor(params) {
	        this.rawSource = params.source;
	        this.source = params.source;
	        this.callback = params.callback || (() => { });
	        this.toast = params.toast || (() => { });
	        this.showLoading = params.showLoading || (() => () => { });
	        this.shareSource = params.shareSource || (() => { });
	        this.exportImageFromSource = params.exportImageFromSource || (() => { });
	        this.readSourceFromImage = params.readSourceFromImage || (() => '');
	        this.parentElement = params.root || document.body;

	        /** @type{import('monaco-editor').editor.IStandaloneCodeEditor} */
	        this.editor = null;

	        let root = document.createElement('div');
	        root.style.background = '#FFF';
	        root.style.position = 'fixed';
	        root.style.left = '0px';
	        root.style.top = '0px';
	        root.style.right = '0px';
	        root.style.bottom = '0px';
	        root.style.overflow = 'hidden';
	        root.style.zIndex = '10';

	        root.onclick = (e) => e.stopPropagation();
	        root.onkeydown = (e) => e.stopPropagation();
	        let lastPressEscapeTime = 0;
	        root.onkeyup = (e) => {
	            e.stopPropagation();
	            if (e.key == 'Escape') {
	                let time = Date.now() - lastPressEscapeTime;
	                lastPressEscapeTime = Date.now();
	                if (this.rawSource != this.editor.getValue() && time > 300) {
	                    this.toast("内容已修改，连按两次 Escape 确认取消修改。");
	                    return
	                }
	                if (time < 300) {
	                    this.toast("~ ~ ~");
	                }
	                this.closeEditor(this.editor);
	            }
	        };

	        this.root = root;
	    }

	    async show() {
	        let { source, callback, toast, shareSource, exportImageFromSource, readSourceFromImage, showLoading, root } = this;

	        this.parentElement.appendChild(root);

	        let closeLoading = showLoading();
	        let monaco = await MonacoLoader.load();
	        let monacoUtil = new MonacoUtil(monaco);
	        monacoUtil.addLogTheme();
	        monacoUtil.enableTimeFormatProvider();

	        addAppTypes(monaco);

	        let editor = monaco.editor.create(root, {
	            language: "javascript",
	            roundedSelection: false,
	            scrollBeyondLastLine: false,
	            renderWhitespace: 'all',
	            theme: "EditorTheme",
	            fontSize: 16,
	            dragAndDrop: true,
	            automaticLayout: true,
	        });

	        this.editor = editor;

	        let actionShareSource = (source) => {
	            shareSource(source);
	        };
	        let actionSave = () => {
	            callback(editor.getValue());
	            this.closeEditor(editor);
	        };
	        let actionCancel = () => {
	            this.closeEditor(editor);
	        };

	        let actionImport = async () => {
	            let source = await readSourceFromImage();
	            editor.setValue(source);
	            const sleep = (/** @type {number} */ timeout) => new Promise((resolve) => setTimeout(resolve, timeout));
	            await sleep(10);
	            editor.getAction('editor.action.formatDocument').run();
	        };

	        let actionExport = () => {
	            exportImageFromSource(editor.getValue());
	        };

	        this.sourceEditorMenu = mount(SourceEditorMenu, {
	            target: root,
	            props: {
	                actionSave,
	                actionCancel,
	                actionImport,
	                actionExport
	            }
	        });

	        monacoUtil.enableDragDrop(root, editor);
	        monacoUtil.addActions(editor);
	        monacoUtil.addAppActions(editor);
	        editor.addAction(saveAction(monaco, actionSave));
	        editor.addAction(shareSourceAction(monaco, actionShareSource));

	        editor.setValue(source);

	        // editor.getAction('editor.foldLevel2').run()
	        setTimeout(() => {
	            editor.getAction('editor.action.formatDocument').run();
	        }, 300);

	        closeLoading();
	    }

	    /**
	     * @param {import('monaco-editor').editor.IStandaloneCodeEditor} editor 
	     */
	    closeEditor(editor) {
	        setTimeout(() => {
	            if (editor) {
	                editor.dispose();
	            }
	            unmount(this.sourceEditorMenu);
	            this.root.remove();
	        }, 100);
	    }
	}

	/**
	 * @param {import('monaco-editor')} monaco 
	 */
	function saveAction(monaco, cb) {
	    return {
	        id: 'y-save-exit',
	        label: 'Save&Exit',
	        keybindings: [
	            monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,
	        ],
	        precondition: null,
	        keybindingContext: null,
	        contextMenuGroupId: 'navigation',
	        contextMenuOrder: 1.5,
	        run: function () {
	            cb();
	            return null
	        }
	    }
	}

	/**
	 * @param {import('monaco-editor')} monaco 
	 */
	function shareSourceAction(monaco, cb) {
	    return {
	        id: 'y-share-source',
	        label: 'Share Source',
	        run: function (/** @type {import("monaco-editor").editor.ICodeEditor} */ ed) {
	            MonacoUtil.editText(ed, { noChange: true }, (text) => {
	                cb(text);
	                return null
	            });
	            return null
	        }
	    }
	}

	const addedDtsMap = new WeakMap();

	/**
	 * @param {import('monaco-editor')} monaco
	 */
	function addAppTypes(monaco) {
	    if (addedDtsMap.has(monaco)) return
	    let libUri = 'ts:filename/app.d.ts';
	    monaco.typescript?.javascriptDefaults.addExtraLib(app_d_ts, libUri);
	    addedDtsMap.set(monaco, true);
	}

	/**
	 * @param {{
	 *      source:string,
	 *      callback:(source:string)=>void,
	 *      showLoading:()=>()=>void,
	 *      shareSource:(source:string)=>void,
	 *      exportImageFromSource:(source:string)=>void,
	 *      readSourceFromImage:()=>Promise<string>,
	 *      toast:(message:string)=>void
	 *      root:HTMLElement
	 * }} params 
	 */
	function editor(params) {
	    new SourceEditor(params).show();
	}

	window['Editor'] = editor;

})();
